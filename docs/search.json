[{"path":"index.html","id":"welcome","chapter":"Welcome","heading":"Welcome","text":"这是 Mastering Shiny 的在线版本，该书目前正在早期开发中，预计由 O’Reilly Media 于 2020 年底发行。Shiny 是一个使用 R 代码创建 Web 应用程序的框架。它的设计主要考虑了数据科学家的需求，为此，您可以在不了解 HTML、CSS 或 JavaScript 的情况下创建相当复杂的 Shiny 应用程序。另一方面，Shiny 并不限制您创建琐碎或预制的应用程序：它的用户界面组件可以轻松自定义或扩展，并且它的服务器使用反应式编程来让您创建您想要的任何类型的后端逻辑。\nShiny 的设计初衷是让您在刚开始使用时感觉非常简单，但您越深入地了解它的工作原理，您就越会意识到它是由通用构建块构建而成，而这些构建块背后都有强大的软件工程原理。如今，Shiny 的应用领域和行业几乎与 R 本身一样多。\n它在学术界被用作统计概念的教学工具，一种让本科生对学习编写代码感到兴奋的方式，一种炫耀新颖统计方法或模型的引人注目的媒介。\n大型制药公司使用它来加速药物开发过程中科学家和分析师之间的合作。\n硅谷科技公司使用它来设置包含高级分析的实时指标仪表盘。本书旨在帮助您从对 Shiny 一无所知到成为一名专家开发人员，能够编写仍然可维护且高性能的大型复杂应用程序。您将深入了解 Shiny 背后的反应式编程模型，并构建一个包含有用技术的工具箱来解决常见的应用程序挑战。","code":""},{"path":"index.html","id":"license","chapter":"Welcome","heading":"License","text":"book licensed Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.code samples book licensed Creative Commons CC0 1.0 Universal (CC0 1.0), .e. public domain.","code":""},{"path":"preface.html","id":"preface","chapter":"Preface","heading":"Preface","text":"","code":""},{"path":"preface.html","id":"what-is-shiny","chapter":"Preface","heading":"0.1 What is Shiny?","text":"如果您以前从未使用过 Shiny，欢迎！\nShiny 是一个 R 包，可让您轻松创建丰富的交互式 Web 应用程序。\nShiny 允许您在 R 中进行工作并通过网络浏览器公开它，以便任何人都可以使用它。\nShiny 让您可以轻松地以最少的痛苦来生成精美的 Web 应用程序，从而使您看起来很棒。在过去，创建 Web 应用程序对于大多数 R 用户来说都很困难，因为：您需要深入了解 HTML、CSS 和 JavaScript 等 Web 技术。您需要深入了解 HTML、CSS 和 JavaScript 等 Web 技术。制作复杂的交互式应用程序需要仔细分析交互流，以确保当输入更改时，仅更新相关的输出。制作复杂的交互式应用程序需要仔细分析交互流，以确保当输入更改时，仅更新相关的输出。Shiny 使 R 程序员可以通过以下方式更轻松地创建 Web 应用程序：提供一组精心策划的用户界面（简称 UI）功能，用于生成常见任务所需的 HTML、CSS 和 JavaScript。\n这意味着您不需要了解 HTML/CSS/JavaScript 的详细信息，除非您想要超越 Shiny 为您提供的基础。提供一组精心策划的用户界面（简称 UI）功能，用于生成常见任务所需的 HTML、CSS 和 JavaScript。\n这意味着您不需要了解 HTML/CSS/JavaScript 的详细信息，除非您想要超越 Shiny 为您提供的基础。引入一种称为反应式编程（reactive programming）的新编程风格，它自动跟踪代码片段的依赖关系。\n这意味着每当输入发生变化时，Shiny 都可以自动找出如何做最少的工作来更新所有相关的输出。引入一种称为反应式编程（reactive programming）的新编程风格，它自动跟踪代码片段的依赖关系。\n这意味着每当输入发生变化时，Shiny 都可以自动找出如何做最少的工作来更新所有相关的输出。人们使用 Shiny 来：创建跟踪重要的高级性能指标的仪表盘，同时促进深入了解需要更多调查的指标。创建跟踪重要的高级性能指标的仪表盘，同时促进深入了解需要更多调查的指标。用交互式应用程序替换数百页 PDF，让用户可以跳转到他们关心的结果的确切部分。用交互式应用程序替换数百页 PDF，让用户可以跳转到他们关心的结果的确切部分。通过信息丰富的可视化和交互式敏感性分析，向非技术受众传达复杂的模型。通过信息丰富的可视化和交互式敏感性分析，向非技术受众传达复杂的模型。为常见工作流程提供自助数据分析，用 Shiny 应用程序取代电子邮件请求，允许人们上传自己的数据并执行标准分析。\n您可以为没有编程技能的用户提供复杂的 R 分析。为常见工作流程提供自助数据分析，用 Shiny 应用程序取代电子邮件请求，允许人们上传自己的数据并执行标准分析。\n您可以为没有编程技能的用户提供复杂的 R 分析。创建用于教授统计学和数据科学概念的交互式演示，使学习者能够调整输入并观察分析中这些变化的下游影响。创建用于教授统计学和数据科学概念的交互式演示，使学习者能够调整输入并观察分析中这些变化的下游影响。简而言之，Shiny 使您能够将一些 R 超能力传递给任何可以使用网络的人。","code":""},{"path":"preface.html","id":"who-should-read-this-book","chapter":"Preface","heading":"0.2 Who should read this book?","text":"本书针对两种主要读者：有兴趣了解 Shiny 以便将他们的分析转化为交互式 Web 应用程序的 R 用户。\n为了充分利用本书，您应该能够熟练地使用 R 进行数据分析，并且至少应该编写一些函数。有兴趣了解 Shiny 以便将他们的分析转化为交互式 Web 应用程序的 R 用户。\n为了充分利用本书，您应该能够熟练地使用 R 进行数据分析，并且至少应该编写一些函数。现有的 Shiny 用户希望提高对 Shiny 基础理论的了解，以便更快、更轻松地编写更高质量的应用程序。\n如果您的应用程序开始变得越来越大并且您开始在管理复杂性方面遇到问题，那么您应该会发现这本书特别有帮助。现有的 Shiny 用户希望提高对 Shiny 基础理论的了解，以便更快、更轻松地编写更高质量的应用程序。\n如果您的应用程序开始变得越来越大并且您开始在管理复杂性方面遇到问题，那么您应该会发现这本书特别有帮助。","code":""},{"path":"preface.html","id":"what-will-you-learn","chapter":"Preface","heading":"0.3 What will you learn?","text":"本书分为四个部分：在 “Getting started” 部分，您将学习 Shiny 的基础知识，以便您可以尽快启动并运行。\n您将了解应用程序结构的基础知识、有用的 UI 组件以及响应式编程的基础知识。在 “Getting started” 部分，您将学习 Shiny 的基础知识，以便您可以尽快启动并运行。\n您将了解应用程序结构的基础知识、有用的 UI 组件以及响应式编程的基础知识。“Shiny action” 部分建立在帮助您解决常见问题的基础知识之上，包括向用户提供反馈、上传和下载数据、使用代码生成 UI、减少代码重复以及使用 Shiny 对 tidyverse 进行编程。“Shiny action” 部分建立在帮助您解决常见问题的基础知识之上，包括向用户提供反馈、上传和下载数据、使用代码生成 UI、减少代码重复以及使用 Shiny 对 tidyverse 进行编程。在 “Mastering reactivity” 部分，您将深入了解反应式编程的理论和实践，这是 Shiny 的编程范例。\n如果您是现有的 Shiny 用户，您将从本章中获得最大的价值，因为它将为您提供坚实的理论基础，使您能够创建专门针对您的问题定制的新工具。在 “Mastering reactivity” 部分，您将深入了解反应式编程的理论和实践，这是 Shiny 的编程范例。\n如果您是现有的 Shiny 用户，您将从本章中获得最大的价值，因为它将为您提供坚实的理论基础，使您能够创建专门针对您的问题定制的新工具。最后，在 “Best practices” 部分，我们将完成对使您的 Shiny 应用程序在生产中良好运行的有用技术的调查。\n您将学习如何将复杂的应用程序分解为函数和模块，如何使用包来组织代码，如何测试代码以确保其正确，以及如何衡量和提高性能。最后，在 “Best practices” 部分，我们将完成对使您的 Shiny 应用程序在生产中良好运行的有用技术的调查。\n您将学习如何将复杂的应用程序分解为函数和模块，如何使用包来组织代码，如何测试代码以确保其正确，以及如何衡量和提高性能。","code":""},{"path":"preface.html","id":"what-wont-you-learn","chapter":"Preface","heading":"0.4 What won’t you learn?","text":"本书的重点是制作有效的 Shiny 应用程序并理解反应式的基本理论。\n我将尽力展示数据科学、R 编程和软件工程的最佳实践，但您需要其他参考资料来掌握这些重要技能。\n如果您喜欢我在本书中的写作，您可能会喜欢我关于这些主题的其他书籍：R Data Science、Advanced R 和 R Packages。还有一些特定于 Shiny 的重要主题我没有涉及：本书仅涵盖内置的用户界面工具包。\n这并没有提供最性感的设计，但它很容易学习并且可以让你走得很远。\n如果您有其他需求（或者只是对默认设置感到厌倦），还有许多其他软件包可以提供替代前端。\n参见 Section ?? 获取更多细节。本书仅涵盖内置的用户界面工具包。\n这并没有提供最性感的设计，但它很容易学习并且可以让你走得很远。\n如果您有其他需求（或者只是对默认设置感到厌倦），还有许多其他软件包可以提供替代前端。\n参见 Section ?? 获取更多细节。部署 Shiny 应用程序。\n将 Shiny “投入生产” 超出了本书的讨论范围，因为每个公司的情况差异很大，而且其中大部分与 R 无关（大多数挑战往往是文化或组织方面的，而不是技术方面的）。\n如果您在生产中不熟悉 Shiny，我建议您从 Joe Cheng’s 2019 rstudio::conf keynote: https://rstudio.com/resources/rstudioconf-2019/shiny--production-principles-practices--tools/ 开始。\n这将为您提供基本情况，广泛讨论将 Shiny 投入生产需要什么以及如何克服您可能面临的一些挑战。\n完成此操作后，请访问 RStudio Connect website，了解用于在公司内部署应用程序的 RStudio 产品，并访问 Shiny website了解其他常见部署场景。部署 Shiny 应用程序。\n将 Shiny “投入生产” 超出了本书的讨论范围，因为每个公司的情况差异很大，而且其中大部分与 R 无关（大多数挑战往往是文化或组织方面的，而不是技术方面的）。\n如果您在生产中不熟悉 Shiny，我建议您从 Joe Cheng’s 2019 rstudio::conf keynote: https://rstudio.com/resources/rstudioconf-2019/shiny--production-principles-practices--tools/ 开始。\n这将为您提供基本情况，广泛讨论将 Shiny 投入生产需要什么以及如何克服您可能面临的一些挑战。\n完成此操作后，请访问 RStudio Connect website，了解用于在公司内部署应用程序的 RStudio 产品，并访问 Shiny website了解其他常见部署场景。","code":""},{"path":"preface.html","id":"prerequisites","chapter":"Preface","heading":"0.5 Prerequisites","text":"在我们继续之前，请确保您拥有本书所需的所有软件：R：如果你还没有安装 R，你可能读错书了；我假设您对本书中的 R 有基本的了解。\n如果您想学习如何使用 R，我会推荐我的 R Data Science，它旨在帮助您轻松上手并运行 R。R：如果你还没有安装 R，你可能读错书了；我假设您对本书中的 R 有基本的了解。\n如果您想学习如何使用 R，我会推荐我的 R Data Science，它旨在帮助您轻松上手并运行 R。RStudio：RStudio 是一个免费的开源 R 集成开发环境 (IDE)。\n虽然您可以在任何 R 环境（包括 R GUI 和 ESS）中编写和使用 Shiny 应用程序，但 RStudio 有一些专门用于创作、调试和部署 Shiny 应用程序的出色功能。\n我们建议您尝试一下，但并不需要使用 Shiny 或本书即可获得成功。\n您可以从 https://www.rstudio.com/products/rstudio/download 下载 RStudio Desktop。RStudio：RStudio 是一个免费的开源 R 集成开发环境 (IDE)。\n虽然您可以在任何 R 环境（包括 R GUI 和 ESS）中编写和使用 Shiny 应用程序，但 RStudio 有一些专门用于创作、调试和部署 Shiny 应用程序的出色功能。\n我们建议您尝试一下，但并不需要使用 Shiny 或本书即可获得成功。\n您可以从 https://www.rstudio.com/products/rstudio/download 下载 RStudio Desktop。R packages：本书使用了一堆 R 包。\n您可以通过运行以下命令一次性安装它们：\n\ninstall.packages(c(\n  \"gapminder\", \"ggforce\", \"gh\", \"globals\", \"openintro\", \"profvis\", \n  \"RSQLite\", \"shiny\", \"shinycssloaders\", \"shinyFeedback\", \n  \"shinythemes\", \"testthat\", \"thematic\", \"tidyverse\", \"vroom\", \n  \"waiter\", \"xml2\", \"zeallot\" \n))\n如果您过去下载过 Shiny，请确保您的版本至少为 1.6.0。R packages：本书使用了一堆 R 包。\n您可以通过运行以下命令一次性安装它们：如果您过去下载过 Shiny，请确保您的版本至少为 1.6.0。","code":"\ninstall.packages(c(\n  \"gapminder\", \"ggforce\", \"gh\", \"globals\", \"openintro\", \"profvis\", \n  \"RSQLite\", \"shiny\", \"shinycssloaders\", \"shinyFeedback\", \n  \"shinythemes\", \"testthat\", \"thematic\", \"tidyverse\", \"vroom\", \n  \"waiter\", \"xml2\", \"zeallot\" \n))"},{"path":"preface.html","id":"acknowledgements","chapter":"Preface","heading":"0.6 Acknowledgements","text":"这本书是公开撰写的，完成后各章节会在 Twitter 上发布广告。\n这确实是社区的努力：许多人阅读草稿、修正拼写错误、提出改进建议并贡献内容。\n如果没有这些贡献者，这本书就不会这么好，我非常感谢他们的帮助。big thank 83 people contributed specific improvements via GitHub pull requests (alphabetical order username): Adam Pearce (@1wheel), Adi Sarid (@adisarid), Alexandros Melemenidis (@alex-m-ffm), Anton Klåvus (@antonvsdata), Betsy Rosalen (@betsyrosalen), Michael Beigelmacher (@brooklynbagel), Bryan Smith (@BSCowboy), c1au6io_hh (@c1au6i0), @canovasjm, Chris Beeley (@ChrisBeeley), @chsafouane, Chuliang Xiao (@ChuliangXiao), Conor Neilson (@condwanaland), @d-edison, Dean Attali (@daattali), DanielDavid521 (@Danieldavid521), David Granjon (@DivadNojnarg), Eduardo Vásquez (@edovtp), Emil Hvitfeldt (@EmilHvitfeldt), Emilio (@emilopezcano), Emily Riederer (@emilyriederer), Eric Simms (@esimms999), Federico Marini (@federicomarini), Frederik Kok Hansen (@fkoh111), Frans van Dunné (@FvD), Giorgio Comai (@giocomai), Hedley (@heds1), Henning (@henningsway), Hlynur (@hlynurhallgrims), @hsm207, @jacobxk, James Pooley (@jamespooley), Joe Cheng (@jcheng5), Julien Colomb (@jcolomb), Juan C Rodriguez (@jcrodriguez1989), Jennifer (Jenny) Bryan (@jennybc), Jim Hester (@jimhester), Joachim Gassen (@joachim-gassen), Jon Calder (@jonmcalder), Jonathan Carroll (@jonocarroll), Julian Stanley (@julianstanley), @jyuu, @kaanpekel, Karandeep Singh (@kdpsingh), Robert Kirk DeLisle (@KirkDCO), Elaine (@loomalaine), Malcolm Barrett (@malcolmbarrett), Marly Gotti (@marlycormar), Matthew Wilson (@MattW-Geospatial), Matthew T. Warkentin (@mattwarkentin), Mauro Lepore (@maurolepore), Maximilian Rohde (@maxdrohde), Matthew Berginski (@mbergins), Michael Dewar (@michael-dewar), Mine Cetinkaya-Rundel (@mine-cetinkaya-rundel), Maria Paula Caldas (@mpaulacaldas), nthobservation (@nthobservation), Pietro Monticone (@pitmonticone), psychometrician (@psychometrician), Ram Thapa (@raamthapa), Janko Thyson (@rappster), Rebecca Janis (@rbjanis), Tom Palmer (@remlapmot), Russ Hyde (@russHyde), Barret Schloerke (@schloerke), Scott (@scottyd22), Matthew Sedaghatfar (@sedaghatfar), Shixiang Wang (@ShixiangWang), Praer (Suthira Owlarn) (@sowla), Sébastien Rochette (@statnmap), @stevensbr, André Calero Valdez (@Sumidu), Tanner Stauss (@tmstauss), Tony Fujs (@tonyfujs), Stefan Moog (@trekonom), Jeff Allen (@trestletech), Trey Gilliland (@treygilliland), Albrecht (@Tungurahua), Valeri Voev (@ValeriVoev), Vickus (@Vickusr), William Doane (@WilDoane), 黄湘云 (@XiangyunHuang), gXcloud (@xwydq).","code":"#> Warning: package 'dplyr' was built under R version 4.2.3"},{"path":"preface.html","id":"colophon","chapter":"Preface","heading":"0.7 Colophon","text":"本书是使用 bookdown 在 RStudio 中编写的。\n该网站由 netlify 托管，并在 Github Actions 每次提交后自动更新。完整的源代码可以从 GitHub 获取。本书的这个版本是使用 R 版本 R version 4.2.0 (2022-04-22 ucrt) 和以下软件包构建的：","code":""},{"path":"basic-intro.html","id":"basic-intro","chapter":"Introduction","heading":"Introduction","text":"接下来四章的目标是让您尽快编写 Shiny 应用程序。\n在 Chapter 1 中，我将从小而完整的开始，向您展示应用程序的所有主要部分以及它们如何组合在一起。\n然后在 Chapters 2 和 3 您将开始深入了解 Shiny 应用程序的两个主要部分的详细信息：前端（用户在浏览器中看到的内容）和后端（使其全部正常工作的代码）。\n我们将在 Chapter ?? 结束，通过案例研究来帮助巩固您迄今为止学到的概念。","code":""},{"path":"basic-app.html","id":"basic-app","chapter":"1 Your first Shiny app","heading":"1 Your first Shiny app","text":"","code":""},{"path":"basic-app.html","id":"introduction","chapter":"1 Your first Shiny app","heading":"1.1 Introduction","text":"在本章中，我们将创建一个简单的 Shiny app。\n我将首先向您展示 Shiny app 所需的最小样板，然后您将学习如何启动和停止它。\n接下来，您将学习每个 Shiny app 的两个关键组件：定义 app 外观的 UI（user interface 的缩写），和定义 app 工作方式的 server function。\nShiny 使用响应式编程（reactive programming）在输入变化时自动更新输出，因此我们将通过学习 Shiny app 的第三个重要组件来结束本章：响应式表达式（reactive expressions）。如果您尚未安装 Shiny，请立即安装：如果您已经安装了 Shiny，请使用 packageVersion(\"shiny\") 检查您是否拥有 1.5.0 或更高版本。然后加载当前的 R 会话：","code":"\ninstall.packages(\"shiny\")\nlibrary(shiny)"},{"path":"basic-app.html","id":"create-app","chapter":"1 Your first Shiny app","heading":"1.2 Create app directory and file","text":"有多种方法可以创建 Shiny app。\n最简单的方法是为您的 app 创建一个新目录，并在其中放置一个名为 app.R 的文件。\n这个 app.R 文件将用于告诉 Shiny 您的 app 应该如何显示以及它应该如何运行。通过创建一个新目录并添加一个如下所示的 app.R 文件来尝试一下：这是一个完整但微不足道的 Shiny app！\n仔细观察上面的代码，我们的 app.R 做了四件事：它调用 library(shiny) 来加载 shiny 包。它调用 library(shiny) 来加载 shiny 包。它定义了用户界面，即人类与之交互的 HTML 网页。\n在本例中，它是一个包含 “Hello, world!” 字样的页面。它定义了用户界面，即人类与之交互的 HTML 网页。\n在本例中，它是一个包含 “Hello, world!” 字样的页面。它通过定义 server 函数来指定我们 app 的行为。\n它目前是空的，所以我们的应用程序不执行任何操作，但我们很快就会回来重新讨论这个问题。它通过定义 server 函数来指定我们 app 的行为。\n它目前是空的，所以我们的应用程序不执行任何操作，但我们很快就会回来重新讨论这个问题。它执行 shinyApp(ui, server) 来从 UI 和 server 构建并启动 Shiny app。它执行 shinyApp(ui, server) 来从 UI 和 server 构建并启动 Shiny app。RStudio Tip: 在 RStudio 中创建一个新的 app 有两种便捷的方法：单击 File | New Project 创建一个新目录和一个包含基本 app 的 app.R 文件，然后选择 New Directory 和 Shiny Web Application。单击 File | New Project 创建一个新目录和一个包含基本 app 的 app.R 文件，然后选择 New Directory 和 Shiny Web Application。如果您已经创建了 app.R 文件，则可以通过键入 “shinyapp” 并按 Shift+Tab 快速添加 app 样板。如果您已经创建了 app.R 文件，则可以通过键入 “shinyapp” 并按 Shift+Tab 快速添加 app 样板。","code":"\nlibrary(shiny)\nui <- fluidPage(\n  \"Hello, world!\"\n)\nserver <- function(input, output, session) {\n}\nshinyApp(ui, server)"},{"path":"basic-app.html","id":"running","chapter":"1 Your first Shiny app","heading":"1.3 Running and stopping","text":"您可以通过以下几种方式运行此 app：单击文档工具栏中的 Run App (Figure 1.1) 按钮。单击文档工具栏中的 Run App (Figure 1.1) 按钮。使用键盘快捷键：Cmd/Ctrl + Shift + Enter。使用键盘快捷键：Cmd/Ctrl + Shift + Enter。如果您不使用 RStudio，您可以 (source())1 整个文档，或者使用包含 app.R 的目录的路径调用 shiny::runApp()。如果您不使用 RStudio，您可以 (source())1 整个文档，或者使用包含 app.R 的目录的路径调用 shiny::runApp()。\nFigure 1.1: Run App 按钮位于源窗格的右上角。\n选择这些选项之一，并检查您是否看到与 Figure 1.2 中相同的 app。\n恭喜！\n您已经制作了第一个 Shiny app。\nFigure 1.2: 当您运行上面的代码时，您将看到一个非常基本的 shiny app\n在关闭 app 之前，请返回 RStudio 并查看 R console。\n你会注意到它说的是这样的：这告诉您可以找到您的 app 的 URL：127.0.0.1 是一个标准地址，表示“这台计算机”，3827 是一个随机分配的端口号（port）。\n您可以在任何兼容的2网络浏览器中输入该 URL 以打开你的 app 的另一个副本。另请注意 R 正忙：R 提示不可见，并且控制台工具栏显示停止标志图标。\n当 Shiny app 运行时，它会“阻止” R console。\n这意味着在 Shiny app 停止之前，您无法在 R console 上运行新命令。您可以使用以下任一选项停止 app 并返回对 console 的访问权限：单击 R console 工具栏上的停止标志图标。单击 R console 工具栏上的停止标志图标。单击 console，然后按 Esc（如果您不使用 RStudio，则按 Ctrl + C）。单击 console，然后按 Esc（如果您不使用 RStudio，则按 Ctrl + C）。关闭 Shiny app 窗口。关闭 Shiny app 窗口。Shiny app 开发的基本工作流程是编写一些代码，启动 app，使用 app，编写更多代码，然后重复。\n如果您使用的是 RStudio，您甚至不需要停止并重新启动应用程序即可查看更改 — 您可以按工具箱中的 Reload app 按钮或使用 Cmd/Ctrl + Shift + Enter 键盘快捷键。\n我将在 Chapter ?? 中介绍其他工作流程模式。","code":"\n#> Listening on http://127.0.0.1:3827"},{"path":"basic-app.html","id":"adding-ui","chapter":"1 Your first Shiny app","heading":"1.4 Adding UI controls","text":"接下来，我们将向 UI 添加一些输入和输出，这样它就不会那么小了。\n我们将制作一个非常简单的 app，向您显示 datasets 包中包含的所有内置 data frames。将您的 ui 替换为以下代码：此示例使用四个新函数：fluidPage() 是一个 layout function，用于设置页面的基本视觉结构。\n您将在 Section ?? 中了解有关它们的更多信息。fluidPage() 是一个 layout function，用于设置页面的基本视觉结构。\n您将在 Section ?? 中了解有关它们的更多信息。selectInput() 是一个 input control，允许用户通过提供值（value）与 app 交互。\n在本例中，它是一个带有 “Dataset” 标签的选择框，可让您选择 R 附带的内置数据集之一。\n您将在 Section 2.2 中了解有关输入的更多信息。selectInput() 是一个 input control，允许用户通过提供值（value）与 app 交互。\n在本例中，它是一个带有 “Dataset” 标签的选择框，可让您选择 R 附带的内置数据集之一。\n您将在 Section 2.2 中了解有关输入的更多信息。verbatimTextOutput() 和 tableOutput() 是 output controls，它们告诉 Shiny 将渲染的输出放在哪里（我们稍后会介绍如何放置）。\nverbatimTextOutput() 显示代码，tableOutput() 显示表格。\n您将在 Section 2.3 中了解有关输出的更多信息。verbatimTextOutput() 和 tableOutput() 是 output controls，它们告诉 Shiny 将渲染的输出放在哪里（我们稍后会介绍如何放置）。\nverbatimTextOutput() 显示代码，tableOutput() 显示表格。\n您将在 Section 2.3 中了解有关输出的更多信息。布局函数、输入和输出有不同的用途，但它们本质上是相同的：它们都是生成 HTML 的奇特方法，如果您在 Shiny app 之外调用其中任何一个，您将看到 HTML 在控制台打印出来。\n不要害怕四处探索，看看这些不同的布局和控件在幕后是如何工作的。继续并再次运行该 app。\n现在您将看到 Figure 1.3，这是一个包含选择框的页面。\n我们只看到输入，看不到两个输出，因为我们还没有告诉 Shiny 输入和输出是如何关联的。\nFigure 1.3: datasets app UI\n","code":"\nui <- fluidPage(\n  selectInput(\"dataset\", label = \"Dataset\", choices = ls(\"package:datasets\")),\n  verbatimTextOutput(\"summary\"),\n  tableOutput(\"table\")\n)"},{"path":"basic-app.html","id":"server-function","chapter":"1 Your first Shiny app","heading":"1.5 Adding behaviour","text":"接下来，我们将通过在 server 函数中定义输出来使输出变得生动。Shiny 使用响应式编程使 apps 具有交互性。\n您将在 Chapter 3 中了解有关响应式编程的更多信息，但现在请注意，它涉及告诉 Shiny 如何执行计算，而不是命令 Shiny 实际执行计算。\n这就像给某人一个菜谱和要求他们给你做一个三明治之间的区别。我们将通过提供这些输出的“配方”来告诉 Shiny 如何在示例 app 中填写 summary 和 table 输出。\n将空的 server 函数替换为：赋值运算符 (<-) 的左侧，output$ID，表示您正在为具有该 ID 的 Shiny 输出提供配方。\n赋值的右侧使用特定的渲染函数（render function）来包装您提供的一些代码。\n每个 render{Type} 函数都旨在生成特定类型的输出（例如文本、表格和绘图），并且通常与 {type}Output 函数配对。\n例如，在此 app 中，renderPrint() 与 verbatimTextOutput() 配合使用，以显示固定宽度（逐字）文本的统计摘要，而 renderTable() 与 tableOutput() 配合使用，以在表格中显示输入数据。再次运行 app 并进行测试，观察更改输入时输出会发生什么情况。\nFigure 1.4 显示了打开 app 时应该看到的内容。\nFigure 1.4: 现在我们已经提供了连接输出和输入的 server function，我们有了一个功能齐全的 app\n请注意，每当您更改输入数据集时，摘要和表格都会更新。\n这种依赖关系是隐式创建的，因为我们在输出函数中引用了 input$dataset。\ninput$dataset 填充了带有 id dataset 的 UI 组件的当前值，并且每当该值发生变化时都会导致输出自动更新。\n这是响应式（reactivity）的本质：当输入发生变化时，输出会自动做出响应（重新计算）。","code":"\nserver <- function(input, output, session) {\n  output$summary <- renderPrint({\n    dataset <- get(input$dataset, \"package:datasets\")\n    summary(dataset)\n  })\n  \n  output$table <- renderTable({\n    dataset <- get(input$dataset, \"package:datasets\")\n    dataset\n  })\n}"},{"path":"basic-app.html","id":"reactive-expr","chapter":"1 Your first Shiny app","heading":"1.6 Reducing duplication with reactive expressions","text":"即使在这个简单的示例中，我们也有一些重复的代码：两个输出中都存在以下行。在每种编程中，重复代码都是不好的做法；它可能会造成计算浪费，更重要的是，它增加了维护或调试代码的难度。\n这在这里并不重要，但我想在一个非常简单的上下文中说明基本思想。不幸的是，这些方法在这里都不起作用，原因您将在 Section ?? 中了解，并且我们需要一种新机制：响应式表达式（reactive expressions）。您可以通过将代码块包装在 reactive({...}) 中并将其分配给变量来创建响应式表达式，然后通过像函数一样调用它来使用响应式表达式。\n但是，虽然看起来像是在调用函数，但响应式表达式有一个重要的区别：它仅在第一次调用时运行，然后缓存其结果，直到需要更新为止。我们可以更新我们的 server() 以使用响应式表达式，如下所示。\n该 app 的行为相同，但工作效率更高一些，因为它只需要检索数据集一次，而不是两次。我们将多次回到响应式编程，但即使具备输入、输出和响应式表达式的粗略知识，也可以构建非常有用的 Shiny apps！","code":"\ndataset <- get(input$dataset, \"package:datasets\")\nserver <- function(input, output, session) {\n  # Create a reactive expression\n  dataset <- reactive({\n    get(input$dataset, \"package:datasets\")\n  })\n\n  output$summary <- renderPrint({\n    # Use a reactive expression by calling it like a function\n    summary(dataset())\n  })\n  \n  output$table <- renderTable({\n    dataset()\n  })\n}"},{"path":"basic-app.html","id":"summary","chapter":"1 Your first Shiny app","heading":"1.7 Summary","text":"在本章中，您创建了一个简单的 app — 它不是很令人兴奋或有用，但您看到了使用现有的 R 知识构建一个 web app 是多么容易。\n在接下来的两章中，您将了解有关用户界面和响应式编程的更多信息，这是 Shiny 的两个基本构建块。\n现在是获取 Shiny cheatsheet 的好时机。\n这是一个很好的资源，可以帮助您回忆 Shiny app 的主要组件。\nFigure 1.5: Shiny cheatsheet, available https://www.rstudio.com/resources/cheatsheets/\n","code":""},{"path":"basic-app.html","id":"exercises","chapter":"1 Your first Shiny app","heading":"1.8 Exercises","text":"创建一个通过名字向用户打招呼的 app。\n您还不知道执行此操作所需的所有函数，因此我在下面添加了一些代码行。\n考虑一下您将使用哪些行，然后将它们复制并粘贴到 Shiny app 中的正确位置。\n\ntableOutput(\"mortgage\")\noutput$greeting <- renderText({\n  paste0(\"Hello \", input$name)\n})\nnumericInput(\"age\", \"old ?\", value = NA)\ntextInput(\"name\", \"name?\")\ntextOutput(\"greeting\")\noutput$histogram <- renderPlot({\n  hist(rnorm(1000))\n}, res = 96)创建一个通过名字向用户打招呼的 app。\n您还不知道执行此操作所需的所有函数，因此我在下面添加了一些代码行。\n考虑一下您将使用哪些行，然后将它们复制并粘贴到 Shiny app 中的正确位置。假设您的朋友想要设计一个 app，允许用户设置 1 到 50 之间的数字 (x)，并显示该数字乘以 5 的结果。\n这是他们的第一次尝试：\n\nlibrary(shiny)\n\nui <- fluidPage(\n  sliderInput(\"x\", label = \"x \", min = 1, max = 50, value = 30),\n  \"x times 5 \",\n  textOutput(\"product\")\n)\n\nserver <- function(input, output, session) {\n  output$product <- renderText({ \n    x * 5\n  })\n}\n\nshinyApp(ui, server)\n但不幸的是它有一个错误：\n\n你能帮助他们找到并纠正错误吗？假设您的朋友想要设计一个 app，允许用户设置 1 到 50 之间的数字 (x)，并显示该数字乘以 5 的结果。\n这是他们的第一次尝试：但不幸的是它有一个错误：你能帮助他们找到并纠正错误吗？扩展上一个练习中的 app，以允许用户设置乘数 y 的值，以便应用程序生成 x * y 的值。\n最终结果应该是这样的：\n扩展上一个练习中的 app，以允许用户设置乘数 y 的值，以便应用程序生成 x * y 的值。\n最终结果应该是这样的：使用以下 app，它为上一个练习中描述的最后一个 app 添加了一些附加功能。\n什么是新的？\n如何通过使用响应式表达式来减少 app 中重复代码的数量。\n\nlibrary(shiny)\n\nui <- fluidPage(\n  sliderInput(\"x\", \"x \", min = 1, max = 50, value = 30),\n  sliderInput(\"y\", \"y \", min = 1, max = 50, value = 5),\n  \", (x * y) \", textOutput(\"product\"),\n  \", (x * y) + 5 \", textOutput(\"product_plus5\"),\n  \"(x * y) + 10 \", textOutput(\"product_plus10\")\n)\n\nserver <- function(input, output, session) {\n  output$product <- renderText({ \n    product <- input$x * input$y\n    product\n  })\n  output$product_plus5 <- renderText({ \n    product <- input$x * input$y\n    product + 5\n  })\n  output$product_plus10 <- renderText({ \n    product <- input$x * input$y\n    product + 10\n  })\n}\n\nshinyApp(ui, server)使用以下 app，它为上一个练习中描述的最后一个 app 添加了一些附加功能。\n什么是新的？\n如何通过使用响应式表达式来减少 app 中重复代码的数量。以下 app 与您在本章前面看到的 app 非常相似：您从包中选择一个数据集（这次我们使用 ggplot2 包），然后该 app 打印出数据的摘要和绘图。\n它还遵循良好实践并利用响应式表达式来避免代码冗余。\n然而，下面提供的代码中存在三个错误。\n你能找到并修复它们吗？\n\nlibrary(shiny)\nlibrary(ggplot2)\n#> Warning: package 'ggplot2' built R version 4.2.3\n\ndatasets <- c(\"economics\", \"faithfuld\", \"seals\")\nui <- fluidPage(\n  selectInput(\"dataset\", \"Dataset\", choices = datasets),\n  verbatimTextOutput(\"summary\"),\n  tableOutput(\"plot\")\n)\n\nserver <- function(input, output, session) {\n  dataset <- reactive({\n    get(input$dataset, \"package:ggplot2\")\n  })\n  output$summmry <- renderPrint({\n    summary(dataset())\n  })\n  output$plot <- renderPlot({\n    plot(dataset)\n  }, res = 96)\n}\n\nshinyApp(ui, server)以下 app 与您在本章前面看到的 app 非常相似：您从包中选择一个数据集（这次我们使用 ggplot2 包），然后该 app 打印出数据的摘要和绘图。\n它还遵循良好实践并利用响应式表达式来避免代码冗余。\n然而，下面提供的代码中存在三个错误。\n你能找到并修复它们吗？","code":"\ntableOutput(\"mortgage\")\noutput$greeting <- renderText({\n  paste0(\"Hello \", input$name)\n})\nnumericInput(\"age\", \"How old are you?\", value = NA)\ntextInput(\"name\", \"What's your name?\")\ntextOutput(\"greeting\")\noutput$histogram <- renderPlot({\n  hist(rnorm(1000))\n}, res = 96)\nlibrary(shiny)\n\nui <- fluidPage(\n  sliderInput(\"x\", label = \"If x is\", min = 1, max = 50, value = 30),\n  \"then x times 5 is\",\n  textOutput(\"product\")\n)\n\nserver <- function(input, output, session) {\n  output$product <- renderText({ \n    x * 5\n  })\n}\n\nshinyApp(ui, server)\nlibrary(shiny)\n\nui <- fluidPage(\n  sliderInput(\"x\", \"If x is\", min = 1, max = 50, value = 30),\n  sliderInput(\"y\", \"and y is\", min = 1, max = 50, value = 5),\n  \"then, (x * y) is\", textOutput(\"product\"),\n  \"and, (x * y) + 5 is\", textOutput(\"product_plus5\"),\n  \"and (x * y) + 10 is\", textOutput(\"product_plus10\")\n)\n\nserver <- function(input, output, session) {\n  output$product <- renderText({ \n    product <- input$x * input$y\n    product\n  })\n  output$product_plus5 <- renderText({ \n    product <- input$x * input$y\n    product + 5\n  })\n  output$product_plus10 <- renderText({ \n    product <- input$x * input$y\n    product + 10\n  })\n}\n\nshinyApp(ui, server)\nlibrary(shiny)\nlibrary(ggplot2)\n#> Warning: package 'ggplot2' was built under R version 4.2.3\n\ndatasets <- c(\"economics\", \"faithfuld\", \"seals\")\nui <- fluidPage(\n  selectInput(\"dataset\", \"Dataset\", choices = datasets),\n  verbatimTextOutput(\"summary\"),\n  tableOutput(\"plot\")\n)\n\nserver <- function(input, output, session) {\n  dataset <- reactive({\n    get(input$dataset, \"package:ggplot2\")\n  })\n  output$summmry <- renderPrint({\n    summary(dataset())\n  })\n  output$plot <- renderPlot({\n    plot(dataset)\n  }, res = 96)\n}\n\nshinyApp(ui, server)"},{"path":"basic-ui.html","id":"basic-ui","chapter":"2 Basic UI","heading":"2 Basic UI","text":"","code":""},{"path":"basic-ui.html","id":"introduction-1","chapter":"2 Basic UI","heading":"2.1 Introduction","text":"现在您已经掌握了一个基本的 app，我们可以开始探索让 Shiny 发挥作用的细节。\n正如您在上一章中看到的，Shiny 鼓励将生成用户界面（前端）的代码与驱动 app 行为的代码（后端）分离。在本章中，我们将重点关注前端，并带您快速了解 Shiny 提供的 HTML 输入和输出。\n这使您能够捕获多种类型的数据并显示多种类型的 R 输出。\n你还没有很多方法将输入和输出拼接在一起，但我们将在 Chapter ?? 中回到这一点。在这里，我将主要坚持 Shiny 本身内置的输入和输出。\n然而，有一个丰富且充满活力的扩展包社区，例如 shinyWidgets、colorpicker、和 sorttable。\n您可以在 https://github.com/nanxstats/awesome-shiny-extensions 找到全面的、积极维护的其他软件包列表，由 Nan Xiao 维护。像往常一样，我们将首先加载 shiny 包：","code":"\nlibrary(shiny)"},{"path":"basic-ui.html","id":"inputs","chapter":"2 Basic UI","heading":"2.2 Inputs","text":"正如我们在上一章中看到的，您可以使用 sliderInput()、selectInput()、textInput() 和 numericInput() 等函数将输入控件插入到 UI 规范中。\n现在我们将讨论所有输入函数的通用结构，并快速概述 Shiny 中内置的输入。","code":""},{"path":"basic-ui.html","id":"common-structure","chapter":"2 Basic UI","heading":"2.2.1 Common structure","text":"所有输入函数都有相同的第一个参数：inputId。\n这是用于连接前端和后端的标识符：如果您的 UI 有一个 ID 为 \"name\" 的输入，server 函数将使用 input$name 访问它。inputId 有两个约束：它必须是一个仅包含字母、数字和下划线的简单字符串（不允许包含空格、短划线、句点或其他特殊字符！）。\n命名它就像在 R 中命名变量一样。它必须是一个仅包含字母、数字和下划线的简单字符串（不允许包含空格、短划线、句点或其他特殊字符！）。\n命名它就像在 R 中命名变量一样。它必须是独一无二的。\n如果它不是唯一的，您将无法在 server 函数中引用此控件！它必须是独一无二的。\n如果它不是唯一的，您将无法在 server 函数中引用此控件！大多数输入函数都有第二个参数，称为 label。\n这用于为控件创建人类可读的标签。\nShiny 不会对此字符串施加任何限制，但您需要仔细考虑它以确保您的 app 可供人类使用！\n第三个参数通常是 value，在可能的情况下，让您设置默认值。\n其余参数对于该控件来说是唯一的。创建输入时，我建议按位置提供 inputId 和 label 参数，并按名称提供所有其他参数：以下部分描述了 Shiny 中内置的输入，根据它们创建的控件类型松散地分组。\n目的是让您快速了解您的选择，而不是详尽地描述所有参数。\n我将在下面显示每个控件最重要的参数，但您需要阅读文档才能获取完整的详细信息。","code":"\nsliderInput(\"min\", \"Limit (minimum)\", value = 50, min = 0, max = 100)"},{"path":"basic-ui.html","id":"free-text","chapter":"2 Basic UI","heading":"2.2.2 Free text","text":"使用 textInput() 收集少量文本，使用 passwordInput()3 收集密码，使用 textAreaInput() 收集文本段落。如果你想确保文本具有某些属性，你可以使用 validate()，我们将在 Chapter ?? 中讨论这一点。","code":"\nui <- fluidPage(\n  textInput(\"name\", \"What's your name?\"),\n  passwordInput(\"password\", \"What's your password?\"),\n  textAreaInput(\"story\", \"Tell me about yourself\", rows = 3)\n)"},{"path":"basic-ui.html","id":"numeric-inputs","chapter":"2 Basic UI","heading":"2.2.3 Numeric inputs","text":"要收集数值，请使用 numericInput() 创建受约束的文本框或使用 sliderInput() 创建滑块。\n如果为 sliderInput() 的默认值提供长度为 2 的数值向量，您将得到一个有两端的“范围”滑块。一般来说，我建议仅在小范围或精确值不太重要的情况下使用滑块。\n尝试在小滑块上精确选择数字是一项令人沮丧的练习！滑块是高度可定制的，并且有很多方法可以调整其外观。有关更多详细信息，请参阅 ?sliderInput 和 https://shiny.rstudio.com/articles/sliders.html。","code":"\nui <- fluidPage(\n  numericInput(\"num\", \"Number one\", value = 0, min = 0, max = 100),\n  sliderInput(\"num2\", \"Number two\", value = 50, min = 0, max = 100),\n  sliderInput(\"rng\", \"Range\", value = c(10, 20), min = 0, max = 100)\n)"},{"path":"basic-ui.html","id":"dates","chapter":"2 Basic UI","heading":"2.2.4 Dates","text":"使用 dateInput() 收集单个日期，或使用 dateRangeInput() 收集两个日期的范围。\n它们提供了一个方便的日历选择器，并且像 datesdisabled 和 daysofweekdisabled 这样的附加参数允许您限制有效输入的集合。日期格式、语言和一周开始日期默认为美国标准。\n如果您要创建面向国际受众的应用程序，请设置 format、language、和 weekstart，以便日期对您的用户来说是自然的。","code":"\nui <- fluidPage(\n  dateInput(\"dob\", \"When were you born?\"),\n  dateRangeInput(\"holiday\", \"When do you want to go on vacation next?\")\n)"},{"path":"basic-ui.html","id":"limited-choices","chapter":"2 Basic UI","heading":"2.2.5 Limited choices","text":"有两种不同的方法允许用户从一组预先指定的选项中进行选择：selectInput() 和 radioButtons()。单选按钮有两个很好的功能：它们显示所有可能的选项，使其适合短列表，并且通过 choiceNames/choiceValues 参数，它们可以显示纯文本以外的选项。\nchoiceNames 决定向用户显示的内容；choiceValues 决定 server 函数中返回的内容。无论选项数量多少，使用 selectInput() 创建的下拉菜单都会占用相同的空间，这使得它们更适合较长的选项。\n您还可以设置 multiple = TRUE 以允许用户选择多个元素。如果您有大量可能的选项，您可能需要使用“服务器端” selectInput()，以便完整的可能选项集不会嵌入到 UI 中（这会导致加载速度变慢），而是由 server 根据需要发送。\n您可以在 https://shiny.rstudio.com/articles/selectize.html#server-side-selectize 了解有关此高级主题的更多信息。无法使用单选按钮选择多个值，但有一个概念上类似的替代方案：checkboxGroupInput()。如果您想要单个复选框用于单个是/否问题，请使用 checkboxInput()：","code":"\nanimals <- c(\"dog\", \"cat\", \"mouse\", \"bird\", \"other\", \"I hate animals\")\n\nui <- fluidPage(\n  selectInput(\"state\", \"What's your favourite state?\", state.name),\n  radioButtons(\"animal\", \"What's your favourite animal?\", animals)\n)\nui <- fluidPage(\n  radioButtons(\"rb\", \"Choose one:\",\n    choiceNames = list(\n      icon(\"angry\"),\n      icon(\"smile\"),\n      icon(\"sad-tear\")\n    ),\n    choiceValues = list(\"angry\", \"happy\", \"sad\")\n  )\n)\nui <- fluidPage(\n  selectInput(\n    \"state\", \"What's your favourite state?\", state.name,\n    multiple = TRUE\n  )\n)\nui <- fluidPage(\n  checkboxGroupInput(\"animal\", \"What animals do you like?\", animals)\n)\nui <- fluidPage(\n  checkboxInput(\"cleanup\", \"Clean up?\", value = TRUE),\n  checkboxInput(\"shutdown\", \"Shutdown?\")\n)"},{"path":"basic-ui.html","id":"file-uploads","chapter":"2 Basic UI","heading":"2.2.6 File uploads","text":"通过 fileInput() 允许用户使上传文件：fileInput() 需要在服务器端进行特殊处理，在 Chapter ?? 中详细讨论。","code":"\nui <- fluidPage(\n  fileInput(\"upload\", NULL)\n)"},{"path":"basic-ui.html","id":"action-buttons","chapter":"2 Basic UI","heading":"2.2.7 Action buttons","text":"使用 actionButton() 或actionLink() 让用户执行操作：操作链接和按钮最自然地与 server 函数中的 observeEvent() 或 eventReactive() 配对。\n您还没有了解这些重要的功能，但我们将在 Section 3.5 中回顾它们。您可以使用 class 参数通过使用 \"btn-primary\"、\"btn-success\"、\"btn-info\"、\"btn-warning\"、\"btn-danger\" 其中的一个来自定义外观。\n您还可以使用 \"btn-lg\"、\"btn-sm\"、\"btn-xs\" 更改大小。\n最后，您可以使用 \"btn-block\" 使按钮跨越它们嵌入的元素的整个宽度。class 参数通过设置底层 HTML 的 class 属性来工作，这会影响元素的样式。\n要查看其他选项，您可以阅读 Bootstrap（Shiny 使用的 CSS 设计系统）的文档：<http://bootstrapdocs.com/v3.3.6/docs/css/#buttons>。","code":"\nui <- fluidPage(\n  actionButton(\"click\", \"Click me!\"),\n  actionButton(\"drink\", \"Drink me!\", icon = icon(\"cocktail\"))\n)\nui <- fluidPage(\n  fluidRow(\n    actionButton(\"click\", \"Click me!\", class = \"btn-danger\"),\n    actionButton(\"drink\", \"Drink me!\", class = \"btn-lg btn-success\")\n  ),\n  fluidRow(\n    actionButton(\"eat\", \"Eat me!\", class = \"btn-block\")\n  )\n)"},{"path":"basic-ui.html","id":"exercises-1","chapter":"2 Basic UI","heading":"2.2.8 Exercises","text":"当空间非常宝贵时，使用出现在文本输入区域内的占位符来标记文本框非常有用。\n如何调用 textInput() 来生成下面的 UI？\n当空间非常宝贵时，使用出现在文本输入区域内的占位符来标记文本框非常有用。\n如何调用 textInput() 来生成下面的 UI？仔细阅读 sliderInput() 的文档，了解如何创建日期滑块，如下所示。\n仔细阅读 sliderInput() 的文档，了解如何创建日期滑块，如下所示。创建一个滑块输入以选择 0 到 100 之间的值，其中滑块上每个可选值之间的间隔为 5。\n然后，向 input widget 添加动画，以便当用户按下“播放”时，input widget 会自动滚动该范围。创建一个滑块输入以选择 0 到 100 之间的值，其中滑块上每个可选值之间的间隔为 5。\n然后，向 input widget 添加动画，以便当用户按下“播放”时，input widget 会自动滚动该范围。如果 selectInput() 中有一个相当长的列表，那么创建将列表分成几部分的子标题会很有用。\n阅读文档以了解如何操作。\n（提示：底层 HTML 称为 <optgroup>。）如果 selectInput() 中有一个相当长的列表，那么创建将列表分成几部分的子标题会很有用。\n阅读文档以了解如何操作。\n（提示：底层 HTML 称为 <optgroup>。）","code":""},{"path":"basic-ui.html","id":"outputs","chapter":"2 Basic UI","heading":"2.3 Outputs","text":"UI 中的输出创建占位符，稍后由 server 函数填充。\n与输入一样，输出采用唯一的 ID 作为其第一个参数4：如果您的 UI 规范创建 ID 为 \"plot\" 的输出，您将在 server 函数中使用 output$plot 访问它。前端的每个 output 函数都与后端的 render 函数耦合。\n输出主要有三种类型，对应于报告中通常包含的三种内容：文本、表格和图表。\n以下部分向您展示前端输出函数的基础知识，以及后端相应的 render 函数。","code":""},{"path":"basic-ui.html","id":"text","chapter":"2 Basic UI","heading":"2.3.1 Text","text":"使用 textOutput() 输出常规文本，使用 verbatimTextOutput() 输出固定代码和控制台输出。请注意，仅当需要运行多行代码时，render 函数中才需要 {}。\n正如您很快就会了解到的，您应该在 render 函数中进行尽可能少的计算，这意味着您通常可以忽略它们。\n如果写得更紧凑的话，上面的 server 函数会是这样的：请注意，有两个 render 函数的行为略有不同：renderText() 将结果组合成单个字符串，通常与 textOutput() 配对renderPrint() 打印结果，就像在 R console 中一样，并且通常与 verbatimTextOutput() 配对。我们可以看到与 toy app 的区别：这相当于 R 语言中 cat() 和 print() 的区别。","code":"\nui <- fluidPage(\n  textOutput(\"text\"),\n  verbatimTextOutput(\"code\")\n)\nserver <- function(input, output, session) {\n  output$text <- renderText({ \n    \"Hello friend!\" \n  })\n  output$code <- renderPrint({ \n    summary(1:10) \n  })\n}\nserver <- function(input, output, session) {\n  output$text <- renderText(\"Hello friend!\")\n  output$code <- renderPrint(summary(1:10))\n}\nui <- fluidPage(\n  textOutput(\"text\"),\n  verbatimTextOutput(\"print\")\n)\nserver <- function(input, output, session) {\n  output$text <- renderText(\"hello!\")\n  output$print <- renderPrint(\"hello!\")\n}"},{"path":"basic-ui.html","id":"tables","chapter":"2 Basic UI","heading":"2.3.2 Tables","text":"有两种用于在表格中显示 data frames 的选项：tableOutput() 和 renderTable() 渲染静态数据表，一次性显示所有数据。tableOutput() 和 renderTable() 渲染静态数据表，一次性显示所有数据。dataTableOutput() 和 renderDataTable() 呈现一个动态表，显示固定数量的行以及用于更改哪些行可见的控件。dataTableOutput() 和 renderDataTable() 呈现一个动态表，显示固定数量的行以及用于更改哪些行可见的控件。tableOutput() 对于小型固定摘要最有用（例如模型系数）；如果您想向用户公开完整的 data frame，则 dataTableOutput() 最合适。\n如果您想更好地控制 dataTableOutput() 的输出，我强烈推荐 Greg Lin 的 reactable 包。","code":"\nui <- fluidPage(\n  tableOutput(\"static\"),\n  dataTableOutput(\"dynamic\")\n)\nserver <- function(input, output, session) {\n  output$static <- renderTable(head(mtcars))\n  output$dynamic <- renderDataTable(mtcars, options = list(pageLength = 5))\n}"},{"path":"basic-ui.html","id":"plots","chapter":"2 Basic UI","heading":"2.3.3 Plots","text":"您可以使用 plotOutput() 和 renderPlot() 显示任何类型的 R 图形（base、ggplot2 或其他）：默认情况下，plotOutput() 将占据其容器的整个宽度（稍后会详细介绍），高度为 400 像素。\n您可以使用 height 和 width 参数覆盖这些默认值。\n我们建议始终设置 res = 96，因为这将使您的 Shiny plots 尽可能匹配您在 RStudio 中看到的内容。Plots 很特殊，因为它们是输出，也可以充当输入。\nplotOutput() 有许多参数，例如 click、dblclick 和 hover。\n如果您向它们传递一个字符串，例如 click = \"plot_click\"，它们将创建一个反应性输入 (input$plot_click)，您可以使用它来处理绘图上的用户交互，例如单击绘图。\n我们将在 Chapter ?? 中回到 Shiny 中的 interactive plots。","code":"\nui <- fluidPage(\n  plotOutput(\"plot\", width = \"400px\")\n)\nserver <- function(input, output, session) {\n  output$plot <- renderPlot(plot(1:5), res = 96)\n}"},{"path":"basic-ui.html","id":"downloads","chapter":"2 Basic UI","heading":"2.3.4 Downloads","text":"您可以使用 downloadButton() 或 downloadLink() 让用户下载文件。\n这些需要 server 函数中的新技术，所以我们将在 Chapter ?? 中回到这一点。","code":""},{"path":"basic-ui.html","id":"exercises-2","chapter":"2 Basic UI","heading":"2.3.5 Exercises","text":"以下每个 render 函数应该与 textOutput() 和 verbatimTextOutput() 中的哪一个配对？\nrenderPrint(summary(mtcars))\nrenderText(\"Good morning!\")\nrenderPrint(t.test(1:5, 2:6))\nrenderText(str(lm(mpg ~ wt, data = mtcars)))\n以下每个 render 函数应该与 textOutput() 和 verbatimTextOutput() 中的哪一个配对？renderPrint(summary(mtcars))renderPrint(summary(mtcars))renderText(\"Good morning!\")renderText(\"Good morning!\")renderPrint(t.test(1:5, 2:6))renderPrint(t.test(1:5, 2:6))renderText(str(lm(mpg ~ wt, data = mtcars)))renderText(str(lm(mpg ~ wt, data = mtcars)))重新创建 Section 2.3.3 中的 Shiny app，这次将高度设置为 300px，宽度设置为 700px。\n设置绘图 “alt” 文本，以便视障用户可以看出它是五个随机数的散点图。重新创建 Section 2.3.3 中的 Shiny app，这次将高度设置为 300px，宽度设置为 700px。\n设置绘图 “alt” 文本，以便视障用户可以看出它是五个随机数的散点图。更新下面对 renderDataTable() 的调用中的选项，以便显示数据，但抑制所有其他控件（即删除搜索、排序和过滤命令）。\n您需要阅读 ?renderDataTable 并查看 https://datatables.net/reference/option/ 中的选项。\n\nui <- fluidPage(\n  dataTableOutput(\"table\")\n)\nserver <- function(input, output, session) {\n  output$table <- renderDataTable(mtcars, options = list(pageLength = 5))\n}更新下面对 renderDataTable() 的调用中的选项，以便显示数据，但抑制所有其他控件（即删除搜索、排序和过滤命令）。\n您需要阅读 ?renderDataTable 并查看 https://datatables.net/reference/option/ 中的选项。或者，阅读有关 reactable 的内容，并将上述 app 转换为使用它。或者，阅读有关 reactable 的内容，并将上述 app 转换为使用它。","code":"\nui <- fluidPage(\n  dataTableOutput(\"table\")\n)\nserver <- function(input, output, session) {\n  output$table <- renderDataTable(mtcars, options = list(pageLength = 5))\n}"},{"path":"basic-ui.html","id":"summary-1","chapter":"2 Basic UI","heading":"2.4 Summary","text":"本章向您介绍了构成 Shiny app 前端的主要输入和输出函数。\n这是一个很大的信息转储，所以不要指望在一次阅读后记住所有内容。\n相反，当您正在寻找特定组件时，请返回本章：您可以快速浏览图形，然后找到您需要的代码。在下一章中，我们将继续讨论 Shiny app 的后端：使用户界面栩栩如生的 R 代码。","code":""},{"path":"basic-reactivity.html","id":"basic-reactivity","chapter":"3 Basic reactivity","heading":"3 Basic reactivity","text":"","code":""},{"path":"basic-reactivity.html","id":"introduction-2","chapter":"3 Basic reactivity","heading":"3.1 Introduction","text":"Shiny, express server logic using reactive programming.\nReactive programming elegant powerful programming paradigm, can disorienting first ’s different paradigm writing script.\nkey idea reactive programming specify graph dependencies input changes, related outputs automatically updated.\nmakes flow app considerably simpler, takes get head around fits together.chapter provide gentle introduction reactive programming, teaching basics common reactive constructs ’ll use Shiny apps.\n’ll start survey server function, discussing detail input output arguments work.\nNext ’ll review simplest form reactivity (inputs directly connected outputs), discuss reactive expressions allow eliminate duplicated work.\n’ll finish reviewing common roadblocks encountered newer Shiny users.","code":""},{"path":"basic-reactivity.html","id":"the-server-function","chapter":"3 Basic reactivity","heading":"3.2 The server function","text":"’ve seen, guts every Shiny app look like :previous chapter covered basics front end, ui object contains HTML presented every user app.\nui simple every user gets HTML.\nserver complicated every user needs get independent version app; user moves slider, user B shouldn’t see outputs change.achieve independence, Shiny invokes server() function time new session5 starts.\nJust like R function, server function called creates new local environment independent every invocation function.\nallows session unique state, well isolating variables created inside function.\nalmost reactive programming ’ll Shiny inside server function6\n.Server functions take three parameters: input, output, session.\nnever call server function , ’ll never create objects .\nInstead, ’re created Shiny session begins, connecting back specific session.\nmoment, ’ll focus input output arguments, leave session later chapters.","code":"\nlibrary(shiny)\n\nui <- fluidPage(\n  # front end interface\n)\n\nserver <- function(input, output, session) {\n  # back end logic\n}\n\nshinyApp(ui, server)"},{"path":"basic-reactivity.html","id":"input","chapter":"3 Basic reactivity","heading":"3.2.1 Input","text":"input argument list-like object contains input data sent browser, named according input ID.\nexample, UI contains numeric input control input ID count, like :can access value input input$count.\ninitially contain value 100, automatically updated user changes value browser.Unlike typical list, input objects read-.\nattempt modify input inside server function, ’ll get error:error occurs input reflects ’s happening browser, browser Shiny’s “single source truth”.\nmodify value R, introduce inconsistencies, input slider said one thing browser, input$count said something different R.\nmake programming challenging!\nLater, Chapter ??, ’ll learn use functions like updateNumericInput() modify value browser, input$count update accordingly.One important thing input: ’s selective allowed read .\nread input, must reactive context created function like renderText() reactive().\n’ll come back idea shortly, ’s important constraint allows outputs automatically update input changes.\ncode illustrates error ’ll see make mistake:","code":"\nui <- fluidPage(\n  numericInput(\"count\", label = \"Number of values\", value = 100)\n)\nserver <- function(input, output, session) {\n  input$count <- 10  \n}\n\nshinyApp(ui, server)\n#> Error: Can't modify read-only reactive value 'count'\nserver <- function(input, output, session) {\n  message(\"The value of input$count is \", input$count)\n}\n\nshinyApp(ui, server)\n#> Error: Can't access reactive value 'count' outside of reactive consumer.\n#> ℹ Do you need to wrap inside reactive() or observer()?"},{"path":"basic-reactivity.html","id":"output","chapter":"3 Basic reactivity","heading":"3.2.2 Output","text":"output similar input: ’s also list-like object named according output ID.\nmain difference use sending output instead receiving input.\nalways use output object concert render function, following simple example:(Note ID quoted UI, server.)render function two things:sets special reactive context automatically tracks inputs output uses.sets special reactive context automatically tracks inputs output uses.converts output R code HTML suitable display web page.converts output R code HTML suitable display web page.Like input, output picky use .\n’ll get error :forget render function.\n\nserver <- function(input, output, session) {\n  output$greeting <- \"Hello human\"\n}\nshinyApp(ui, server)\n#> Error: Unexpected character object output$greeting\n#> ℹ forget use render function?forget render function.attempt read output.\n\nserver <- function(input, output, session) {\n  message(\"greeting \", output$greeting)\n}\nshinyApp(ui, server)\n#> Error: Reading shinyoutput object allowed.attempt read output.","code":"\nui <- fluidPage(\n  textOutput(\"greeting\")\n)\n\nserver <- function(input, output, session) {\n  output$greeting <- renderText(\"Hello human!\")\n}\nserver <- function(input, output, session) {\n  output$greeting <- \"Hello human\"\n}\nshinyApp(ui, server)\n#> Error: Unexpected character object for output$greeting\n#> ℹ Did you forget to use a render function?\nserver <- function(input, output, session) {\n  message(\"The greeting is \", output$greeting)\n}\nshinyApp(ui, server)\n#> Error: Reading from shinyoutput object is not allowed."},{"path":"basic-reactivity.html","id":"reactive-programming","chapter":"3 Basic reactivity","heading":"3.3 Reactive programming","text":"app going pretty boring inputs outputs.\nreal magic Shiny happens app .\nLet’s look simple example:’s hard show works book, best Figure 3.1.\nrun app, type name box, ’ll see greeting updates automatically type7.\nFigure 3.1: Reactivity means outputs automatically update inputs change, app type ‘J’, ‘o’, ‘e’. See live https://hadley.shinyapps.io/ms-connection.\nbig idea Shiny: don’t need tell output update, Shiny automatically figures .\nwork?\nexactly going body function?\nLet’s think code inside server function precisely:’s easy read “paste together ‘hello’ user’s name, send output$greeting”.\nmental model wrong subtle, important, way.\nThink : model, issue instruction .\nShiny performs action every time update input$name, must something going .app works code doesn’t tell Shiny create string send browser, instead, informs Shiny create string needs .\n’s Shiny (even !) code run.\nmight run soon app launches, might quite bit later; might run many times, might never run!\nisn’t imply Shiny capricious, ’s Shiny’s responsibility decide code executed, .\nThink app providing Shiny recipes, giving commands.","code":"\nui <- fluidPage(\n  textInput(\"name\", \"What's your name?\"),\n  textOutput(\"greeting\")\n)\n\nserver <- function(input, output, session) {\n  output$greeting <- renderText({\n    paste0(\"Hello \", input$name, \"!\")\n  })\n}\noutput$greeting <- renderText({\n  paste0(\"Hello \", input$name, \"!\")\n})"},{"path":"basic-reactivity.html","id":"imperative-vs-declarative-programming","chapter":"3 Basic reactivity","heading":"3.3.1 Imperative vs declarative programming","text":"difference commands recipes one key differences two important styles programming:imperative programming, issue specific command ’s carried immediately.\nstyle programming ’re used analysis scripts: command R load data, transform , visualise , save results disk.imperative programming, issue specific command ’s carried immediately.\nstyle programming ’re used analysis scripts: command R load data, transform , visualise , save results disk.declarative programming, express higher-level goals describe important constraints, rely someone else decide /translate action.\nstyle programming use Shiny.declarative programming, express higher-level goals describe important constraints, rely someone else decide /translate action.\nstyle programming use Shiny.imperative code say “Make sandwich”8.\ndeclarative code say “Ensure sandwich refrigerator whenever look inside ”.\nImperative code assertive; declarative code passive-aggressive.time, declarative programming tremendously freeing: describe overall goals, software figures achieve without intervention.\ndownside occasional time know exactly want, can’t figure frame way declarative system understands9.\ngoal book help develop understanding underlying theory happens infrequently possible.","code":""},{"path":"basic-reactivity.html","id":"laziness","chapter":"3 Basic reactivity","heading":"3.3.2 Laziness","text":"One strengths declarative programming Shiny allows apps extremely lazy.\nShiny app ever minimal amount work needed update output controls can currently see10.\nlaziness, however, comes important downside aware .\nCan spot ’s wrong server function ?look closely, might notice ’ve written greting instead greeting.\nwon’t generate error Shiny, won’t want.\ngreting output doesn’t exist, code inside renderText() never run.’re working Shiny app just can’t figure code never gets run, double check UI server functions using identifiers.","code":"\nserver <- function(input, output, session) {\n  output$greting <- renderText({\n    paste0(\"Hello \", input$name, \"!\")\n  })\n}"},{"path":"basic-reactivity.html","id":"the-reactive-graph","chapter":"3 Basic reactivity","heading":"3.3.3 The reactive graph","text":"Shiny’s laziness another important property.\nR code, can understand order execution reading code top bottom.\ndoesn’t work Shiny, code run needed.\nunderstand order execution need instead look reactive graph, describes inputs outputs connected.\nreactive graph app simple shown Figure 3.2.\nFigure 3.2: reactive graph shows inputs outputs connected\nreactive graph contains one symbol every input output, connect input output whenever output accesses input.\ngraph tells greeting need recomputed whenever name changed.\n’ll often describe relationship greeting reactive dependency name.Note graphical conventions used inputs outputs: name input naturally fits greeting output.\ndraw closely packed together, Figure 3.3, emphasise way fit together; won’t normally works simplest apps.\nFigure 3.3: shapes used components reactive graph evoke ways connect.\nreactive graph powerful tool understanding app works.\napp gets complicated, ’s often useful make quick high-level sketch reactive graph remind pieces fit together.\nThroughout book ’ll show reactive graph help understand examples work, later , Chapter 14, ’ll learn use reactlog draw graph .","code":""},{"path":"basic-reactivity.html","id":"reactive-expressions","chapter":"3 Basic reactivity","heading":"3.3.4 Reactive expressions","text":"’s one important component ’ll see reactive graph: reactive expression.\n’ll come back reactive expressions detail shortly; now think tool reduces duplication reactive code introducing additional nodes reactive graph.don’t need reactive expression simple app, ’ll add one anyway can see affects reactive graph, Figure 3.4.\nFigure 3.4: reactive expression drawn angles sides connects inputs outputs.\nReactive expressions take inputs produce outputs shape combines features inputs outputs.\nHopefully, shapes help remember components fit together.","code":"\nserver <- function(input, output, session) {\n  string <- reactive(paste0(\"Hello \", input$name, \"!\"))\n  output$greeting <- renderText(string())\n}"},{"path":"basic-reactivity.html","id":"execution-order","chapter":"3 Basic reactivity","heading":"3.3.5 Execution order","text":"’s important understand order code run solely determined reactive graph.\ndifferent R code execution order determined order lines.\nexample, flip order two lines simple server function:might think yield error output$greeting refers reactive expression, string, hasn’t created yet.\nremember Shiny lazy, code run session starts, string created.Instead, code yields reactive graph , order code run exactly .\nOrganising code like confusing humans, best avoided.\nInstead, make sure reactive expressions outputs refer things defined , below11.\nmake code easier understand.concept important different R code, ’ll say : order reactive code run determined reactive graph, layout server function.","code":"\nserver <- function(input, output, session) {\n  output$greeting <- renderText(string())\n  string <- reactive(paste0(\"Hello \", input$name, \"!\"))\n}"},{"path":"basic-reactivity.html","id":"exercises-3","chapter":"3 Basic reactivity","heading":"3.3.6 Exercises","text":"Given UI:\n\nui <- fluidPage(\n  textInput(\"name\", \"name?\"),\n  textOutput(\"greeting\")\n)\nFix simple errors found three server functions .\nFirst try spotting problem just reading code; run code make sure ’ve fixed .\n\nserver1 <- function(input, output, server) {\n  input$greeting <- renderText(paste0(\"Hello \", name))\n}\n\nserver2 <- function(input, output, server) {\n  greeting <- paste0(\"Hello \", input$name)\n  output$greeting <- renderText(greeting)\n}\n\nserver3 <- function(input, output, server) {\n  output$greting <- paste0(\"Hello\", input$name)\n}Given UI:Fix simple errors found three server functions .\nFirst try spotting problem just reading code; run code make sure ’ve fixed .Draw reactive graph following server functions:\n\nserver1 <- function(input, output, session) {\n  c <- reactive(input$+ input$b)\n  e <- reactive(c() + input$d)\n  output$f <- renderText(e())\n}\nserver2 <- function(input, output, session) {\n  x <- reactive(input$x1 + input$x2 + input$x3)\n  y <- reactive(input$y1 + input$y2)\n  output$z <- renderText(x() / y())\n}\nserver3 <- function(input, output, session) {\n  d <- reactive(c() ^ input$d)\n  <- reactive(input$* 10)\n  c <- reactive(b() / input$c) \n  b <- reactive(() + input$b)\n}Draw reactive graph following server functions:code fail?\n\nvar <- reactive(df[[input$var]])\nrange <- reactive(range(var(), na.rm = TRUE))\nrange() var() bad names reactive?code fail?range() var() bad names reactive?","code":"\nui <- fluidPage(\n  textInput(\"name\", \"What's your name?\"),\n  textOutput(\"greeting\")\n)\nserver1 <- function(input, output, server) {\n  input$greeting <- renderText(paste0(\"Hello \", name))\n}\n\nserver2 <- function(input, output, server) {\n  greeting <- paste0(\"Hello \", input$name)\n  output$greeting <- renderText(greeting)\n}\n\nserver3 <- function(input, output, server) {\n  output$greting <- paste0(\"Hello\", input$name)\n}\nserver1 <- function(input, output, session) {\n  c <- reactive(input$a + input$b)\n  e <- reactive(c() + input$d)\n  output$f <- renderText(e())\n}\nserver2 <- function(input, output, session) {\n  x <- reactive(input$x1 + input$x2 + input$x3)\n  y <- reactive(input$y1 + input$y2)\n  output$z <- renderText(x() / y())\n}\nserver3 <- function(input, output, session) {\n  d <- reactive(c() ^ input$d)\n  a <- reactive(input$a * 10)\n  c <- reactive(b() / input$c) \n  b <- reactive(a() + input$b)\n}\nvar <- reactive(df[[input$var]])\nrange <- reactive(range(var(), na.rm = TRUE))"},{"path":"basic-reactivity.html","id":"reactive-expressions-1","chapter":"3 Basic reactivity","heading":"3.4 Reactive expressions","text":"’ve quickly skimmed reactive expressions couple times, ’re hopefully getting sense might .\nNow ’ll dive details, show important constructing real apps.Reactive expressions important give Shiny information can less recomputation inputs change, making apps efficient, make easier humans understand app simplifying reactive graph.\nReactive expressions flavour inputs outputs:Like inputs, can use results reactive expression output.Like inputs, can use results reactive expression output.Like outputs, reactive expressions depend inputs automatically know need updating.Like outputs, reactive expressions depend inputs automatically know need updating.duality means need new vocab: ’ll use producers refer reactive inputs expressions, consumers refer reactive expressions outputs.\nFigure 3.5 shows relationship Venn diagram.\nFigure 3.5: Inputs expressions reactive producers; expressions outputs reactive consumers\n’re going need complex app see benefits using reactive expressions.\nFirst, ’ll set stage defining regular R functions ’ll use power app.","code":""},{"path":"basic-reactivity.html","id":"the-motivation","chapter":"3 Basic reactivity","heading":"3.4.1 The motivation","text":"Imagine want compare two simulated datasets plot hypothesis test.\n’ve done little experimentation come functions : freqpoly() visualises two distributions frequency polygons12, t_test() uses t-test compare means summarises results string:simulated data, can use functions compare two variables:real analysis, probably ’ve done bunch exploration ended functions.\n’ve skipped exploration can get app quickly possible.\nextracting imperative code regular functions important technique Shiny apps: code can extract app, easier understand.\ngood software engineering helps isolate concerns: functions outside app focus computation code inside app can focus responding user actions.\n’ll come back idea Chapter ??.","code":"\nlibrary(ggplot2)\n#> Warning: package 'ggplot2' was built under R version 4.2.3\n\nfreqpoly <- function(x1, x2, binwidth = 0.1, xlim = c(-3, 3)) {\n  df <- data.frame(\n    x = c(x1, x2),\n    g = c(rep(\"x1\", length(x1)), rep(\"x2\", length(x2)))\n  )\n\n  ggplot(df, aes(x, colour = g)) +\n    geom_freqpoly(binwidth = binwidth, size = 1) +\n    coord_cartesian(xlim = xlim)\n}\n\nt_test <- function(x1, x2) {\n  test <- t.test(x1, x2)\n  \n  # use sprintf() to format t.test() results compactly\n  sprintf(\n    \"p value: %0.3f\\n[%0.2f, %0.2f]\",\n    test$p.value, test$conf.int[1], test$conf.int[2]\n  )\n}\nx1 <- rnorm(100, mean = 0, sd = 0.5)\nx2 <- rnorm(200, mean = 0.15, sd = 0.9)\n\nfreqpoly(x1, x2)\n#> Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\n#> ℹ Please use `linewidth` instead.\n#> This warning is displayed once every 8 hours.\n#> Call `lifecycle::last_lifecycle_warnings()` to see where this warning was\n#> generated.\ncat(t_test(x1, x2))\n#> p value: 0.434\n#> [-0.22, 0.10]"},{"path":"basic-reactivity.html","id":"the-app","chapter":"3 Basic reactivity","heading":"3.4.2 The app","text":"’d like use two tools quickly explore bunch simulations.\nShiny app great way lets avoid tediously modifying re-running R code.\nwrap pieces Shiny app can interactively tweak inputs.Let’s start UI.\n’ll come back exactly fluidRow() column() Section ??; can guess purpose names 😄.\nfirst row three columns input controls (distribution 1, distribution 2, plot controls).\nsecond row wide column plot, narrow column hypothesis test.server function combines calls freqpoly() t_test() functions drawing specified distributions:\nFigure 3.6: Shiny app lets compare two simulated distributions t-test frequency polygon See live https://hadley.shinyapps.io/ms-case-study-1.\ndefinition server ui yields Figure 3.6.\ncan find live version https://hadley.shinyapps.io/ms-case-study-1; recommend opening app quick play make sure understand basic operation continue reading.","code":"\nui <- fluidPage(\n  fluidRow(\n    column(4, \n      \"Distribution 1\",\n      numericInput(\"n1\", label = \"n\", value = 1000, min = 1),\n      numericInput(\"mean1\", label = \"µ\", value = 0, step = 0.1),\n      numericInput(\"sd1\", label = \"σ\", value = 0.5, min = 0.1, step = 0.1)\n    ),\n    column(4, \n      \"Distribution 2\",\n      numericInput(\"n2\", label = \"n\", value = 1000, min = 1),\n      numericInput(\"mean2\", label = \"µ\", value = 0, step = 0.1),\n      numericInput(\"sd2\", label = \"σ\", value = 0.5, min = 0.1, step = 0.1)\n    ),\n    column(4,\n      \"Frequency polygon\",\n      numericInput(\"binwidth\", label = \"Bin width\", value = 0.1, step = 0.1),\n      sliderInput(\"range\", label = \"range\", value = c(-3, 3), min = -5, max = 5)\n    )\n  ),\n  fluidRow(\n    column(9, plotOutput(\"hist\")),\n    column(3, verbatimTextOutput(\"ttest\"))\n  )\n)\nserver <- function(input, output, session) {\n  output$hist <- renderPlot({\n    x1 <- rnorm(input$n1, input$mean1, input$sd1)\n    x2 <- rnorm(input$n2, input$mean2, input$sd2)\n    \n    freqpoly(x1, x2, binwidth = input$binwidth, xlim = input$range)\n  }, res = 96)\n\n  output$ttest <- renderText({\n    x1 <- rnorm(input$n1, input$mean1, input$sd1)\n    x2 <- rnorm(input$n2, input$mean2, input$sd2)\n    \n    t_test(x1, x2)\n  })\n}"},{"path":"basic-reactivity.html","id":"the-reactive-graph-1","chapter":"3 Basic reactivity","heading":"3.4.3 The reactive graph","text":"Let’s start drawing reactive graph app.\nShiny smart enough update output inputs refers change; ’s smart enough selectively run pieces code inside output.\nwords, outputs atomic: ’re either executed whole.example, take snippet server:human reading code can tell need update x1 n1, mean1, sd1 changes, need update x2 n2, mean2, sd2 changes.\nShiny, however, looks output whole, update x1 x2 every time one n1, mean1, sd1, n2, mean2, sd2 changes.\nleads reactive graph shown Figure 3.7:\nFigure 3.7: reactive graph shows every output depends every input\n’ll notice graph dense: almost every input connected directly every output.\ncreates two problems:app hard understand many connections.\npieces app can pull analyse isolation.app hard understand many connections.\npieces app can pull analyse isolation.app inefficient work necessary.\nexample, change breaks plot, data recalculated; change value n1, x2 updated (two places!).app inefficient work necessary.\nexample, change breaks plot, data recalculated; change value n1, x2 updated (two places!).’s one major flaw app: frequency polygon t-test use separate random draws.\nrather misleading, ’d expect working underlying data.Fortunately, can fix problems using reactive expressions pull repeated computation.","code":"\nx1 <- rnorm(input$n1, input$mean1, input$sd1)\nx2 <- rnorm(input$n2, input$mean2, input$sd2)\nt_test(x1, x2)"},{"path":"basic-reactivity.html","id":"simplifying-the-graph","chapter":"3 Basic reactivity","heading":"3.4.4 Simplifying the graph","text":"server function refactor existing code pull repeated code two new reactive expressions, x1 x2, simulate data two distributions.\ncreate reactive expression, call reactive() assign results variable.\nlater use expression, call variable like ’s function.transformation yields substantially simpler graph shown Figure 3.8.\nsimpler graph makes easier understand app can understand connected components isolation; values distribution parameters affect output via x1 x2.\nrewrite also makes app much efficient since much less computation.\nNow, change binwidth range, plot changes, underlying data.\nFigure 3.8: Using reactive expressions considerably simplifies graph, making much easier understand\nemphasise modularity Figure 3.9 draws boxes around independent components.\n’ll come back idea Chapter ??, discuss modules.\nModules allow extract repeated code reuse, guaranteeing ’s isolated everything else app.\nModules extremely useful powerful technique complex apps.\nFigure 3.9: Modules enforce isolation parts app\nmight familiar “rule three” programming: whenever copy paste something three times, figure reduce duplication (typically writing function).\nimportant reduces amount duplication code, makes easier understand, easier update requirements change.Shiny, however, think consider rule one: whenever copy paste something , consider extracting repeated code reactive expression.\nrule stricter Shiny reactive expressions don’t just make easier humans understand code, also improve Shiny’s ability efficiently rerun code.","code":"\nserver <- function(input, output, session) {\n  x1 <- reactive(rnorm(input$n1, input$mean1, input$sd1))\n  x2 <- reactive(rnorm(input$n2, input$mean2, input$sd2))\n\n  output$hist <- renderPlot({\n    freqpoly(x1(), x2(), binwidth = input$binwidth, xlim = input$range)\n  }, res = 96)\n\n  output$ttest <- renderText({\n    t_test(x1(), x2())\n  })\n}"},{"path":"basic-reactivity.html","id":"reactive-roadblocks","chapter":"3 Basic reactivity","heading":"3.4.5 Why do we need reactive expressions?","text":"first start working reactive code, might wonder need reactive expressions.\ncan’t use existing tools reducing duplication code: creating new variables writing functions?\nUnfortunately neither techniques work reactive environment.try use variable reduce duplication, might write something like :run code, ’ll get error ’re attempting access input values outside reactive context.\nEven didn’t get error, ’d still problem: x1 x2 computed , session begins, every time one inputs updated.try use function, app work:problem original code: input cause outputs recomputed, t-test frequency polygon run separate samples.\nReactive expressions automatically cache results, update inputs change13.variables calculate value (porridge cold), functions calculate value every time ’re called (porridge hot), reactive expressions calculate value might changed (porridge just right!).","code":"\nserver <- function(input, output, session) {\n  x1 <- rnorm(input$n1, input$mean1, input$sd1)\n  x2 <- rnorm(input$n2, input$mean2, input$sd2)\n\n  output$hist <- renderPlot({\n    freqpoly(x1, x2, binwidth = input$binwidth, xlim = input$range)\n  }, res = 96)\n\n  output$ttest <- renderText({\n    t_test(x1, x2)\n  })\n}\nserver <- function(input, output, session) { \n  x1 <- function() rnorm(input$n1, input$mean1, input$sd1)\n  x2 <- function() rnorm(input$n2, input$mean2, input$sd2)\n\n  output$hist <- renderPlot({\n    freqpoly(x1(), x2(), binwidth = input$binwidth, xlim = input$range)\n  }, res = 96)\n\n  output$ttest <- renderText({\n    t_test(x1(), x2())\n  })\n}"},{"path":"basic-reactivity.html","id":"controlling-timing-of-evaluation","chapter":"3 Basic reactivity","heading":"3.5 Controlling timing of evaluation","text":"Now ’re familiar basic ideas reactivity, ’ll discuss two advanced techniques allow either increase decrease often reactive expression executed.\n’ll show use basic techniques; Chapter ??, ’ll come back underlying implementations.explore basic ideas, ’m going simplify simulation app.\n’ll use distribution one parameter, force samples share n.\n’ll also remove plot controls.\nyields smaller UI object server function:generates app shown Figure 3.10 reactive graph shown Figure 3.11.\nFigure 3.10: simpler app displays frequency polygon random numbers drawn two Poisson distributions. See live https://hadley.shinyapps.io/ms-simulation-2.\n\nFigure 3.11: reactive graph\n","code":"\nui <- fluidPage(\n  fluidRow(\n    column(3, \n      numericInput(\"lambda1\", label = \"lambda1\", value = 3),\n      numericInput(\"lambda2\", label = \"lambda2\", value = 5),\n      numericInput(\"n\", label = \"n\", value = 1e4, min = 0)\n    ),\n    column(9, plotOutput(\"hist\"))\n  )\n)\nserver <- function(input, output, session) {\n  x1 <- reactive(rpois(input$n, input$lambda1))\n  x2 <- reactive(rpois(input$n, input$lambda2))\n  output$hist <- renderPlot({\n    freqpoly(x1(), x2(), binwidth = 1, xlim = c(0, 40))\n  }, res = 96)\n}"},{"path":"basic-reactivity.html","id":"timed-invalidation","chapter":"3 Basic reactivity","heading":"3.5.1 Timed invalidation","text":"Imagine wanted reinforce fact simulated data constantly resimulating data, see animation rather static plot14.\ncan increase frequency updates new function: reactiveTimer().reactiveTimer() reactive expression dependency hidden input: current time.\ncan use reactiveTimer() want reactive expression invalidate often otherwise .\nexample, following code uses interval 500 ms plot update twice second.\nfast enough remind ’re looking simulation, without dizzying rapid changes.\nchange yields reactive graph shown Figure 3.12\nFigure 3.12: reactiveTimer(500) introduces new reactive input automatically invalidates every half second\nNote use timer() reactive expressions compute x1() x2(): call , don’t use value.\nlets x1 x2 take reactive dependency timer, without worrying exactly value returns.","code":"\nserver <- function(input, output, session) {\n  timer <- reactiveTimer(500)\n  \n  x1 <- reactive({\n    timer()\n    rpois(input$n, input$lambda1)\n  })\n  x2 <- reactive({\n    timer()\n    rpois(input$n, input$lambda2)\n  })\n  \n  output$hist <- renderPlot({\n    freqpoly(x1(), x2(), binwidth = 1, xlim = c(0, 40))\n  }, res = 96)\n}"},{"path":"basic-reactivity.html","id":"on-click","chapter":"3 Basic reactivity","heading":"3.5.2 On click","text":"scenario, think happen simulation code took 1 second run.\nperform simulation every 0.5s, Shiny , never able catch .\nproblem can happen someone rapidly clicking buttons app computation relatively expensive.\n’s possible create big backlog work Shiny, ’s working backlog, can’t respond new events.\nleads poor user experience.situation arises app, might want require user opt-performing expensive calculation requiring click button.\ngreat use case actionButton():use action button need learn new tool.\nsee , let’s first tackle problem using approach .\n, refer simulate without using value take reactive dependency .\nFigure 3.13: App action button. See live https://hadley.shinyapps.io/ms-action-button.\n\nFigure 3.14: reactive graph doesn’t accomplish goal; ’ve added dependency instead replacing existing dependencies.\nyields app Figure 3.13 reactive graph Figure 3.14.\ndoesn’t achieve goal just introduces new dependency: x1() x2() update click simulate button, ’ll also continue update lambda1, lambda2, n change.\nwant replace existing dependencies, add .solve problem need new tool: way use input values without taking reactive dependency .\nneed eventReactive(), two arguments: first argument specifies take dependency , second argument specifies compute.\nallows app compute x1() x2() simulate clicked:Figure 3.15 shows new reactive graph.\nNote , desired, x1 x2 longer reactive dependency lambda1, lambda2, n: changing values trigger computation.\nleft arrows pale grey just remind x1 x2 continue use values, longer take reactive dependency .\nFigure 3.15: eventReactive() makes possible separate dependencies (black arrows) values used compute result (pale gray arrows).\n","code":"\nui <- fluidPage(\n  fluidRow(\n    column(3, \n      numericInput(\"lambda1\", label = \"lambda1\", value = 3),\n      numericInput(\"lambda2\", label = \"lambda2\", value = 5),\n      numericInput(\"n\", label = \"n\", value = 1e4, min = 0),\n      actionButton(\"simulate\", \"Simulate!\")\n    ),\n    column(9, plotOutput(\"hist\"))\n  )\n)\nserver <- function(input, output, session) {\n  x1 <- reactive({\n    input$simulate\n    rpois(input$n, input$lambda1)\n  })\n  x2 <- reactive({\n    input$simulate\n    rpois(input$n, input$lambda2)\n  })\n  output$hist <- renderPlot({\n    freqpoly(x1(), x2(), binwidth = 1, xlim = c(0, 40))\n  }, res = 96)\n}\nserver <- function(input, output, session) {\n  x1 <- eventReactive(input$simulate, {\n    rpois(input$n, input$lambda1)\n  })\n  x2 <- eventReactive(input$simulate, {\n    rpois(input$n, input$lambda2)\n  })\n\n  output$hist <- renderPlot({\n    freqpoly(x1(), x2(), binwidth = 1, xlim = c(0, 40))\n  }, res = 96)\n}"},{"path":"basic-reactivity.html","id":"observers","chapter":"3 Basic reactivity","heading":"3.6 Observers","text":"far, ’ve focused ’s happening inside app.\nsometimes need reach outside app cause side-effects happen elsewhere world.\nmight saving file shared network drive, sending data web API, updating database, (commonly) printing debugging message console.\nactions don’t affect app looks, shouldn’t use output render function.\nInstead need use observer.multiple ways create observer, ’ll come back later Section ??.\nnow, wanted show use observeEvent(), gives important debugging tool ’re first learning Shiny.observeEvent() similar eventReactive().\ntwo important arguments: eventExpr handlerExpr.\nfirst argument input expression take dependency ; second argument code run.\nexample, following modification server() means every time name updated, message sent console:two important differences observeEvent() eventReactive():don’t assign result observeEvent() variable, soYou can’t refer reactive consumers.Observers outputs closely related.\ncan think outputs special side-effect: updating HTML user’s browser.\nemphasise closeness, ’ll draw way reactive graph.\nyields following reactive graph shown Figure 3.16.\nFigure 3.16: reactive graph, observer looks output\n","code":"\nui <- fluidPage(\n  textInput(\"name\", \"What's your name?\"),\n  textOutput(\"greeting\")\n)\n\nserver <- function(input, output, session) {\n  string <- reactive(paste0(\"Hello \", input$name, \"!\"))\n  \n  output$greeting <- renderText(string())\n  observeEvent(input$name, {\n    message(\"Greeting performed\")\n  })\n}"},{"path":"basic-reactivity.html","id":"summary-2","chapter":"3 Basic reactivity","heading":"3.7 Summary","text":"chapter improved understanding backend Shiny apps, server() code responds user actions.\n’ve also taken first steps mastering reactive programming paradigm underpins Shiny.\n’ve learned carry long way; ’ll come back underlying theory Chapter ??.\nReactivity extremely powerful, also different imperative style R programming ’re used .\nDon’t surprised takes consequences sink .chapter concludes overview foundations Shiny.\nnext chapter help practice material ’ve seen far creating bigger Shiny app designed support data analysis.","code":""}]
