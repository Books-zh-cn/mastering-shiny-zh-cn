[{"path":"index.html","id":"welcome","chapter":"Welcome","heading":"Welcome","text":"这是 Mastering Shiny 的在线版本，该书目前正在早期开发中，预计由 O’Reilly Media 于 2020 年底发行。Shiny 是一个使用 R 代码创建 Web 应用程序的框架。它的设计主要考虑了数据科学家的需求，为此，您可以在不了解 HTML、CSS 或 JavaScript 的情况下创建相当复杂的 Shiny 应用程序。另一方面，Shiny 并不限制您创建琐碎或预制的应用程序：它的用户界面组件可以轻松自定义或扩展，并且它的服务器使用反应式编程来让您创建您想要的任何类型的后端逻辑。\nShiny 的设计初衷是让您在刚开始使用时感觉非常简单，但您越深入地了解它的工作原理，您就越会意识到它是由通用构建块构建而成，而这些构建块背后都有强大的软件工程原理。如今，Shiny 的应用领域和行业几乎与 R 本身一样多。\n它在学术界被用作统计概念的教学工具，一种让本科生对学习编写代码感到兴奋的方式，一种炫耀新颖统计方法或模型的引人注目的媒介。\n大型制药公司使用它来加速药物开发过程中科学家和分析师之间的合作。\n硅谷科技公司使用它来设置包含高级分析的实时指标仪表盘。本书旨在帮助您从对 Shiny 一无所知到成为一名专家开发人员，能够编写仍然可维护且高性能的大型复杂应用程序。您将深入了解 Shiny 背后的反应式编程模型，并构建一个包含有用技术的工具箱来解决常见的应用程序挑战。","code":""},{"path":"index.html","id":"license","chapter":"Welcome","heading":"License","text":"book licensed Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.code samples book licensed Creative Commons CC0 1.0 Universal (CC0 1.0), .e. public domain.","code":""},{"path":"preface.html","id":"preface","chapter":"Preface","heading":"Preface","text":"","code":""},{"path":"preface.html","id":"what-is-shiny","chapter":"Preface","heading":"0.1 What is Shiny?","text":"如果您以前从未使用过 Shiny，欢迎！\nShiny 是一个 R 包，可让您轻松创建丰富的交互式 Web 应用程序。\nShiny 允许您在 R 中进行工作并通过网络浏览器公开它，以便任何人都可以使用它。\nShiny 让您可以轻松地以最少的痛苦来生成精美的 Web 应用程序，从而使您看起来很棒。在过去，创建 Web 应用程序对于大多数 R 用户来说都很困难，因为：您需要深入了解 HTML、CSS 和 JavaScript 等 Web 技术。您需要深入了解 HTML、CSS 和 JavaScript 等 Web 技术。制作复杂的交互式应用程序需要仔细分析交互流，以确保当输入更改时，仅更新相关的输出。制作复杂的交互式应用程序需要仔细分析交互流，以确保当输入更改时，仅更新相关的输出。Shiny 使 R 程序员可以通过以下方式更轻松地创建 Web 应用程序：提供一组精心策划的用户界面（简称 UI）功能，用于生成常见任务所需的 HTML、CSS 和 JavaScript。\n这意味着您不需要了解 HTML/CSS/JavaScript 的详细信息，除非您想要超越 Shiny 为您提供的基础。提供一组精心策划的用户界面（简称 UI）功能，用于生成常见任务所需的 HTML、CSS 和 JavaScript。\n这意味着您不需要了解 HTML/CSS/JavaScript 的详细信息，除非您想要超越 Shiny 为您提供的基础。引入一种称为反应式编程（reactive programming）的新编程风格，它自动跟踪代码片段的依赖关系。\n这意味着每当输入发生变化时，Shiny 都可以自动找出如何做最少的工作来更新所有相关的输出。引入一种称为反应式编程（reactive programming）的新编程风格，它自动跟踪代码片段的依赖关系。\n这意味着每当输入发生变化时，Shiny 都可以自动找出如何做最少的工作来更新所有相关的输出。人们使用 Shiny 来：创建跟踪重要的高级性能指标的仪表盘，同时促进深入了解需要更多调查的指标。创建跟踪重要的高级性能指标的仪表盘，同时促进深入了解需要更多调查的指标。用交互式应用程序替换数百页 PDF，让用户可以跳转到他们关心的结果的确切部分。用交互式应用程序替换数百页 PDF，让用户可以跳转到他们关心的结果的确切部分。通过信息丰富的可视化和交互式敏感性分析，向非技术受众传达复杂的模型。通过信息丰富的可视化和交互式敏感性分析，向非技术受众传达复杂的模型。为常见工作流程提供自助数据分析，用 Shiny 应用程序取代电子邮件请求，允许人们上传自己的数据并执行标准分析。\n您可以为没有编程技能的用户提供复杂的 R 分析。为常见工作流程提供自助数据分析，用 Shiny 应用程序取代电子邮件请求，允许人们上传自己的数据并执行标准分析。\n您可以为没有编程技能的用户提供复杂的 R 分析。创建用于教授统计学和数据科学概念的交互式演示，使学习者能够调整输入并观察分析中这些变化的下游影响。创建用于教授统计学和数据科学概念的交互式演示，使学习者能够调整输入并观察分析中这些变化的下游影响。简而言之，Shiny 使您能够将一些 R 超能力传递给任何可以使用网络的人。","code":""},{"path":"preface.html","id":"who-should-read-this-book","chapter":"Preface","heading":"0.2 Who should read this book?","text":"本书针对两种主要读者：有兴趣了解 Shiny 以便将他们的分析转化为交互式 Web 应用程序的 R 用户。\n为了充分利用本书，您应该能够熟练地使用 R 进行数据分析，并且至少应该编写一些函数。有兴趣了解 Shiny 以便将他们的分析转化为交互式 Web 应用程序的 R 用户。\n为了充分利用本书，您应该能够熟练地使用 R 进行数据分析，并且至少应该编写一些函数。现有的 Shiny 用户希望提高对 Shiny 基础理论的了解，以便更快、更轻松地编写更高质量的应用程序。\n如果您的应用程序开始变得越来越大并且您开始在管理复杂性方面遇到问题，那么您应该会发现这本书特别有帮助。现有的 Shiny 用户希望提高对 Shiny 基础理论的了解，以便更快、更轻松地编写更高质量的应用程序。\n如果您的应用程序开始变得越来越大并且您开始在管理复杂性方面遇到问题，那么您应该会发现这本书特别有帮助。","code":""},{"path":"preface.html","id":"what-will-you-learn","chapter":"Preface","heading":"0.3 What will you learn?","text":"本书分为四个部分：在 “Getting started” 部分，您将学习 Shiny 的基础知识，以便您可以尽快启动并运行。\n您将了解应用程序结构的基础知识、有用的 UI 组件以及响应式编程的基础知识。在 “Getting started” 部分，您将学习 Shiny 的基础知识，以便您可以尽快启动并运行。\n您将了解应用程序结构的基础知识、有用的 UI 组件以及响应式编程的基础知识。“Shiny action” 部分建立在帮助您解决常见问题的基础知识之上，包括向用户提供反馈、上传和下载数据、使用代码生成 UI、减少代码重复以及使用 Shiny 对 tidyverse 进行编程。“Shiny action” 部分建立在帮助您解决常见问题的基础知识之上，包括向用户提供反馈、上传和下载数据、使用代码生成 UI、减少代码重复以及使用 Shiny 对 tidyverse 进行编程。在 “Mastering reactivity” 部分，您将深入了解反应式编程的理论和实践，这是 Shiny 的编程范例。\n如果您是现有的 Shiny 用户，您将从本章中获得最大的价值，因为它将为您提供坚实的理论基础，使您能够创建专门针对您的问题定制的新工具。在 “Mastering reactivity” 部分，您将深入了解反应式编程的理论和实践，这是 Shiny 的编程范例。\n如果您是现有的 Shiny 用户，您将从本章中获得最大的价值，因为它将为您提供坚实的理论基础，使您能够创建专门针对您的问题定制的新工具。最后，在 “Best practices” 部分，我们将完成对使您的 Shiny 应用程序在生产中良好运行的有用技术的调查。\n您将学习如何将复杂的应用程序分解为函数和模块，如何使用包来组织代码，如何测试代码以确保其正确，以及如何衡量和提高性能。最后，在 “Best practices” 部分，我们将完成对使您的 Shiny 应用程序在生产中良好运行的有用技术的调查。\n您将学习如何将复杂的应用程序分解为函数和模块，如何使用包来组织代码，如何测试代码以确保其正确，以及如何衡量和提高性能。","code":""},{"path":"preface.html","id":"what-wont-you-learn","chapter":"Preface","heading":"0.4 What won’t you learn?","text":"本书的重点是制作有效的 Shiny 应用程序并理解反应式的基本理论。\n我将尽力展示数据科学、R 编程和软件工程的最佳实践，但您需要其他参考资料来掌握这些重要技能。\n如果您喜欢我在本书中的写作，您可能会喜欢我关于这些主题的其他书籍：R Data Science、Advanced R 和 R Packages。还有一些特定于 Shiny 的重要主题我没有涉及：本书仅涵盖内置的用户界面工具包。\n这并没有提供最性感的设计，但它很容易学习并且可以让你走得很远。\n如果您有其他需求（或者只是对默认设置感到厌倦），还有许多其他软件包可以提供替代前端。\n参见 Section ?? 获取更多细节。本书仅涵盖内置的用户界面工具包。\n这并没有提供最性感的设计，但它很容易学习并且可以让你走得很远。\n如果您有其他需求（或者只是对默认设置感到厌倦），还有许多其他软件包可以提供替代前端。\n参见 Section ?? 获取更多细节。部署 Shiny 应用程序。\n将 Shiny “投入生产” 超出了本书的讨论范围，因为每个公司的情况差异很大，而且其中大部分与 R 无关（大多数挑战往往是文化或组织方面的，而不是技术方面的）。\n如果您在生产中不熟悉 Shiny，我建议您从 Joe Cheng’s 2019 rstudio::conf keynote: https://rstudio.com/resources/rstudioconf-2019/shiny--production-principles-practices--tools/ 开始。\n这将为您提供基本情况，广泛讨论将 Shiny 投入生产需要什么以及如何克服您可能面临的一些挑战。\n完成此操作后，请访问 RStudio Connect website，了解用于在公司内部署应用程序的 RStudio 产品，并访问 Shiny website了解其他常见部署场景。部署 Shiny 应用程序。\n将 Shiny “投入生产” 超出了本书的讨论范围，因为每个公司的情况差异很大，而且其中大部分与 R 无关（大多数挑战往往是文化或组织方面的，而不是技术方面的）。\n如果您在生产中不熟悉 Shiny，我建议您从 Joe Cheng’s 2019 rstudio::conf keynote: https://rstudio.com/resources/rstudioconf-2019/shiny--production-principles-practices--tools/ 开始。\n这将为您提供基本情况，广泛讨论将 Shiny 投入生产需要什么以及如何克服您可能面临的一些挑战。\n完成此操作后，请访问 RStudio Connect website，了解用于在公司内部署应用程序的 RStudio 产品，并访问 Shiny website了解其他常见部署场景。","code":""},{"path":"preface.html","id":"prerequisites","chapter":"Preface","heading":"0.5 Prerequisites","text":"在我们继续之前，请确保您拥有本书所需的所有软件：R：如果你还没有安装 R，你可能读错书了；我假设您对本书中的 R 有基本的了解。\n如果您想学习如何使用 R，我会推荐我的 R Data Science，它旨在帮助您轻松上手并运行 R。R：如果你还没有安装 R，你可能读错书了；我假设您对本书中的 R 有基本的了解。\n如果您想学习如何使用 R，我会推荐我的 R Data Science，它旨在帮助您轻松上手并运行 R。RStudio：RStudio 是一个免费的开源 R 集成开发环境 (IDE)。\n虽然您可以在任何 R 环境（包括 R GUI 和 ESS）中编写和使用 Shiny 应用程序，但 RStudio 有一些专门用于创作、调试和部署 Shiny 应用程序的出色功能。\n我们建议您尝试一下，但并不需要使用 Shiny 或本书即可获得成功。\n您可以从 https://www.rstudio.com/products/rstudio/download 下载 RStudio Desktop。RStudio：RStudio 是一个免费的开源 R 集成开发环境 (IDE)。\n虽然您可以在任何 R 环境（包括 R GUI 和 ESS）中编写和使用 Shiny 应用程序，但 RStudio 有一些专门用于创作、调试和部署 Shiny 应用程序的出色功能。\n我们建议您尝试一下，但并不需要使用 Shiny 或本书即可获得成功。\n您可以从 https://www.rstudio.com/products/rstudio/download 下载 RStudio Desktop。R packages：本书使用了一堆 R 包。\n您可以通过运行以下命令一次性安装它们：\n\ninstall.packages(c(\n  \"gapminder\", \"ggforce\", \"gh\", \"globals\", \"openintro\", \"profvis\", \n  \"RSQLite\", \"shiny\", \"shinycssloaders\", \"shinyFeedback\", \n  \"shinythemes\", \"testthat\", \"thematic\", \"tidyverse\", \"vroom\", \n  \"waiter\", \"xml2\", \"zeallot\" \n))\n如果您过去下载过 Shiny，请确保您的版本至少为 1.6.0。R packages：本书使用了一堆 R 包。\n您可以通过运行以下命令一次性安装它们：如果您过去下载过 Shiny，请确保您的版本至少为 1.6.0。","code":"\ninstall.packages(c(\n  \"gapminder\", \"ggforce\", \"gh\", \"globals\", \"openintro\", \"profvis\", \n  \"RSQLite\", \"shiny\", \"shinycssloaders\", \"shinyFeedback\", \n  \"shinythemes\", \"testthat\", \"thematic\", \"tidyverse\", \"vroom\", \n  \"waiter\", \"xml2\", \"zeallot\" \n))"},{"path":"preface.html","id":"acknowledgements","chapter":"Preface","heading":"0.6 Acknowledgements","text":"这本书是公开撰写的，完成后各章节会在 Twitter 上发布广告。\n这确实是社区的努力：许多人阅读草稿、修正拼写错误、提出改进建议并贡献内容。\n如果没有这些贡献者，这本书就不会这么好，我非常感谢他们的帮助。big thank 83 people contributed specific improvements via GitHub pull requests (alphabetical order username): Adam Pearce (@1wheel), Adi Sarid (@adisarid), Alexandros Melemenidis (@alex-m-ffm), Anton Klåvus (@antonvsdata), Betsy Rosalen (@betsyrosalen), Michael Beigelmacher (@brooklynbagel), Bryan Smith (@BSCowboy), c1au6io_hh (@c1au6i0), @canovasjm, Chris Beeley (@ChrisBeeley), @chsafouane, Chuliang Xiao (@ChuliangXiao), Conor Neilson (@condwanaland), @d-edison, Dean Attali (@daattali), DanielDavid521 (@Danieldavid521), David Granjon (@DivadNojnarg), Eduardo Vásquez (@edovtp), Emil Hvitfeldt (@EmilHvitfeldt), Emilio (@emilopezcano), Emily Riederer (@emilyriederer), Eric Simms (@esimms999), Federico Marini (@federicomarini), Frederik Kok Hansen (@fkoh111), Frans van Dunné (@FvD), Giorgio Comai (@giocomai), Hedley (@heds1), Henning (@henningsway), Hlynur (@hlynurhallgrims), @hsm207, @jacobxk, James Pooley (@jamespooley), Joe Cheng (@jcheng5), Julien Colomb (@jcolomb), Juan C Rodriguez (@jcrodriguez1989), Jennifer (Jenny) Bryan (@jennybc), Jim Hester (@jimhester), Joachim Gassen (@joachim-gassen), Jon Calder (@jonmcalder), Jonathan Carroll (@jonocarroll), Julian Stanley (@julianstanley), @jyuu, @kaanpekel, Karandeep Singh (@kdpsingh), Robert Kirk DeLisle (@KirkDCO), Elaine (@loomalaine), Malcolm Barrett (@malcolmbarrett), Marly Gotti (@marlycormar), Matthew Wilson (@MattW-Geospatial), Matthew T. Warkentin (@mattwarkentin), Mauro Lepore (@maurolepore), Maximilian Rohde (@maxdrohde), Matthew Berginski (@mbergins), Michael Dewar (@michael-dewar), Mine Cetinkaya-Rundel (@mine-cetinkaya-rundel), Maria Paula Caldas (@mpaulacaldas), nthobservation (@nthobservation), Pietro Monticone (@pitmonticone), psychometrician (@psychometrician), Ram Thapa (@raamthapa), Janko Thyson (@rappster), Rebecca Janis (@rbjanis), Tom Palmer (@remlapmot), Russ Hyde (@russHyde), Barret Schloerke (@schloerke), Scott (@scottyd22), Matthew Sedaghatfar (@sedaghatfar), Shixiang Wang (@ShixiangWang), Praer (Suthira Owlarn) (@sowla), Sébastien Rochette (@statnmap), @stevensbr, André Calero Valdez (@Sumidu), Tanner Stauss (@tmstauss), Tony Fujs (@tonyfujs), Stefan Moog (@trekonom), Jeff Allen (@trestletech), Trey Gilliland (@treygilliland), Albrecht (@Tungurahua), Valeri Voev (@ValeriVoev), Vickus (@Vickusr), William Doane (@WilDoane), 黄湘云 (@XiangyunHuang), gXcloud (@xwydq).","code":"#> Warning: package 'dplyr' was built under R version 4.2.3"},{"path":"preface.html","id":"colophon","chapter":"Preface","heading":"0.7 Colophon","text":"本书是使用 bookdown 在 RStudio 中编写的。\n该网站由 netlify 托管，并在 Github Actions 每次提交后自动更新。完整的源代码可以从 GitHub 获取。本书的这个版本是使用 R 版本 R version 4.2.0 (2022-04-22 ucrt) 和以下软件包构建的：","code":""},{"path":"basic-intro.html","id":"basic-intro","chapter":"Introduction","heading":"Introduction","text":"接下来四章的目标是让您尽快编写 Shiny 应用程序。\n在 Chapter 1 中，我将从小而完整的开始，向您展示应用程序的所有主要部分以及它们如何组合在一起。\n然后在 Chapters 2 和 3 您将开始深入了解 Shiny 应用程序的两个主要部分的详细信息：前端（用户在浏览器中看到的内容）和后端（使其全部正常工作的代码）。\n我们将在 Chapter 4 结束，通过案例研究来帮助巩固您迄今为止学到的概念。","code":""},{"path":"basic-app.html","id":"basic-app","chapter":"1 Your first Shiny app","heading":"1 Your first Shiny app","text":"","code":""},{"path":"basic-app.html","id":"introduction","chapter":"1 Your first Shiny app","heading":"1.1 Introduction","text":"在本章中，我们将创建一个简单的 Shiny app。\n我将首先向您展示 Shiny app 所需的最小样板，然后您将学习如何启动和停止它。\n接下来，您将学习每个 Shiny app 的两个关键组件：定义 app 外观的 UI（user interface 的缩写），和定义 app 工作方式的 server function。\nShiny 使用响应式编程（reactive programming）在输入变化时自动更新输出，因此我们将通过学习 Shiny app 的第三个重要组件来结束本章：响应式表达式（reactive expressions）。如果您尚未安装 Shiny，请立即安装：如果您已经安装了 Shiny，请使用 packageVersion(\"shiny\") 检查您是否拥有 1.5.0 或更高版本。然后加载当前的 R 会话：","code":"\ninstall.packages(\"shiny\")\nlibrary(shiny)"},{"path":"basic-app.html","id":"create-app","chapter":"1 Your first Shiny app","heading":"1.2 Create app directory and file","text":"有多种方法可以创建 Shiny app。\n最简单的方法是为您的 app 创建一个新目录，并在其中放置一个名为 app.R 的文件。\n这个 app.R 文件将用于告诉 Shiny 您的 app 应该如何显示以及它应该如何运行。通过创建一个新目录并添加一个如下所示的 app.R 文件来尝试一下：这是一个完整但微不足道的 Shiny app！\n仔细观察上面的代码，我们的 app.R 做了四件事：它调用 library(shiny) 来加载 shiny 包。它调用 library(shiny) 来加载 shiny 包。它定义了用户界面，即人类与之交互的 HTML 网页。\n在本例中，它是一个包含 “Hello, world!” 字样的页面。它定义了用户界面，即人类与之交互的 HTML 网页。\n在本例中，它是一个包含 “Hello, world!” 字样的页面。它通过定义 server 函数来指定我们 app 的行为。\n它目前是空的，所以我们的应用程序不执行任何操作，但我们很快就会回来重新讨论这个问题。它通过定义 server 函数来指定我们 app 的行为。\n它目前是空的，所以我们的应用程序不执行任何操作，但我们很快就会回来重新讨论这个问题。它执行 shinyApp(ui, server) 来从 UI 和 server 构建并启动 Shiny app。它执行 shinyApp(ui, server) 来从 UI 和 server 构建并启动 Shiny app。RStudio Tip: 在 RStudio 中创建一个新的 app 有两种便捷的方法：单击 File | New Project 创建一个新目录和一个包含基本 app 的 app.R 文件，然后选择 New Directory 和 Shiny Web Application。单击 File | New Project 创建一个新目录和一个包含基本 app 的 app.R 文件，然后选择 New Directory 和 Shiny Web Application。如果您已经创建了 app.R 文件，则可以通过键入 “shinyapp” 并按 Shift+Tab 快速添加 app 样板。如果您已经创建了 app.R 文件，则可以通过键入 “shinyapp” 并按 Shift+Tab 快速添加 app 样板。","code":"\nlibrary(shiny)\nui <- fluidPage(\n  \"Hello, world!\"\n)\nserver <- function(input, output, session) {\n}\nshinyApp(ui, server)"},{"path":"basic-app.html","id":"running","chapter":"1 Your first Shiny app","heading":"1.3 Running and stopping","text":"您可以通过以下几种方式运行此 app：单击文档工具栏中的 Run App (Figure 1.1) 按钮。单击文档工具栏中的 Run App (Figure 1.1) 按钮。使用键盘快捷键：Cmd/Ctrl + Shift + Enter。使用键盘快捷键：Cmd/Ctrl + Shift + Enter。如果您不使用 RStudio，您可以 (source())1 整个文档，或者使用包含 app.R 的目录的路径调用 shiny::runApp()。如果您不使用 RStudio，您可以 (source())1 整个文档，或者使用包含 app.R 的目录的路径调用 shiny::runApp()。\nFigure 1.1: Run App 按钮位于源窗格的右上角。\n选择这些选项之一，并检查您是否看到与 Figure 1.2 中相同的 app。\n恭喜！\n您已经制作了第一个 Shiny app。\nFigure 1.2: 当您运行上面的代码时，您将看到一个非常基本的 shiny app\n在关闭 app 之前，请返回 RStudio 并查看 R console。\n你会注意到它说的是这样的：这告诉您可以找到您的 app 的 URL：127.0.0.1 是一个标准地址，表示“这台计算机”，3827 是一个随机分配的端口号（port）。\n您可以在任何兼容的2网络浏览器中输入该 URL 以打开你的 app 的另一个副本。另请注意 R 正忙：R 提示不可见，并且控制台工具栏显示停止标志图标。\n当 Shiny app 运行时，它会“阻止” R console。\n这意味着在 Shiny app 停止之前，您无法在 R console 上运行新命令。您可以使用以下任一选项停止 app 并返回对 console 的访问权限：单击 R console 工具栏上的停止标志图标。单击 R console 工具栏上的停止标志图标。单击 console，然后按 Esc（如果您不使用 RStudio，则按 Ctrl + C）。单击 console，然后按 Esc（如果您不使用 RStudio，则按 Ctrl + C）。关闭 Shiny app 窗口。关闭 Shiny app 窗口。Shiny app 开发的基本工作流程是编写一些代码，启动 app，使用 app，编写更多代码，然后重复。\n如果您使用的是 RStudio，您甚至不需要停止并重新启动应用程序即可查看更改 — 您可以按工具箱中的 Reload app 按钮或使用 Cmd/Ctrl + Shift + Enter 键盘快捷键。\n我将在 Chapter 5 中介绍其他工作流程模式。","code":"\n#> Listening on http://127.0.0.1:3827"},{"path":"basic-app.html","id":"adding-ui","chapter":"1 Your first Shiny app","heading":"1.4 Adding UI controls","text":"接下来，我们将向 UI 添加一些输入和输出，这样它就不会那么小了。\n我们将制作一个非常简单的 app，向您显示 datasets 包中包含的所有内置 data frames。将您的 ui 替换为以下代码：此示例使用四个新函数：fluidPage() 是一个 layout function，用于设置页面的基本视觉结构。\n您将在 Section ?? 中了解有关它们的更多信息。fluidPage() 是一个 layout function，用于设置页面的基本视觉结构。\n您将在 Section ?? 中了解有关它们的更多信息。selectInput() 是一个 input control，允许用户通过提供值（value）与 app 交互。\n在本例中，它是一个带有 “Dataset” 标签的选择框，可让您选择 R 附带的内置数据集之一。\n您将在 Section 2.2 中了解有关输入的更多信息。selectInput() 是一个 input control，允许用户通过提供值（value）与 app 交互。\n在本例中，它是一个带有 “Dataset” 标签的选择框，可让您选择 R 附带的内置数据集之一。\n您将在 Section 2.2 中了解有关输入的更多信息。verbatimTextOutput() 和 tableOutput() 是 output controls，它们告诉 Shiny 将渲染的输出放在哪里（我们稍后会介绍如何放置）。\nverbatimTextOutput() 显示代码，tableOutput() 显示表格。\n您将在 Section 2.3 中了解有关输出的更多信息。verbatimTextOutput() 和 tableOutput() 是 output controls，它们告诉 Shiny 将渲染的输出放在哪里（我们稍后会介绍如何放置）。\nverbatimTextOutput() 显示代码，tableOutput() 显示表格。\n您将在 Section 2.3 中了解有关输出的更多信息。布局函数、输入和输出有不同的用途，但它们本质上是相同的：它们都是生成 HTML 的奇特方法，如果您在 Shiny app 之外调用其中任何一个，您将看到 HTML 在控制台打印出来。\n不要害怕四处探索，看看这些不同的布局和控件在幕后是如何工作的。继续并再次运行该 app。\n现在您将看到 Figure 1.3，这是一个包含选择框的页面。\n我们只看到输入，看不到两个输出，因为我们还没有告诉 Shiny 输入和输出是如何关联的。\nFigure 1.3: datasets app UI\n","code":"\nui <- fluidPage(\n  selectInput(\"dataset\", label = \"Dataset\", choices = ls(\"package:datasets\")),\n  verbatimTextOutput(\"summary\"),\n  tableOutput(\"table\")\n)"},{"path":"basic-app.html","id":"server-function","chapter":"1 Your first Shiny app","heading":"1.5 Adding behaviour","text":"接下来，我们将通过在 server 函数中定义输出来使输出变得生动。Shiny 使用响应式编程使 apps 具有交互性。\n您将在 Chapter 3 中了解有关响应式编程的更多信息，但现在请注意，它涉及告诉 Shiny 如何执行计算，而不是命令 Shiny 实际执行计算。\n这就像给某人一个菜谱和要求他们给你做一个三明治之间的区别。我们将通过提供这些输出的“配方”来告诉 Shiny 如何在示例 app 中填写 summary 和 table 输出。\n将空的 server 函数替换为：赋值运算符 (<-) 的左侧，output$ID，表示您正在为具有该 ID 的 Shiny 输出提供配方。\n赋值的右侧使用特定的渲染函数（render function）来包装您提供的一些代码。\n每个 render{Type} 函数都旨在生成特定类型的输出（例如文本、表格和绘图），并且通常与 {type}Output 函数配对。\n例如，在此 app 中，renderPrint() 与 verbatimTextOutput() 配合使用，以显示固定宽度（逐字）文本的统计摘要，而 renderTable() 与 tableOutput() 配合使用，以在表格中显示输入数据。再次运行 app 并进行测试，观察更改输入时输出会发生什么情况。\nFigure 1.4 显示了打开 app 时应该看到的内容。\nFigure 1.4: 现在我们已经提供了连接输出和输入的 server function，我们有了一个功能齐全的 app\n请注意，每当您更改输入数据集时，摘要和表格都会更新。\n这种依赖关系是隐式创建的，因为我们在输出函数中引用了 input$dataset。\ninput$dataset 填充了带有 id dataset 的 UI 组件的当前值，并且每当该值发生变化时都会导致输出自动更新。\n这是响应式（reactivity）的本质：当输入发生变化时，输出会自动做出响应（重新计算）。","code":"\nserver <- function(input, output, session) {\n  output$summary <- renderPrint({\n    dataset <- get(input$dataset, \"package:datasets\")\n    summary(dataset)\n  })\n  \n  output$table <- renderTable({\n    dataset <- get(input$dataset, \"package:datasets\")\n    dataset\n  })\n}"},{"path":"basic-app.html","id":"reactive-expr","chapter":"1 Your first Shiny app","heading":"1.6 Reducing duplication with reactive expressions","text":"即使在这个简单的示例中，我们也有一些重复的代码：两个输出中都存在以下行。在每种编程中，重复代码都是不好的做法；它可能会造成计算浪费，更重要的是，它增加了维护或调试代码的难度。\n这在这里并不重要，但我想在一个非常简单的上下文中说明基本思想。不幸的是，这些方法在这里都不起作用，原因您将在 Section ?? 中了解，并且我们需要一种新机制：响应式表达式（reactive expressions）。您可以通过将代码块包装在 reactive({...}) 中并将其分配给变量来创建响应式表达式，然后通过像函数一样调用它来使用响应式表达式。\n但是，虽然看起来像是在调用函数，但响应式表达式有一个重要的区别：它仅在第一次调用时运行，然后缓存其结果，直到需要更新为止。我们可以更新我们的 server() 以使用响应式表达式，如下所示。\n该 app 的行为相同，但工作效率更高一些，因为它只需要检索数据集一次，而不是两次。我们将多次回到响应式编程，但即使具备输入、输出和响应式表达式的粗略知识，也可以构建非常有用的 Shiny apps！","code":"\ndataset <- get(input$dataset, \"package:datasets\")\nserver <- function(input, output, session) {\n  # Create a reactive expression\n  dataset <- reactive({\n    get(input$dataset, \"package:datasets\")\n  })\n\n  output$summary <- renderPrint({\n    # Use a reactive expression by calling it like a function\n    summary(dataset())\n  })\n  \n  output$table <- renderTable({\n    dataset()\n  })\n}"},{"path":"basic-app.html","id":"summary","chapter":"1 Your first Shiny app","heading":"1.7 Summary","text":"在本章中，您创建了一个简单的 app — 它不是很令人兴奋或有用，但您看到了使用现有的 R 知识构建一个 web app 是多么容易。\n在接下来的两章中，您将了解有关用户界面和响应式编程的更多信息，这是 Shiny 的两个基本构建块。\n现在是获取 Shiny cheatsheet 的好时机。\n这是一个很好的资源，可以帮助您回忆 Shiny app 的主要组件。\nFigure 1.5: Shiny cheatsheet, available https://www.rstudio.com/resources/cheatsheets/\n","code":""},{"path":"basic-app.html","id":"exercises","chapter":"1 Your first Shiny app","heading":"1.8 Exercises","text":"创建一个通过名字向用户打招呼的 app。\n您还不知道执行此操作所需的所有函数，因此我在下面添加了一些代码行。\n考虑一下您将使用哪些行，然后将它们复制并粘贴到 Shiny app 中的正确位置。\n\ntableOutput(\"mortgage\")\noutput$greeting <- renderText({\n  paste0(\"Hello \", input$name)\n})\nnumericInput(\"age\", \"old ?\", value = NA)\ntextInput(\"name\", \"name?\")\ntextOutput(\"greeting\")\noutput$histogram <- renderPlot({\n  hist(rnorm(1000))\n}, res = 96)创建一个通过名字向用户打招呼的 app。\n您还不知道执行此操作所需的所有函数，因此我在下面添加了一些代码行。\n考虑一下您将使用哪些行，然后将它们复制并粘贴到 Shiny app 中的正确位置。假设您的朋友想要设计一个 app，允许用户设置 1 到 50 之间的数字 (x)，并显示该数字乘以 5 的结果。\n这是他们的第一次尝试：\n\nlibrary(shiny)\n\nui <- fluidPage(\n  sliderInput(\"x\", label = \"x \", min = 1, max = 50, value = 30),\n  \"x times 5 \",\n  textOutput(\"product\")\n)\n\nserver <- function(input, output, session) {\n  output$product <- renderText({ \n    x * 5\n  })\n}\n\nshinyApp(ui, server)\n但不幸的是它有一个错误：\n\n你能帮助他们找到并纠正错误吗？假设您的朋友想要设计一个 app，允许用户设置 1 到 50 之间的数字 (x)，并显示该数字乘以 5 的结果。\n这是他们的第一次尝试：但不幸的是它有一个错误：你能帮助他们找到并纠正错误吗？扩展上一个练习中的 app，以允许用户设置乘数 y 的值，以便应用程序生成 x * y 的值。\n最终结果应该是这样的：\n扩展上一个练习中的 app，以允许用户设置乘数 y 的值，以便应用程序生成 x * y 的值。\n最终结果应该是这样的：使用以下 app，它为上一个练习中描述的最后一个 app 添加了一些附加功能。\n什么是新的？\n如何通过使用响应式表达式来减少 app 中重复代码的数量。\n\nlibrary(shiny)\n\nui <- fluidPage(\n  sliderInput(\"x\", \"x \", min = 1, max = 50, value = 30),\n  sliderInput(\"y\", \"y \", min = 1, max = 50, value = 5),\n  \", (x * y) \", textOutput(\"product\"),\n  \", (x * y) + 5 \", textOutput(\"product_plus5\"),\n  \"(x * y) + 10 \", textOutput(\"product_plus10\")\n)\n\nserver <- function(input, output, session) {\n  output$product <- renderText({ \n    product <- input$x * input$y\n    product\n  })\n  output$product_plus5 <- renderText({ \n    product <- input$x * input$y\n    product + 5\n  })\n  output$product_plus10 <- renderText({ \n    product <- input$x * input$y\n    product + 10\n  })\n}\n\nshinyApp(ui, server)使用以下 app，它为上一个练习中描述的最后一个 app 添加了一些附加功能。\n什么是新的？\n如何通过使用响应式表达式来减少 app 中重复代码的数量。以下 app 与您在本章前面看到的 app 非常相似：您从包中选择一个数据集（这次我们使用 ggplot2 包），然后该 app 打印出数据的摘要和绘图。\n它还遵循良好实践并利用响应式表达式来避免代码冗余。\n然而，下面提供的代码中存在三个错误。\n你能找到并修复它们吗？\n\nlibrary(shiny)\nlibrary(ggplot2)\n#> Warning: package 'ggplot2' built R version 4.2.3\n\ndatasets <- c(\"economics\", \"faithfuld\", \"seals\")\nui <- fluidPage(\n  selectInput(\"dataset\", \"Dataset\", choices = datasets),\n  verbatimTextOutput(\"summary\"),\n  tableOutput(\"plot\")\n)\n\nserver <- function(input, output, session) {\n  dataset <- reactive({\n    get(input$dataset, \"package:ggplot2\")\n  })\n  output$summmry <- renderPrint({\n    summary(dataset())\n  })\n  output$plot <- renderPlot({\n    plot(dataset)\n  }, res = 96)\n}\n\nshinyApp(ui, server)以下 app 与您在本章前面看到的 app 非常相似：您从包中选择一个数据集（这次我们使用 ggplot2 包），然后该 app 打印出数据的摘要和绘图。\n它还遵循良好实践并利用响应式表达式来避免代码冗余。\n然而，下面提供的代码中存在三个错误。\n你能找到并修复它们吗？","code":"\ntableOutput(\"mortgage\")\noutput$greeting <- renderText({\n  paste0(\"Hello \", input$name)\n})\nnumericInput(\"age\", \"How old are you?\", value = NA)\ntextInput(\"name\", \"What's your name?\")\ntextOutput(\"greeting\")\noutput$histogram <- renderPlot({\n  hist(rnorm(1000))\n}, res = 96)\nlibrary(shiny)\n\nui <- fluidPage(\n  sliderInput(\"x\", label = \"If x is\", min = 1, max = 50, value = 30),\n  \"then x times 5 is\",\n  textOutput(\"product\")\n)\n\nserver <- function(input, output, session) {\n  output$product <- renderText({ \n    x * 5\n  })\n}\n\nshinyApp(ui, server)\nlibrary(shiny)\n\nui <- fluidPage(\n  sliderInput(\"x\", \"If x is\", min = 1, max = 50, value = 30),\n  sliderInput(\"y\", \"and y is\", min = 1, max = 50, value = 5),\n  \"then, (x * y) is\", textOutput(\"product\"),\n  \"and, (x * y) + 5 is\", textOutput(\"product_plus5\"),\n  \"and (x * y) + 10 is\", textOutput(\"product_plus10\")\n)\n\nserver <- function(input, output, session) {\n  output$product <- renderText({ \n    product <- input$x * input$y\n    product\n  })\n  output$product_plus5 <- renderText({ \n    product <- input$x * input$y\n    product + 5\n  })\n  output$product_plus10 <- renderText({ \n    product <- input$x * input$y\n    product + 10\n  })\n}\n\nshinyApp(ui, server)\nlibrary(shiny)\nlibrary(ggplot2)\n#> Warning: package 'ggplot2' was built under R version 4.2.3\n\ndatasets <- c(\"economics\", \"faithfuld\", \"seals\")\nui <- fluidPage(\n  selectInput(\"dataset\", \"Dataset\", choices = datasets),\n  verbatimTextOutput(\"summary\"),\n  tableOutput(\"plot\")\n)\n\nserver <- function(input, output, session) {\n  dataset <- reactive({\n    get(input$dataset, \"package:ggplot2\")\n  })\n  output$summmry <- renderPrint({\n    summary(dataset())\n  })\n  output$plot <- renderPlot({\n    plot(dataset)\n  }, res = 96)\n}\n\nshinyApp(ui, server)"},{"path":"basic-ui.html","id":"basic-ui","chapter":"2 Basic UI","heading":"2 Basic UI","text":"","code":""},{"path":"basic-ui.html","id":"introduction-1","chapter":"2 Basic UI","heading":"2.1 Introduction","text":"现在您已经掌握了一个基本的 app，我们可以开始探索让 Shiny 发挥作用的细节。\n正如您在上一章中看到的，Shiny 鼓励将生成用户界面（前端）的代码与驱动 app 行为的代码（后端）分离。在本章中，我们将重点关注前端，并带您快速了解 Shiny 提供的 HTML 输入和输出。\n这使您能够捕获多种类型的数据并显示多种类型的 R 输出。\n你还没有很多方法将输入和输出拼接在一起，但我们将在 Chapter ?? 中回到这一点。在这里，我将主要坚持 Shiny 本身内置的输入和输出。\n然而，有一个丰富且充满活力的扩展包社区，例如 shinyWidgets、colorpicker、和 sorttable。\n您可以在 https://github.com/nanxstats/awesome-shiny-extensions 找到全面的、积极维护的其他软件包列表，由 Nan Xiao 维护。像往常一样，我们将首先加载 shiny 包：","code":"\nlibrary(shiny)"},{"path":"basic-ui.html","id":"inputs","chapter":"2 Basic UI","heading":"2.2 Inputs","text":"正如我们在上一章中看到的，您可以使用 sliderInput()、selectInput()、textInput() 和 numericInput() 等函数将输入控件插入到 UI 规范中。\n现在我们将讨论所有输入函数的通用结构，并快速概述 Shiny 中内置的输入。","code":""},{"path":"basic-ui.html","id":"common-structure","chapter":"2 Basic UI","heading":"2.2.1 Common structure","text":"所有输入函数都有相同的第一个参数：inputId。\n这是用于连接前端和后端的标识符：如果您的 UI 有一个 ID 为 \"name\" 的输入，server 函数将使用 input$name 访问它。inputId 有两个约束：它必须是一个仅包含字母、数字和下划线的简单字符串（不允许包含空格、短划线、句点或其他特殊字符！）。\n命名它就像在 R 中命名变量一样。它必须是一个仅包含字母、数字和下划线的简单字符串（不允许包含空格、短划线、句点或其他特殊字符！）。\n命名它就像在 R 中命名变量一样。它必须是独一无二的。\n如果它不是唯一的，您将无法在 server 函数中引用此控件！它必须是独一无二的。\n如果它不是唯一的，您将无法在 server 函数中引用此控件！大多数输入函数都有第二个参数，称为 label。\n这用于为控件创建人类可读的标签。\nShiny 不会对此字符串施加任何限制，但您需要仔细考虑它以确保您的 app 可供人类使用！\n第三个参数通常是 value，在可能的情况下，让您设置默认值。\n其余参数对于该控件来说是唯一的。创建输入时，我建议按位置提供 inputId 和 label 参数，并按名称提供所有其他参数：以下部分描述了 Shiny 中内置的输入，根据它们创建的控件类型松散地分组。\n目的是让您快速了解您的选择，而不是详尽地描述所有参数。\n我将在下面显示每个控件最重要的参数，但您需要阅读文档才能获取完整的详细信息。","code":"\nsliderInput(\"min\", \"Limit (minimum)\", value = 50, min = 0, max = 100)"},{"path":"basic-ui.html","id":"free-text","chapter":"2 Basic UI","heading":"2.2.2 Free text","text":"使用 textInput() 收集少量文本，使用 passwordInput()3 收集密码，使用 textAreaInput() 收集文本段落。如果你想确保文本具有某些属性，你可以使用 validate()，我们将在 Chapter ?? 中讨论这一点。","code":"\nui <- fluidPage(\n  textInput(\"name\", \"What's your name?\"),\n  passwordInput(\"password\", \"What's your password?\"),\n  textAreaInput(\"story\", \"Tell me about yourself\", rows = 3)\n)"},{"path":"basic-ui.html","id":"numeric-inputs","chapter":"2 Basic UI","heading":"2.2.3 Numeric inputs","text":"要收集数值，请使用 numericInput() 创建受约束的文本框或使用 sliderInput() 创建滑块。\n如果为 sliderInput() 的默认值提供长度为 2 的数值向量，您将得到一个有两端的“范围”滑块。一般来说，我建议仅在小范围或精确值不太重要的情况下使用滑块。\n尝试在小滑块上精确选择数字是一项令人沮丧的练习！滑块是高度可定制的，并且有很多方法可以调整其外观。有关更多详细信息，请参阅 ?sliderInput 和 https://shiny.rstudio.com/articles/sliders.html。","code":"\nui <- fluidPage(\n  numericInput(\"num\", \"Number one\", value = 0, min = 0, max = 100),\n  sliderInput(\"num2\", \"Number two\", value = 50, min = 0, max = 100),\n  sliderInput(\"rng\", \"Range\", value = c(10, 20), min = 0, max = 100)\n)"},{"path":"basic-ui.html","id":"dates","chapter":"2 Basic UI","heading":"2.2.4 Dates","text":"使用 dateInput() 收集单个日期，或使用 dateRangeInput() 收集两个日期的范围。\n它们提供了一个方便的日历选择器，并且像 datesdisabled 和 daysofweekdisabled 这样的附加参数允许您限制有效输入的集合。日期格式、语言和一周开始日期默认为美国标准。\n如果您要创建面向国际受众的应用程序，请设置 format、language、和 weekstart，以便日期对您的用户来说是自然的。","code":"\nui <- fluidPage(\n  dateInput(\"dob\", \"When were you born?\"),\n  dateRangeInput(\"holiday\", \"When do you want to go on vacation next?\")\n)"},{"path":"basic-ui.html","id":"limited-choices","chapter":"2 Basic UI","heading":"2.2.5 Limited choices","text":"有两种不同的方法允许用户从一组预先指定的选项中进行选择：selectInput() 和 radioButtons()。单选按钮有两个很好的功能：它们显示所有可能的选项，使其适合短列表，并且通过 choiceNames/choiceValues 参数，它们可以显示纯文本以外的选项。\nchoiceNames 决定向用户显示的内容；choiceValues 决定 server 函数中返回的内容。无论选项数量多少，使用 selectInput() 创建的下拉菜单都会占用相同的空间，这使得它们更适合较长的选项。\n您还可以设置 multiple = TRUE 以允许用户选择多个元素。如果您有大量可能的选项，您可能需要使用“服务器端” selectInput()，以便完整的可能选项集不会嵌入到 UI 中（这会导致加载速度变慢），而是由 server 根据需要发送。\n您可以在 https://shiny.rstudio.com/articles/selectize.html#server-side-selectize 了解有关此高级主题的更多信息。无法使用单选按钮选择多个值，但有一个概念上类似的替代方案：checkboxGroupInput()。如果您想要单个复选框用于单个是/否问题，请使用 checkboxInput()：","code":"\nanimals <- c(\"dog\", \"cat\", \"mouse\", \"bird\", \"other\", \"I hate animals\")\n\nui <- fluidPage(\n  selectInput(\"state\", \"What's your favourite state?\", state.name),\n  radioButtons(\"animal\", \"What's your favourite animal?\", animals)\n)\nui <- fluidPage(\n  radioButtons(\"rb\", \"Choose one:\",\n    choiceNames = list(\n      icon(\"angry\"),\n      icon(\"smile\"),\n      icon(\"sad-tear\")\n    ),\n    choiceValues = list(\"angry\", \"happy\", \"sad\")\n  )\n)\nui <- fluidPage(\n  selectInput(\n    \"state\", \"What's your favourite state?\", state.name,\n    multiple = TRUE\n  )\n)\nui <- fluidPage(\n  checkboxGroupInput(\"animal\", \"What animals do you like?\", animals)\n)\nui <- fluidPage(\n  checkboxInput(\"cleanup\", \"Clean up?\", value = TRUE),\n  checkboxInput(\"shutdown\", \"Shutdown?\")\n)"},{"path":"basic-ui.html","id":"file-uploads","chapter":"2 Basic UI","heading":"2.2.6 File uploads","text":"通过 fileInput() 允许用户使上传文件：fileInput() 需要在服务器端进行特殊处理，在 Chapter ?? 中详细讨论。","code":"\nui <- fluidPage(\n  fileInput(\"upload\", NULL)\n)"},{"path":"basic-ui.html","id":"action-buttons","chapter":"2 Basic UI","heading":"2.2.7 Action buttons","text":"使用 actionButton() 或actionLink() 让用户执行操作：操作链接和按钮最自然地与 server 函数中的 observeEvent() 或 eventReactive() 配对。\n您还没有了解这些重要的功能，但我们将在 Section 3.5 中回顾它们。您可以使用 class 参数通过使用 \"btn-primary\"、\"btn-success\"、\"btn-info\"、\"btn-warning\"、\"btn-danger\" 其中的一个来自定义外观。\n您还可以使用 \"btn-lg\"、\"btn-sm\"、\"btn-xs\" 更改大小。\n最后，您可以使用 \"btn-block\" 使按钮跨越它们嵌入的元素的整个宽度。class 参数通过设置底层 HTML 的 class 属性来工作，这会影响元素的样式。\n要查看其他选项，您可以阅读 Bootstrap（Shiny 使用的 CSS 设计系统）的文档：<http://bootstrapdocs.com/v3.3.6/docs/css/#buttons>。","code":"\nui <- fluidPage(\n  actionButton(\"click\", \"Click me!\"),\n  actionButton(\"drink\", \"Drink me!\", icon = icon(\"cocktail\"))\n)\nui <- fluidPage(\n  fluidRow(\n    actionButton(\"click\", \"Click me!\", class = \"btn-danger\"),\n    actionButton(\"drink\", \"Drink me!\", class = \"btn-lg btn-success\")\n  ),\n  fluidRow(\n    actionButton(\"eat\", \"Eat me!\", class = \"btn-block\")\n  )\n)"},{"path":"basic-ui.html","id":"exercises-1","chapter":"2 Basic UI","heading":"2.2.8 Exercises","text":"当空间非常宝贵时，使用出现在文本输入区域内的占位符来标记文本框非常有用。\n如何调用 textInput() 来生成下面的 UI？\n当空间非常宝贵时，使用出现在文本输入区域内的占位符来标记文本框非常有用。\n如何调用 textInput() 来生成下面的 UI？仔细阅读 sliderInput() 的文档，了解如何创建日期滑块，如下所示。\n仔细阅读 sliderInput() 的文档，了解如何创建日期滑块，如下所示。创建一个滑块输入以选择 0 到 100 之间的值，其中滑块上每个可选值之间的间隔为 5。\n然后，向 input widget 添加动画，以便当用户按下“播放”时，input widget 会自动滚动该范围。创建一个滑块输入以选择 0 到 100 之间的值，其中滑块上每个可选值之间的间隔为 5。\n然后，向 input widget 添加动画，以便当用户按下“播放”时，input widget 会自动滚动该范围。如果 selectInput() 中有一个相当长的列表，那么创建将列表分成几部分的子标题会很有用。\n阅读文档以了解如何操作。\n（提示：底层 HTML 称为 <optgroup>。）如果 selectInput() 中有一个相当长的列表，那么创建将列表分成几部分的子标题会很有用。\n阅读文档以了解如何操作。\n（提示：底层 HTML 称为 <optgroup>。）","code":""},{"path":"basic-ui.html","id":"outputs","chapter":"2 Basic UI","heading":"2.3 Outputs","text":"UI 中的输出创建占位符，稍后由 server 函数填充。\n与输入一样，输出采用唯一的 ID 作为其第一个参数4：如果您的 UI 规范创建 ID 为 \"plot\" 的输出，您将在 server 函数中使用 output$plot 访问它。前端的每个 output 函数都与后端的 render 函数耦合。\n输出主要有三种类型，对应于报告中通常包含的三种内容：文本、表格和图表。\n以下部分向您展示前端输出函数的基础知识，以及后端相应的 render 函数。","code":""},{"path":"basic-ui.html","id":"text","chapter":"2 Basic UI","heading":"2.3.1 Text","text":"使用 textOutput() 输出常规文本，使用 verbatimTextOutput() 输出固定代码和控制台输出。请注意，仅当需要运行多行代码时，render 函数中才需要 {}。\n正如您很快就会了解到的，您应该在 render 函数中进行尽可能少的计算，这意味着您通常可以忽略它们。\n如果写得更紧凑的话，上面的 server 函数会是这样的：请注意，有两个 render 函数的行为略有不同：renderText() 将结果组合成单个字符串，通常与 textOutput() 配对renderPrint() 打印结果，就像在 R console 中一样，并且通常与 verbatimTextOutput() 配对。我们可以看到与 toy app 的区别：这相当于 R 语言中 cat() 和 print() 的区别。","code":"\nui <- fluidPage(\n  textOutput(\"text\"),\n  verbatimTextOutput(\"code\")\n)\nserver <- function(input, output, session) {\n  output$text <- renderText({ \n    \"Hello friend!\" \n  })\n  output$code <- renderPrint({ \n    summary(1:10) \n  })\n}\nserver <- function(input, output, session) {\n  output$text <- renderText(\"Hello friend!\")\n  output$code <- renderPrint(summary(1:10))\n}\nui <- fluidPage(\n  textOutput(\"text\"),\n  verbatimTextOutput(\"print\")\n)\nserver <- function(input, output, session) {\n  output$text <- renderText(\"hello!\")\n  output$print <- renderPrint(\"hello!\")\n}"},{"path":"basic-ui.html","id":"tables","chapter":"2 Basic UI","heading":"2.3.2 Tables","text":"有两种用于在表格中显示 data frames 的选项：tableOutput() 和 renderTable() 渲染静态数据表，一次性显示所有数据。tableOutput() 和 renderTable() 渲染静态数据表，一次性显示所有数据。dataTableOutput() 和 renderDataTable() 呈现一个动态表，显示固定数量的行以及用于更改哪些行可见的控件。dataTableOutput() 和 renderDataTable() 呈现一个动态表，显示固定数量的行以及用于更改哪些行可见的控件。tableOutput() 对于小型固定摘要最有用（例如模型系数）；如果您想向用户公开完整的 data frame，则 dataTableOutput() 最合适。\n如果您想更好地控制 dataTableOutput() 的输出，我强烈推荐 Greg Lin 的 reactable 包。","code":"\nui <- fluidPage(\n  tableOutput(\"static\"),\n  dataTableOutput(\"dynamic\")\n)\nserver <- function(input, output, session) {\n  output$static <- renderTable(head(mtcars))\n  output$dynamic <- renderDataTable(mtcars, options = list(pageLength = 5))\n}"},{"path":"basic-ui.html","id":"plots","chapter":"2 Basic UI","heading":"2.3.3 Plots","text":"您可以使用 plotOutput() 和 renderPlot() 显示任何类型的 R 图形（base、ggplot2 或其他）：默认情况下，plotOutput() 将占据其容器的整个宽度（稍后会详细介绍），高度为 400 像素。\n您可以使用 height 和 width 参数覆盖这些默认值。\n我们建议始终设置 res = 96，因为这将使您的 Shiny plots 尽可能匹配您在 RStudio 中看到的内容。Plots 很特殊，因为它们是输出，也可以充当输入。\nplotOutput() 有许多参数，例如 click、dblclick 和 hover。\n如果您向它们传递一个字符串，例如 click = \"plot_click\"，它们将创建一个反应性输入 (input$plot_click)，您可以使用它来处理绘图上的用户交互，例如单击绘图。\n我们将在 Chapter ?? 中回到 Shiny 中的 interactive plots。","code":"\nui <- fluidPage(\n  plotOutput(\"plot\", width = \"400px\")\n)\nserver <- function(input, output, session) {\n  output$plot <- renderPlot(plot(1:5), res = 96)\n}"},{"path":"basic-ui.html","id":"downloads","chapter":"2 Basic UI","heading":"2.3.4 Downloads","text":"您可以使用 downloadButton() 或 downloadLink() 让用户下载文件。\n这些需要 server 函数中的新技术，所以我们将在 Chapter ?? 中回到这一点。","code":""},{"path":"basic-ui.html","id":"exercises-2","chapter":"2 Basic UI","heading":"2.3.5 Exercises","text":"以下每个 render 函数应该与 textOutput() 和 verbatimTextOutput() 中的哪一个配对？\nrenderPrint(summary(mtcars))\nrenderText(\"Good morning!\")\nrenderPrint(t.test(1:5, 2:6))\nrenderText(str(lm(mpg ~ wt, data = mtcars)))\n以下每个 render 函数应该与 textOutput() 和 verbatimTextOutput() 中的哪一个配对？renderPrint(summary(mtcars))renderPrint(summary(mtcars))renderText(\"Good morning!\")renderText(\"Good morning!\")renderPrint(t.test(1:5, 2:6))renderPrint(t.test(1:5, 2:6))renderText(str(lm(mpg ~ wt, data = mtcars)))renderText(str(lm(mpg ~ wt, data = mtcars)))重新创建 Section 2.3.3 中的 Shiny app，这次将高度设置为 300px，宽度设置为 700px。\n设置绘图 “alt” 文本，以便视障用户可以看出它是五个随机数的散点图。重新创建 Section 2.3.3 中的 Shiny app，这次将高度设置为 300px，宽度设置为 700px。\n设置绘图 “alt” 文本，以便视障用户可以看出它是五个随机数的散点图。更新下面对 renderDataTable() 的调用中的选项，以便显示数据，但抑制所有其他控件（即删除搜索、排序和过滤命令）。\n您需要阅读 ?renderDataTable 并查看 https://datatables.net/reference/option/ 中的选项。\n\nui <- fluidPage(\n  dataTableOutput(\"table\")\n)\nserver <- function(input, output, session) {\n  output$table <- renderDataTable(mtcars, options = list(pageLength = 5))\n}更新下面对 renderDataTable() 的调用中的选项，以便显示数据，但抑制所有其他控件（即删除搜索、排序和过滤命令）。\n您需要阅读 ?renderDataTable 并查看 https://datatables.net/reference/option/ 中的选项。或者，阅读有关 reactable 的内容，并将上述 app 转换为使用它。或者，阅读有关 reactable 的内容，并将上述 app 转换为使用它。","code":"\nui <- fluidPage(\n  dataTableOutput(\"table\")\n)\nserver <- function(input, output, session) {\n  output$table <- renderDataTable(mtcars, options = list(pageLength = 5))\n}"},{"path":"basic-ui.html","id":"summary-1","chapter":"2 Basic UI","heading":"2.4 Summary","text":"本章向您介绍了构成 Shiny app 前端的主要输入和输出函数。\n这是一个很大的信息转储，所以不要指望在一次阅读后记住所有内容。\n相反，当您正在寻找特定组件时，请返回本章：您可以快速浏览图形，然后找到您需要的代码。在下一章中，我们将继续讨论 Shiny app 的后端：使用户界面栩栩如生的 R 代码。","code":""},{"path":"basic-reactivity.html","id":"basic-reactivity","chapter":"3 Basic reactivity","heading":"3 Basic reactivity","text":"","code":""},{"path":"basic-reactivity.html","id":"introduction-2","chapter":"3 Basic reactivity","heading":"3.1 Introduction","text":"在 Shiny 中，您可以使用响应式编程来表达你的 server 逻辑。\n响应式编程是一种优雅而强大的编程范式，但一开始它可能会让人迷失方向，因为它与编写脚本是一种非常不同的范式。\n响应式编程的关键思想是指定依赖关系图，以便当输入更改时，所有相关输出都会自动更新。\n这使得 app 的流程变得相当简单，但需要一段时间才能理解它们是如何组合在一起的。本章将简要介绍响应式编程，教您在 Shiny apps 中使用的最常见响应式结构的基础知识。\n我们将从 server 函数的调查开始，更详细地讨论 input 和 output 参数的工作原理。\n接下来，我们将回顾最简单的响应式形式（其中输入直接连接到输出），然后讨论响应式表达式如何帮助您消除重复的工作。\n最后，我们将回顾一下 Shiny 新用户遇到的一些常见障碍。","code":""},{"path":"basic-reactivity.html","id":"the-server-function","chapter":"3 Basic reactivity","heading":"3.2 The server function","text":"正如您所看到的，每个 Shiny app 的内部结构如下所示：上一章介绍了前端的基础知识，即包含呈现给 app 的每个用户的 HTML 的 ui 对象。\nui 很简单，因为每个用户都会获得相同的 HTML。\nserver 更加复杂，因为每个用户都需要获得独立版本的 app；当用户 移动滑块时，用户 B 不应看到其输出发生变化。为了实现这种独立性，Shiny 每次启动新会话5时都会调用 server() 函数。\n就像任何其他 R 函数一样，当调用 server 函数时，它会创建一个独立于该函数的所有其他调用的新本地环境。\n这允许每个会话具有唯一的状态，并隔离函数内创建的变量。\n这就是为什么您在 Shiny 中进行的几乎所有响应式编程都将在 server 函数中进行6。Server 函数采用三个参数：input、output 和 session。\n因为您从不自己调用 server 函数，所以您永远不会自己创建这些对象。\n相反，它们是在会话开始时由 Shiny 创建的，并连接回特定会话。\n目前，我们将重点关注 input 和 output 参数，并将 session 留给后面的章节。","code":"\nlibrary(shiny)\n\nui <- fluidPage(\n  # front end interface\n)\n\nserver <- function(input, output, session) {\n  # back end logic\n}\n\nshinyApp(ui, server)"},{"path":"basic-reactivity.html","id":"input","chapter":"3 Basic reactivity","heading":"3.2.1 Input","text":"input 参数是一个类似列表的对象，其中包含从浏览器发送的所有输入数据，根据输入 ID 命名。\n例如，如果您的 UI 包含一个输入 ID 为 count 的数字输入控件，如下所示：然后您可以使用 input$count 访问该输入的值。\n它最初包含值 100，并且当用户更改浏览器中的值时，它将自动更新。与典型列表不同，input 对象是只读的。\n如果您尝试修改 server 函数内的 input，您将收到报错：发生此错误的原因是 input 反映了浏览器中发生的情况，而浏览器是 Shiny 的“单一事实来源”。\n如果您可以修改 R 中的值，则可能会导致不一致，即输入滑块在浏览器中表示一件事，而 input$count 在 R 中表示不同的内容。\n这将使编程变得具有挑战性！\n稍后，在 Chapter ?? 中，您将学习如何使用 updateNumericInput() 等函数来修改浏览器中的值，然后 input$count 也会相应更新。关于 input 的另一件重要的事情是：它对允许谁阅读它是有选择性的。\n要读取 input，您必须处于由 renderText() 或 reactive() 等函数创建的响应式上下文中。\n我们很快就会回到这个想法，但这是一个重要的约束，它允许输出在输入更改时自动更新。\n此代码说明了如果您犯此错误，您将看到的错误：","code":"\nui <- fluidPage(\n  numericInput(\"count\", label = \"Number of values\", value = 100)\n)\nserver <- function(input, output, session) {\n  input$count <- 10  \n}\n\nshinyApp(ui, server)\n#> Error: Can't modify read-only reactive value 'count'\nserver <- function(input, output, session) {\n  message(\"The value of input$count is \", input$count)\n}\n\nshinyApp(ui, server)\n#> Error: Can't access reactive value 'count' outside of reactive consumer.\n#> ℹ Do you need to wrap inside reactive() or observer()?"},{"path":"basic-reactivity.html","id":"output","chapter":"3 Basic reactivity","heading":"3.2.2 Output","text":"output 与 input 非常相似：它也是一个根据输出 ID 命名的类似列表的对象。\n主要区别在于您使用它来发送输出而不是接收输入。\n您始终将 output 对象与 render 函数结合使用，如以下简单示例所示：（请注意，该 ID 在 UI 中被引用，但在 server 中未被引用。）render 函数做了两件事：它设置了一个特殊的响应式上下文，可以自动跟踪输出使用的输入。它设置了一个特殊的响应式上下文，可以自动跟踪输出使用的输入。它将 R 代码的输出转换为适合在网页上显示的 HTML。它将 R 代码的输出转换为适合在网页上显示的 HTML。与 input 一样，output 对您的使用方式也很挑剔。\n如果出现以下情况，您将收到错误消息：你忘记了 render 函数。\n\nserver <- function(input, output, session) {\n  output$greeting <- \"Hello human\"\n}\nshinyApp(ui, server)\n#> Error: Unexpected character object output$greeting\n#> ℹ forget use render function?你忘记了 render 函数。您尝试读取 output。\n\nserver <- function(input, output, session) {\n  message(\"greeting \", output$greeting)\n}\nshinyApp(ui, server)\n#> Error: Reading shinyoutput object allowed.您尝试读取 output。","code":"\nui <- fluidPage(\n  textOutput(\"greeting\")\n)\n\nserver <- function(input, output, session) {\n  output$greeting <- renderText(\"Hello human!\")\n}\nserver <- function(input, output, session) {\n  output$greeting <- \"Hello human\"\n}\nshinyApp(ui, server)\n#> Error: Unexpected character object for output$greeting\n#> ℹ Did you forget to use a render function?\nserver <- function(input, output, session) {\n  message(\"The greeting is \", output$greeting)\n}\nshinyApp(ui, server)\n#> Error: Reading from shinyoutput object is not allowed."},{"path":"basic-reactivity.html","id":"reactive-programming","chapter":"3 Basic reactivity","heading":"3.3 Reactive programming","text":"如果 app 只有输入或只有输出，那么它会非常无聊。\n当您拥有同时具备这两种功能的 app 时，Shiny 的真正魔力就会发挥出来。\n让我们看一个简单的例子：很难在一本书中展示它是如何工作的，但我在 Figure 3.1 中尽力了。\n如果您运行该 app，并在 name 框中输入内容，您将看到问候语会在您输入时自动更新7。\nFigure 3.1: 响应式意味着输出会随着输入的变化而自动更新，就像在这个 app 中我输入“J”、“o”、“e”一样。 See live https://hadley.shinyapps.io/ms-connection.\n这是 Shiny 的重要思想：您不需要告诉输出何时更新，因为 Shiny 会自动为您计算出来。\n它是如何工作的？\n函数体内究竟发生了什么？\n让我们更精确地考虑一下 server 函数内部的代码：很容易将其理解为“将‘hello’和用户名粘贴在一起，然后将其发送到output$greeting”。\n但这种思维模式在一个微妙但重要的方面是错误的。\n想一想：使用这种模型，您只需发出一次指令。\n但每次我们更新 input$name 时，Shiny 都会执行该操作，所以肯定还有更多的事情发生。该 app 之所以有效，是因为代码不会告诉 Shiny 创建字符串并将其发送到浏览器，而是通知 Shiny 在需要时如何创建字符串。\n代码何时（甚至是否！）运行取决于 Shiny。\n它可能会在 app 启动后立即运行，也可能会晚一些；它可能会运行很多次，也可能永远不会运行！\n这并不是说 Shiny 反复无常，只是说决定何时执行代码是 Shiny 的责任，而不是你的。\n将您的 app 视为向 Shiny 提供食谱，而不是向其发出命令。","code":"\nui <- fluidPage(\n  textInput(\"name\", \"What's your name?\"),\n  textOutput(\"greeting\")\n)\n\nserver <- function(input, output, session) {\n  output$greeting <- renderText({\n    paste0(\"Hello \", input$name, \"!\")\n  })\n}\noutput$greeting <- renderText({\n  paste0(\"Hello \", input$name, \"!\")\n})"},{"path":"basic-reactivity.html","id":"imperative-vs-declarative-programming","chapter":"3 Basic reactivity","heading":"3.3.1 Imperative vs declarative programming","text":"命令和配方之间的区别是两种重要编程风格之间的主要区别之一：在命令式（imperative）编程中，您发出特定的命令，它会立即执行。\n这是您在分析脚本中习惯的编程风格：命令 R 加载数据、转换数据、可视化数据并将结果保存到磁盘。在命令式（imperative）编程中，您发出特定的命令，它会立即执行。\n这是您在分析脚本中习惯的编程风格：命令 R 加载数据、转换数据、可视化数据并将结果保存到磁盘。在声明式（declarative）编程中，您表达更高级别的目标或描述重要的约束，并依靠其他人来决定如何和/或何时将其转化为行动。\n这是您在 Shiny 中使用的编程风格。在声明式（declarative）编程中，您表达更高级别的目标或描述重要的约束，并依靠其他人来决定如何和/或何时将其转化为行动。\n这是您在 Shiny 中使用的编程风格。使用命令式代码，您可以说“给我做一个三明治”8。\n使用声明性代码，您可以说“每当我查看冰箱内部时，确保冰箱中有一个三明治”。\n命令式代码是断言的（assertive）；声明式代码是被动攻击性的（passive-aggressive）。大多数时候，声明式编程非常自由：您描述您的总体目标，软件就会计算出如何实现这些目标，而无需进一步干预。\n缺点是有时您确切地知道自己想要什么，但无法弄清楚如何以声明性系统可以理解的方式构建它9。\n本书的目的是帮助您加深对基础理论的理解，从而尽可能减少这种情况的发生。","code":""},{"path":"basic-reactivity.html","id":"laziness","chapter":"3 Basic reactivity","heading":"3.3.2 Laziness","text":"Shiny 中声明式编程的优点之一是它允许 apps 变得非常懒惰。\nShiny app 只会执行更新您当前可以看到的输出控件所需的最少工作量10。\n然而，这种懒惰带来了一个您应该意识到的重要缺点。\n你能发现下面的 server 函数有什么问题吗？如果你仔细观察，你可能会注意到我写的是 greting 而不是 greeting。\n这不会在 Shiny 中产生错误，但它不会做你想要的事情。\ngreting 输出不存在，因此 renderText() 中的代码永远不会运行。如果您正在开发一个 Shiny app，并且您无法弄清楚为什么您的代码永远不会运行，请仔细检查您的 UI 和 server 函数是否使用相同的标识符。","code":"\nserver <- function(input, output, session) {\n  output$greting <- renderText({\n    paste0(\"Hello \", input$name, \"!\")\n  })\n}"},{"path":"basic-reactivity.html","id":"the-reactive-graph","chapter":"3 Basic reactivity","heading":"3.3.3 The reactive graph","text":"Shiny 的懒惰还有另一个重要的特性。\n在大多数 R 代码中，您可以通过从上到下阅读代码来了解执行顺序。\n这在 Shiny 中不起作用，因为代码仅在需要时运行。\n要了解执行顺序，您需要查看响应式图（reactive graph），它描述了输入和输出如何连接。\n上面 app 的响应式图非常简单，如 Figure 3.2 所示。\nFigure 3.2: 响应式图显示了输入和输出的连接方式\n响应式图对于每个输入和输出都包含一个符号，每当输出访问输入时，我们就将输入连接到输出。\n该图告诉您，只要 name 更改，就需要重新计算 greeting。\n我们经常将这种关系描述为 greeting 对 name 有响应式依赖（reactive dependency）。请注意我们用于输入和输出的图形约定：name 输入自然适合 greeting 输出。\n我们可以将它们紧密地画在一起，如 Figure 3.3 所示，以强调它们组合在一起的方式；我们通常不会这样做，因为它只适用于最简单的 apps。\nFigure 3.3: 响应式图组件使用的形状唤起了它们连接的方式。\n响应式图是了解 app 工作原理的强大工具。\n随着您的 app 变得越来越复杂，制作响应式图的快速高级草图通常很有用，以提醒您所有部分如何组合在一起。\n在本书中，我们将向您展示响应式图，以帮助您理解示例的工作原理，稍后在 Chapter 14 中，您将学习如何使用 reactlog 来为您绘制图表。","code":""},{"path":"basic-reactivity.html","id":"reactive-expressions","chapter":"3 Basic reactivity","heading":"3.3.4 Reactive expressions","text":"您将在响应式图中看到一个更重要的组件：响应式表达式。\n我们很快就会详细讨论响应式表达式；现在将它们视为一种工具，通过在响应式图中引入额外的节点来减少响应式代码中的重复。我们在非常简单的 app 中不需要响应式表达式，但无论如何我都会添加一个，以便您可以看到它如何影响响应式图，Figure 3.4。\nFigure 3.4: 响应式表达式两边都有角度，因为它将输入连接到输出。\n响应式表达式接受输入并产生输出，因此它们具有结合输入和输出特征的形状。\n希望这些形状能帮助您记住组件如何组合在一起。","code":"\nserver <- function(input, output, session) {\n  string <- reactive(paste0(\"Hello \", input$name, \"!\"))\n  output$greeting <- renderText(string())\n}"},{"path":"basic-reactivity.html","id":"execution-order","chapter":"3 Basic reactivity","heading":"3.3.5 Execution order","text":"重要的是要理解代码运行的顺序完全由响应式图决定。\n这与大多数 R 代码不同，大多数 R 代码的执行顺序由行的顺序决定。\n例如，我们可以在简单的 server 函数中翻转两行的顺序：您可能认为这会产生错误，因为 output$greeting 引用尚未创建的响应式表达式、字符串。\n但请记住，Shiny 是惰性的，因此代码仅在创建字符串后会话启动时运行。相反，此代码会生成与上面相同的响应式图，因此代码的运行顺序完全相同。\n像这样组织代码会让人类感到困惑，最好避免。\n相反，请确保响应式表达式和输出仅引用上面定义的内容，而不是下面定义的内容11。\n这将使您的代码更容易理解。这个概念非常重要，并且与大多数其他 R 代码不同，所以我再说一遍：响应式代码的运行顺序仅由响应式图决定，而不是由其在 server 函数中的布局决定。","code":"\nserver <- function(input, output, session) {\n  output$greeting <- renderText(string())\n  string <- reactive(paste0(\"Hello \", input$name, \"!\"))\n}"},{"path":"basic-reactivity.html","id":"exercises-3","chapter":"3 Basic reactivity","heading":"3.3.6 Exercises","text":"给定这个 UI:\n\nui <- fluidPage(\n  textInput(\"name\", \"name?\"),\n  textOutput(\"greeting\")\n)\n修复以下三个 server 函数中发现的简单错误。\n首先尝试通过阅读代码来发现问题；然后运行代码以确保您已修复它。\n\nserver1 <- function(input, output, server) {\n  input$greeting <- renderText(paste0(\"Hello \", name))\n}\n\nserver2 <- function(input, output, server) {\n  greeting <- paste0(\"Hello \", input$name)\n  output$greeting <- renderText(greeting)\n}\n\nserver3 <- function(input, output, server) {\n  output$greting <- paste0(\"Hello\", input$name)\n}给定这个 UI:修复以下三个 server 函数中发现的简单错误。\n首先尝试通过阅读代码来发现问题；然后运行代码以确保您已修复它。绘制以下 server 函数的响应式图：\n\nserver1 <- function(input, output, session) {\n  c <- reactive(input$+ input$b)\n  e <- reactive(c() + input$d)\n  output$f <- renderText(e())\n}\nserver2 <- function(input, output, session) {\n  x <- reactive(input$x1 + input$x2 + input$x3)\n  y <- reactive(input$y1 + input$y2)\n  output$z <- renderText(x() / y())\n}\nserver3 <- function(input, output, session) {\n  d <- reactive(c() ^ input$d)\n  <- reactive(input$* 10)\n  c <- reactive(b() / input$c) \n  b <- reactive(() + input$b)\n}绘制以下 server 函数的响应式图：为什么这段代码会失败？\n\nvar <- reactive(df[[input$var]])\nrange <- reactive(range(var(), na.rm = TRUE))\n为什么 range() 和 var() 对于响应式来说是不好的名字？为什么这段代码会失败？为什么 range() 和 var() 对于响应式来说是不好的名字？","code":"\nui <- fluidPage(\n  textInput(\"name\", \"What's your name?\"),\n  textOutput(\"greeting\")\n)\nserver1 <- function(input, output, server) {\n  input$greeting <- renderText(paste0(\"Hello \", name))\n}\n\nserver2 <- function(input, output, server) {\n  greeting <- paste0(\"Hello \", input$name)\n  output$greeting <- renderText(greeting)\n}\n\nserver3 <- function(input, output, server) {\n  output$greting <- paste0(\"Hello\", input$name)\n}\nserver1 <- function(input, output, session) {\n  c <- reactive(input$a + input$b)\n  e <- reactive(c() + input$d)\n  output$f <- renderText(e())\n}\nserver2 <- function(input, output, session) {\n  x <- reactive(input$x1 + input$x2 + input$x3)\n  y <- reactive(input$y1 + input$y2)\n  output$z <- renderText(x() / y())\n}\nserver3 <- function(input, output, session) {\n  d <- reactive(c() ^ input$d)\n  a <- reactive(input$a * 10)\n  c <- reactive(b() / input$c) \n  b <- reactive(a() + input$b)\n}\nvar <- reactive(df[[input$var]])\nrange <- reactive(range(var(), na.rm = TRUE))"},{"path":"basic-reactivity.html","id":"reactive-expressions-1","chapter":"3 Basic reactivity","heading":"3.4 Reactive expressions","text":"我们已经快速浏览了几次响应式表达式，因此您希望能够了解它们可能会做什么。\n现在我们将深入探讨更多细节，并展示为什么它们在构建真实 apps 时如此重要。响应式表达式很重要，因为它们为 Shiny 提供了更多信息，以便它在输入更改时可以减少重新计算，从而使 apps 更加高效，并且它们通过简化响应式图使人们更容易理解 app。\n响应式表达式具有输入和输出的风格：与 inputs 一样，您可以在 output 中使用响应式表达式的结果。与 inputs 一样，您可以在 output 中使用响应式表达式的结果。与 outputs 一样，响应式表达式依赖于 inputs 并自动知道何时需要更新。与 outputs 一样，响应式表达式依赖于 inputs 并自动知道何时需要更新。这种二元性意味着我们需要一些新的词汇：我将使用生产者（producers）来指代响应式输入和表达式，使用消费者（consumers）来指代响应式表达式和输出。\nFigure 3.5 用维恩图显示了这种关系。\nFigure 3.5: 输入和表达式是响应式生产者；表达式和输出是响应式消费者。\n我们将需要一个更复杂的 app 来了解使用响应式表达式的好处。\n首先，我们将定义一些常规 R 函数来为我们的 app 提供支持，从而做好准备。","code":""},{"path":"basic-reactivity.html","id":"the-motivation","chapter":"3 Basic reactivity","heading":"3.4.1 The motivation","text":"想象一下，我想通过绘图和假设检验来比较两个模拟数据集。\n我做了一些实验并提出了以下函数：freqpoly() 使用频率多边形可视化两个分布12，t_test() 使用 t-test 来比较平均值并用字符串总结结果：如果我有一些模拟数据，我可以使用这些函数来比较两个变量：在真正的分析中，您可能会在最终使用这些函数之前进行大量探索。\n我在这里跳过了该探索，以便我们可以尽快使用该 app。\n但是，将命令式代码提取到常规函数中对于所有 Shiny app 来说都是一项重要技术：从 app 中提取的代码越多，它就越容易理解。\n这是很好的软件工程，因为它有助于隔离问题：app 外部的函数专注于计算，以便 app 内部的代码可以专注于响应用户操作。\n我们将在 Chapter ?? 中再次讨论这个想法。","code":"\nlibrary(ggplot2)\n\nfreqpoly <- function(x1, x2, binwidth = 0.1, xlim = c(-3, 3)) {\n  df <- data.frame(\n    x = c(x1, x2),\n    g = c(rep(\"x1\", length(x1)), rep(\"x2\", length(x2)))\n  )\n\n  ggplot(df, aes(x, colour = g)) +\n    geom_freqpoly(binwidth = binwidth, size = 1) +\n    coord_cartesian(xlim = xlim)\n}\n\nt_test <- function(x1, x2) {\n  test <- t.test(x1, x2)\n  \n  # use sprintf() to format t.test() results compactly\n  sprintf(\n    \"p value: %0.3f\\n[%0.2f, %0.2f]\",\n    test$p.value, test$conf.int[1], test$conf.int[2]\n  )\n}\nx1 <- rnorm(100, mean = 0, sd = 0.5)\nx2 <- rnorm(200, mean = 0.15, sd = 0.9)\n\nfreqpoly(x1, x2)\ncat(t_test(x1, x2))\n#> p value: 0.008\n#> [-0.37, -0.06]"},{"path":"basic-reactivity.html","id":"the-app","chapter":"3 Basic reactivity","heading":"3.4.2 The app","text":"我想使用这两个工具来快速探索一系列模拟。\nShiny app 是实现此目的的好方法，因为它可以让您避免繁琐的修改和重新运行 R 代码。\n下面我将这些片段封装到一个 Shiny app 中，我可以在其中交互式地调整输入。让我们从 UI 开始。\n我们将回到 Section ?? 中 fluidRow() 和 column() 的具体用途；但你可以从他们的名字猜出他们的目的😄。\n第一行有三列用于 input controls（distribution 1, distribution 2, plot controls）。\n第二行有一个宽的列用于绘图，一个窄的列用于假设检验。指定分布绘制后，server 函数结合了对 freqpoly() 和 t_test() 函数的调用：\nFigure 3.6: 一个 Shiny app，可让您使用 t-test 和频数多边形来比较两个模拟分布。 See live https://hadley.shinyapps.io/ms-case-study-1.\nserver 和 ui 的定义如 Figure 3.6 所示。\n您可以在 https://hadley.shinyapps.io/ms-case-study-1 找到实时版本；我建议您打开该 app 并快速玩一下，以确保您在继续阅读之前了解其基本操作。","code":"\nui <- fluidPage(\n  fluidRow(\n    column(4, \n      \"Distribution 1\",\n      numericInput(\"n1\", label = \"n\", value = 1000, min = 1),\n      numericInput(\"mean1\", label = \"µ\", value = 0, step = 0.1),\n      numericInput(\"sd1\", label = \"σ\", value = 0.5, min = 0.1, step = 0.1)\n    ),\n    column(4, \n      \"Distribution 2\",\n      numericInput(\"n2\", label = \"n\", value = 1000, min = 1),\n      numericInput(\"mean2\", label = \"µ\", value = 0, step = 0.1),\n      numericInput(\"sd2\", label = \"σ\", value = 0.5, min = 0.1, step = 0.1)\n    ),\n    column(4,\n      \"Frequency polygon\",\n      numericInput(\"binwidth\", label = \"Bin width\", value = 0.1, step = 0.1),\n      sliderInput(\"range\", label = \"range\", value = c(-3, 3), min = -5, max = 5)\n    )\n  ),\n  fluidRow(\n    column(9, plotOutput(\"hist\")),\n    column(3, verbatimTextOutput(\"ttest\"))\n  )\n)\nserver <- function(input, output, session) {\n  output$hist <- renderPlot({\n    x1 <- rnorm(input$n1, input$mean1, input$sd1)\n    x2 <- rnorm(input$n2, input$mean2, input$sd2)\n    \n    freqpoly(x1, x2, binwidth = input$binwidth, xlim = input$range)\n  }, res = 96)\n\n  output$ttest <- renderText({\n    x1 <- rnorm(input$n1, input$mean1, input$sd1)\n    x2 <- rnorm(input$n2, input$mean2, input$sd2)\n    \n    t_test(x1, x2)\n  })\n}"},{"path":"basic-reactivity.html","id":"the-reactive-graph-1","chapter":"3 Basic reactivity","heading":"3.4.3 The reactive graph","text":"让我们首先绘制这个 app 的响应式图。\nShiny 足够聪明，只有当它引用的输入发生变化时才会更新输出；它不够智能，无法仅选择性地运行输出中的代码片段。\n换句话说，输出是原子的：它们要么被执行，要么不作为一个整体执行。例如，从 server 获取此片段：作为阅读这段代码的人，您可以看出，当 n1、mean1 或 sd1 更改时，我们只需要更新 x1，当 n2、mean2 或 sd2 更改时，我们只需要更新 x2。\n然而，Shiny 只将输出视为一个整体，因此每当 n1、mean1、sd1、n2、mean2 或 sd2 之一发生变化时，它都会更新 x1 和 x2。\n这导致响应式图如 Figure 3.7 所示：\nFigure 3.7: 响应式图显示每个输出都取决于每个输入\n您会注意到该图非常密集：几乎每个输入都直接连接到每个输出。\n这会产生两个问题：该 app 很难理解，因为有很多连接。\n该 app 中没有任何部分可以单独提取和分析。该 app 很难理解，因为有很多连接。\n该 app 中没有任何部分可以单独提取和分析。该 app 效率低下，因为它做了超出必要的工作。\n例如，如果更改绘图的 breaks，则会重新计算数据；如果更改 n1 的值，x2 也会更新（在两个地方！）。该 app 效率低下，因为它做了超出必要的工作。\n例如，如果更改绘图的 breaks，则会重新计算数据；如果更改 n1 的值，x2 也会更新（在两个地方！）。该 app 还有另一个主要缺陷：频率多边形和 t-test 使用单独的随机抽取。\n这是相当误导的，因为您期望他们处理相同的基础数据。幸运的是，我们可以通过使用响应式表达式来消除重复计算来解决所有这些问题。","code":"\nx1 <- rnorm(input$n1, input$mean1, input$sd1)\nx2 <- rnorm(input$n2, input$mean2, input$sd2)\nt_test(x1, x2)"},{"path":"basic-reactivity.html","id":"simplifying-the-graph","chapter":"3 Basic reactivity","heading":"3.4.4 Simplifying the graph","text":"在下面的 server 函数中，我们重构现有代码，将重复的代码提取为两个新的响应式表达式 x1 和 x2，它们模拟来自两个分布的数据。\n为了创建响应式表达式，我们调用 reactive() 并将结果分配给一个变量。\n为了稍后使用该表达式，我们将变量称为函数。这种转换产生了 Figure 3.8 所示的更加简单的图。\n这个更简单的图使您更容易理解 app，因为您可以单独理解连接的组件；分布参数的值仅影响通过 x1 和 x2 的输出。\n这种重写还使 app 更加高效，因为它执行的计算要少得多。\n现在，当您更改 binwidth 或 range 时，只有绘图发生变化，而不是基础数据。\nFigure 3.8: 使用响应式表达式可以大大简化图，使其更容易理解\n为了强调这种模块化，Figure 3.9 在独立组件周围画了方框。\n当我们讨论模块时，我们将在 Chapter ?? 中回到这个想法。\n模块允许您提取重复的代码以供重复使用，同时保证它与 app 中的其他所有内容隔离。\n对于更复杂的 apps 来说，模块是一种非常有用且强大的技术。\nFigure 3.9: 模块强制 app 各部分之间的隔离\n您可能熟悉编程的“三规则”：每当您将某些内容复制并粘贴三次时，您应该弄清楚如何减少重复（通常通过编写函数）。\n这很重要，因为它减少了代码中的重复量，这使得代码更容易理解，并且随着需求的变化更容易更新。然而，在 Shiny 中，我认为您应该考虑一则规则：每当您复制并粘贴某些内容一次时，您应该考虑将重复的代码提取到响应式表达式中。\n该规则对于 Shiny 来说更为严格，因为响应式表达式不仅使人们更容易理解代码，还提高了 Shiny 有效重新运行代码的能力。","code":"\nserver <- function(input, output, session) {\n  x1 <- reactive(rnorm(input$n1, input$mean1, input$sd1))\n  x2 <- reactive(rnorm(input$n2, input$mean2, input$sd2))\n\n  output$hist <- renderPlot({\n    freqpoly(x1(), x2(), binwidth = input$binwidth, xlim = input$range)\n  }, res = 96)\n\n  output$ttest <- renderText({\n    t_test(x1(), x2())\n  })\n}"},{"path":"basic-reactivity.html","id":"reactive-roadblocks","chapter":"3 Basic reactivity","heading":"3.4.5 Why do we need reactive expressions?","text":"当您第一次开始使用响应式代码时，您可能想知道为什么我们需要响应式表达式。\n为什么不能使用现有的工具来减少代码重复：创建新变量和编写函数？\n不幸的是，这些技术都不能在响应式环境中工作。如果您尝试使用变量来减少重复，您可能会编写如下内容：如果运行此代码，您将收到报错，因为您正在尝试访问响应式上下文之外的输入值。\n即使您没有收到该报错，您仍然会遇到问题：x1 和 x2 只会在会话开始时计算一次，而不是每次更新其中一个输入时计算。如果您尝试使用一个函数，该 app 将运行：但它与原始代码存在相同的问题：任何输入都会导致所有输出重新计算，并且 t-test 和频数多边形将在单独的样本上运行。\n响应式表达式会自动缓存其结果，并且仅在其输入更改时更新13。虽然变量只计算一次值（粥太冷），函数每次调用时都计算值（粥太热），但响应式表达式仅在值可能发生变化时才计算值（粥正好是正确的！）。","code":"\nserver <- function(input, output, session) {\n  x1 <- rnorm(input$n1, input$mean1, input$sd1)\n  x2 <- rnorm(input$n2, input$mean2, input$sd2)\n\n  output$hist <- renderPlot({\n    freqpoly(x1, x2, binwidth = input$binwidth, xlim = input$range)\n  }, res = 96)\n\n  output$ttest <- renderText({\n    t_test(x1, x2)\n  })\n}\nserver <- function(input, output, session) { \n  x1 <- function() rnorm(input$n1, input$mean1, input$sd1)\n  x2 <- function() rnorm(input$n2, input$mean2, input$sd2)\n\n  output$hist <- renderPlot({\n    freqpoly(x1(), x2(), binwidth = input$binwidth, xlim = input$range)\n  }, res = 96)\n\n  output$ttest <- renderText({\n    t_test(x1(), x2())\n  })\n}"},{"path":"basic-reactivity.html","id":"controlling-timing-of-evaluation","chapter":"3 Basic reactivity","heading":"3.5 Controlling timing of evaluation","text":"现在您已经熟悉了响应式的基本思想，我们将讨论两种更高级的技术，这些技术允许您增加或减少响应式表达式的执行频率。\n在这里我将展示如何使用基本技术；在 Chapter ?? 中，我们将回到它们的底层实现。为了探索基本想法，我将简化我的模拟 app。\n我将使用只有一个参数的分布，并强制两个样本共享相同的 n。\n我还将删除绘图控件。\n这会产生一个更小的 UI 对象和 server 函数：这会生成如 Figure 3.10 所示的 app 和如 Figure 3.11 所示的响应式图。\nFigure 3.10: 一个更简单的 app，显示从两个泊松分布中提取的随机数的频率多边形。 See live https://hadley.shinyapps.io/ms-simulation-2.\n\nFigure 3.11: reactive graph\n","code":"\nui <- fluidPage(\n  fluidRow(\n    column(3, \n      numericInput(\"lambda1\", label = \"lambda1\", value = 3),\n      numericInput(\"lambda2\", label = \"lambda2\", value = 5),\n      numericInput(\"n\", label = \"n\", value = 1e4, min = 0)\n    ),\n    column(9, plotOutput(\"hist\"))\n  )\n)\nserver <- function(input, output, session) {\n  x1 <- reactive(rpois(input$n, input$lambda1))\n  x2 <- reactive(rpois(input$n, input$lambda2))\n  output$hist <- renderPlot({\n    freqpoly(x1(), x2(), binwidth = 1, xlim = c(0, 40))\n  }, res = 96)\n}"},{"path":"basic-reactivity.html","id":"timed-invalidation","chapter":"3 Basic reactivity","heading":"3.5.1 Timed invalidation","text":"想象一下，您想通过不断重新模拟数据来强化这是针对模拟数据的事实，以便您看到动画而不是静态图14。\n我们可以使用一个新函数来增加更新频率：reactiveTimer()。reactiveTimer() 是一个响应式表达式，它依赖于隐藏输入：当前时间。\n当您希望响应式表达式比其他方式更频繁地使自身无效时，可以使用 reactiveTimer()。\n例如，以下代码使用 500 ms 的间隔，以便绘图每秒更新两次。\n这个速度足够快，足以提醒您正在查看模拟，而不会因快速的变化而感到头晕。\n此更改产生如 Figure 3.12 所示的响应式图\nFigure 3.12: reactiveTimer(500) 引入了一种新的响应式输入，每半秒自动失效一次\n请注意我们如何在计算 x1() 和 x2() 的响应式表达式中使用 timer()：我们调用它，但不使用该值。\n这让 x1 和 x2 对 timer 产生响应式依赖，而不必担心它返回的具体值。","code":"\nserver <- function(input, output, session) {\n  timer <- reactiveTimer(500)\n  \n  x1 <- reactive({\n    timer()\n    rpois(input$n, input$lambda1)\n  })\n  x2 <- reactive({\n    timer()\n    rpois(input$n, input$lambda2)\n  })\n  \n  output$hist <- renderPlot({\n    freqpoly(x1(), x2(), binwidth = 1, xlim = c(0, 40))\n  }, res = 96)\n}"},{"path":"basic-reactivity.html","id":"on-click","chapter":"3 Basic reactivity","heading":"3.5.2 On click","text":"在上面的场景中，想一想如果模拟代码运行时间为 1 秒会发生什么。\n我们每 0.5s 执行一次模拟，因此 Shiny 要做的事情会越来越多，并且永远无法赶上。\n如果有人快速单击 app 中的按钮并且您正在进行的计算相对昂贵，也会发生同样的问题。\n有可能为 Shiny 创建大量积压工作，并且在处理积压工作时，它无法响应任何新事件。\n这会导致糟糕的用户体验。如果您的 app 中出现这种情况，您可能希望要求用户通过单击按钮来选择执行昂贵的计算。\n这是 actionButton() 的一个很好的用例：要使用 action button，我们需要学习一种新工具。\n要了解原因，我们首先使用与上述相同的方法来解决问题。\n如上所述，我们引用 simulate 时不使用其值来对其进行响应式依赖。\nFigure 3.13: App action button. See live https://hadley.shinyapps.io/ms-action-button.\n\nFigure 3.14: 这个响应式图并没有实现我们的目标；我们添加了一个依赖项，而不是替换现有的依赖项。\n这会产生 Figure 3.13 中的 app 和 Figure 3.14 中的响应式图。\n这并没有达到我们的目标，因为它只是引入了一个新的依赖项：当我们单击 simulate 按钮时，x1() 和 x2() 将更新，但当 lambda1、lambda2 或 n 更改时，它们也会继续更新。\n我们想要替换现有的依赖项，而不是添加它们。为了解决这个问题，我们需要一个新工具：一种使用输入值而不对其产生响应式依赖的方法。\n我们需要 eventReactive()，它有两个参数：第一个参数指定要依赖的内容，第二个参数指定要计算的内容。\n这使得该 app 仅在单击 simulate 时计算 x1() 和 x2()：Figure 3.15 显示了新的响应式图。\n请注意，根据需要，x1 和 x2 不再对 lambda1、lambda2 和 n 具有响应式依赖：更改它们的值将不会触发计算。\n我将箭头保留为非常浅的灰色，只是为了提醒您 x1 和 x2 继续使用这些值，但不再对它们产生响应式依赖。\nFigure 3.15: eventReactive() 可以将依赖项（黑色箭头）与用于计算结果的值（浅灰色箭头）分开。\n","code":"\nui <- fluidPage(\n  fluidRow(\n    column(3, \n      numericInput(\"lambda1\", label = \"lambda1\", value = 3),\n      numericInput(\"lambda2\", label = \"lambda2\", value = 5),\n      numericInput(\"n\", label = \"n\", value = 1e4, min = 0),\n      actionButton(\"simulate\", \"Simulate!\")\n    ),\n    column(9, plotOutput(\"hist\"))\n  )\n)\nserver <- function(input, output, session) {\n  x1 <- reactive({\n    input$simulate\n    rpois(input$n, input$lambda1)\n  })\n  x2 <- reactive({\n    input$simulate\n    rpois(input$n, input$lambda2)\n  })\n  output$hist <- renderPlot({\n    freqpoly(x1(), x2(), binwidth = 1, xlim = c(0, 40))\n  }, res = 96)\n}\nserver <- function(input, output, session) {\n  x1 <- eventReactive(input$simulate, {\n    rpois(input$n, input$lambda1)\n  })\n  x2 <- eventReactive(input$simulate, {\n    rpois(input$n, input$lambda2)\n  })\n\n  output$hist <- renderPlot({\n    freqpoly(x1(), x2(), binwidth = 1, xlim = c(0, 40))\n  }, res = 96)\n}"},{"path":"basic-reactivity.html","id":"observers","chapter":"3 Basic reactivity","heading":"3.6 Observers","text":"到目前为止，我们关注的是 app 内部发生的事情。\n但有时您需要到达 app 之外，并导致世界其他地方发生副作用。\n这可能是将文件保存到共享网络驱动器、将数据发送到 Web API、更新数据库或（最常见）将调试消息打印到控制台。\n这些操作不会影响 app 的外观，因此您不应使用输出和 render 函数。\n相反，您需要使用观察者（observer）。创建观察者的方法有多种，我们将在 Section ?? 稍后再讨论它们。\n现在，我想向您展示如何使用 observeEvent()，因为当您第一次学习 Shiny 时，它为您提供了一个重要的调试工具。observeEvent() 与 eventReactive() 非常相似。\n它有两个重要的参数：eventExpr 和 handlerExpr。\n第一个参数是要依赖的输入或表达式；第二个参数是将运行的代码。\n例如，对 server() 进行以下修改意味着每次更新 name 时，都会向控制台发送一条消息：observeEvent() 和 eventReactive() 之间有两个重要的区别：您没有将 observeEvent() 的结果分配给变量，因此你不能从其他响应式消费者那里引用它。观察者和输出密切相关。\n您可以将输出视为具有特殊的副作用：更新用户浏览器中的 HTML。\n为了强调这种接近性，我们将在响应式图中以相同的方式绘制它们。\n这会产生如 Figure 3.16 所示的响应式图。\nFigure 3.16: 在响应式图中，observer 看起来与 output 相同\n","code":"\nui <- fluidPage(\n  textInput(\"name\", \"What's your name?\"),\n  textOutput(\"greeting\")\n)\n\nserver <- function(input, output, session) {\n  string <- reactive(paste0(\"Hello \", input$name, \"!\"))\n  \n  output$greeting <- renderText(string())\n  observeEvent(input$name, {\n    message(\"Greeting performed\")\n  })\n}"},{"path":"basic-reactivity.html","id":"summary-2","chapter":"3 Basic reactivity","heading":"3.7 Summary","text":"本章应该可以提高您对 Shiny apps 后端（响应用户操作的 server() 代码）的理解。\n您还迈出了掌握支撑 Shiny 的响应式编程范例的第一步。\n你在这里学到的东西将会带你走很长的路；我们将在 Chapter ?? 中回到基本理论。\n响应式非常强大，但它与您最习惯的 R 编程的命令式风格也有很大不同。\n如果需要一段时间才能了解所有后果，请不要感到惊讶。本章总结了我们对 Shiny 基础的概述。\n下一章将通过创建一个旨在支持数据分析的更大的 Shiny app 来帮助您练习到目前为止所看到的材料。","code":""},{"path":"basic-case-study.html","id":"basic-case-study","chapter":"4 Case study: ER injuries","heading":"4 Case study: ER injuries","text":"","code":""},{"path":"basic-case-study.html","id":"introduction-3","chapter":"4 Case study: ER injuries","heading":"4.1 Introduction","text":"我在过去三章中向您介绍了许多新概念。\n因此，为了帮助他们理解，我们现在将介绍一个更丰富的 Shiny app，该 app 探索有趣的数据集并将您迄今为止看到的许多想法汇集在一起。\n我们将首先在 Shiny 之外进行一些数据分析，然后将其变成一个 app，从简单开始，然后逐步分层更多细节。在本章中，我们将用 vroom（用于快速文件读取）和 tidyverse（用于一般数据分析）来补充 Shiny。","code":"\nlibrary(shiny)\nlibrary(vroom)\nlibrary(tidyverse)"},{"path":"basic-case-study.html","id":"the-data","chapter":"4 Case study: ER injuries","heading":"4.2 The data","text":"我们将探索来自消费品安全委员会收集的国家电子伤害监控系统 (NEISS) 的数据。\n这是一项长期研究，记录了美国代表性医院样本中发生的所有事故。\n这是一个值得探索的有趣数据集，因为每个人都已经熟悉该领域，并且每次观察都附有一个简短的叙述，解释事故是如何发生的。\n您可以在 https://github.com/hadley/neiss 找到有关此数据集的更多信息。在本章中，我将只关注 2017 年的数据。\n这使数据足够小（~10 MB），以便可以轻松存储在 git 中（以及本书的其余部分），这意味着我们不需要考虑快速导入数据的复杂策略（我们将在本书后面讨论这些策略）。\n您可以在 https://github.com/hadley/mastering-shiny/blob/master/neiss/data.R 上查看我用于创建本章摘录的代码。如果您想将数据传输到您自己的计算机上，请运行以下代码：我们将使用的主要数据集是 injuries，其中包含大约 250,000 个观察值：每行代表一个具有 10 个变量的事故：trmt_date 是该人在医院就诊的日期（不是事故发生的时间）。trmt_date 是该人在医院就诊的日期（不是事故发生的时间）。age、sex 和 race 提供了有关事故发生者的人口统计信息。age、sex 和 race 提供了有关事故发生者的人口统计信息。body_part 是身体受伤的位置（例如脚踝或耳朵）；location 是事故发生的地方（如家或学校）。body_part 是身体受伤的位置（例如脚踝或耳朵）；location 是事故发生的地方（如家或学校）。diag 给出损伤的基本诊断（如骨折或撕裂）。diag 给出损伤的基本诊断（如骨折或撕裂）。prod_code 是与伤害相关的主要产品。prod_code 是与伤害相关的主要产品。weight 是统计权重，给出了如果将此数据集扩展到美国全体人口时将遭受这种伤害的估计人数。weight 是统计权重，给出了如果将此数据集扩展到美国全体人口时将遭受这种伤害的估计人数。narrative 是关于事故如何发生的简短故事。narrative 是关于事故如何发生的简短故事。我们将其与其他两个 data frames 配对以获取更多上下文：products 让我们从产品代码中查找产品名称，population 告诉我们 2017 年每种年龄和性别组合的美国总人口。","code":"\ndir.create(\"neiss\")\ndownload <- function(name) {\n  url <- \"https://github.com/hadley/mastering-shiny/blob/main/neiss/\"\n  download.file(paste0(url, name), paste0(\"neiss/\", name), quiet = TRUE)\n}\ndownload(\"injuries.tsv.gz\")\ndownload(\"population.tsv\")\ndownload(\"products.tsv\")\ninjuries <- vroom::vroom(\"neiss/injuries.tsv.gz\")\ninjuries\n#> # A tibble: 255,064 × 10\n#>   trmt_date    age sex   race  body_part   diag         location prod_code weight\n#>   <date>     <dbl> <chr> <chr> <chr>       <chr>        <chr>        <dbl>  <dbl>\n#> 1 2017-01-01    71 male  white Upper Trunk Contusion O… Other P…      1807   77.7\n#> 2 2017-01-01    16 male  white Lower Arm   Burns, Ther… Home           676   77.7\n#> 3 2017-01-01    58 male  white Upper Trunk Contusion O… Home           649   77.7\n#> 4 2017-01-01    21 male  white Lower Trunk Strain, Spr… Home          4076   77.7\n#> 5 2017-01-01    54 male  white Head        Inter Organ… Other P…      1807   77.7\n#> 6 2017-01-01    21 male  white Hand        Fracture     Home          1884   77.7\n#> # ℹ 255,058 more rows\n#> # ℹ 1 more variable: narrative <chr>\nproducts <- vroom::vroom(\"neiss/products.tsv\")\nproducts\n#> # A tibble: 38 × 2\n#>   prod_code title                            \n#>       <dbl> <chr>                            \n#> 1       464 knives, not elsewhere classified \n#> 2       474 tableware and accessories        \n#> 3       604 desks, chests, bureaus or buffets\n#> 4       611 bathtubs or showers              \n#> 5       649 toilets                          \n#> 6       676 rugs or carpets, not specified   \n#> # ℹ 32 more rows\n\npopulation <- vroom::vroom(\"neiss/population.tsv\")\npopulation\n#> # A tibble: 170 × 3\n#>     age sex    population\n#>   <dbl> <chr>       <dbl>\n#> 1     0 female    1924145\n#> 2     0 male      2015150\n#> 3     1 female    1943534\n#> 4     1 male      2031718\n#> 5     2 female    1965150\n#> 6     2 male      2056625\n#> # ℹ 164 more rows"},{"path":"basic-case-study.html","id":"exploration","chapter":"4 Case study: ER injuries","heading":"4.3 Exploration","text":"在创建 app 之前，让我们先探索一下数据。\n我们首先来看一个有有趣故事的产品：649, “toilets”。\n首先，我们将列出与该产品相关的 injuries：接下来，我们将对 toilet 相关伤害的位置、身体部位和诊断进行一些基本总结。\n请注意，我按 weight 变量进行加权，以便计数可以解释为整个美国的估计总伤害。正如您所料，涉及 toilets 的伤害最常发生在 home。\n最常见的 body parts 可能表明这些是跌倒（因为 head 和 face 通常不涉及日常厕所使用），并且诊断似乎相当多样化。我们这里有足够的数据，表格没有那么有用，所以我做了一个图，Figure 4.1，使模式更加明显。\nFigure 4.1: 按 age 和 sex 细分的估计因 toilets 造成的伤害人数\n我们看到年轻男孩的数量在 3 岁时达到顶峰，然后从中年左右开始增加（尤其是女性），并在 80 岁之后逐渐下降。\n我怀疑这个峰值是因为男孩通常是站着上厕所的，而女性的增加是由于骨质疏松症（即我怀疑女性和男性受伤的比例相同，但更多的女性最终进入急诊室，因为她们骨折的风险更高）。解释这一模式的一个问题是，我们知道老年人比年轻人少，因此可能受伤的人口也较少。\n我们可以通过比较受伤人数与总人口并计算受伤率来控制这一点。\n这里我使用的是每 10,000 人的比率。绘制该比率，Figure 4.2，可以得出 50 岁之后的明显不同趋势：男性和女性之间的差异要小得多，而且我们不再看到下降。\n这是因为女性往往比男性寿命更长，因此，随着年龄的增长，有更多的女性会因厕所而受伤。\nFigure 4.2: 按 age 和 sex 细分的每 10,000 人估计受伤率\n（请注意，该比率仅上升到 80 岁，因为我找不到 80 岁以上的人口数据。）最后，我们可以看看一些叙述。\n浏览这些内容是一种非正式的方式来检查我们的假设，并产生新的想法以供进一步探索。\n这里我随机抽取了 10 个样本：在对一个产品进行了这种探索之后，如果我们可以轻松地对其他产品进行此探索，而无需重新输入代码，那就太好了。\n那么让我们制作一个 Shiny app 吧！","code":"\nselected <- injuries %>% filter(prod_code == 649)\nnrow(selected)\n#> [1] 2993\nselected %>% count(location, wt = weight, sort = TRUE)\n#> # A tibble: 6 × 2\n#>   location                         n\n#>   <chr>                        <dbl>\n#> 1 Home                       99603. \n#> 2 Other Public Property      18663. \n#> 3 Unknown                    16267. \n#> 4 School                       659. \n#> 5 Street Or Highway             16.2\n#> 6 Sports Or Recreation Place    14.8\n\nselected %>% count(body_part, wt = weight, sort = TRUE)\n#> # A tibble: 24 × 2\n#>   body_part        n\n#>   <chr>        <dbl>\n#> 1 Head        31370.\n#> 2 Lower Trunk 26855.\n#> 3 Face        13016.\n#> 4 Upper Trunk 12508.\n#> 5 Knee         6968.\n#> 6 N.S./Unk     6741.\n#> # ℹ 18 more rows\n\nselected %>% count(diag, wt = weight, sort = TRUE)\n#> # A tibble: 20 × 2\n#>   diag                       n\n#>   <chr>                  <dbl>\n#> 1 Other Or Not Stated   32897.\n#> 2 Contusion Or Abrasion 22493.\n#> 3 Inter Organ Injury    21525.\n#> 4 Fracture              21497.\n#> 5 Laceration            18734.\n#> 6 Strain, Sprain         7609.\n#> # ℹ 14 more rows\nsummary <- selected %>% \n  count(age, sex, wt = weight)\nsummary\n#> # A tibble: 208 × 3\n#>     age sex         n\n#>   <dbl> <chr>   <dbl>\n#> 1     0 female   4.76\n#> 2     0 male    14.3 \n#> 3     1 female 253.  \n#> 4     1 male   231.  \n#> 5     2 female 438.  \n#> 6     2 male   632.  \n#> # ℹ 202 more rows\n\nsummary %>% \n  ggplot(aes(age, n, colour = sex)) + \n  geom_line() + \n  labs(y = \"Estimated number of injuries\")\nsummary <- selected %>% \n  count(age, sex, wt = weight) %>% \n  left_join(population, by = c(\"age\", \"sex\")) %>% \n  mutate(rate = n / population * 1e4)\n\nsummary\n#> # A tibble: 208 × 5\n#>     age sex         n population   rate\n#>   <dbl> <chr>   <dbl>      <dbl>  <dbl>\n#> 1     0 female   4.76    1924145 0.0247\n#> 2     0 male    14.3     2015150 0.0708\n#> 3     1 female 253.      1943534 1.30  \n#> 4     1 male   231.      2031718 1.14  \n#> 5     2 female 438.      1965150 2.23  \n#> 6     2 male   632.      2056625 3.07  \n#> # ℹ 202 more rows\nsummary %>% \n  ggplot(aes(age, rate, colour = sex)) + \n  geom_line(na.rm = TRUE) + \n  labs(y = \"Injuries per 10,000 people\")\nselected %>% \n  sample_n(10) %>% \n  pull(narrative)\n#>  [1] \"LUMBAR STR.  19YOM STRAINED LOWER BACK GETTING UP FROM TOILET AT HOME.\"                                                                \n#>  [2] \"77 YO M PT LOST HIS BALANCE FELL OFF THE TOILET ONTO FLOOR HITTING HEADDX CHI\"                                                         \n#>  [3] \"76 YO M C/O TOE INJURY S/P TRIP AND FALL AND HIT TOE ON BOTTOM OF TOILET DX CLOSED NONDISPLACED FX DISTAL PHALANX LEFT GREAT TOE, FALL\"\n#>  [4] \"93YOM WAS TRANSFERRING OFF THE TOILET AT THE NURSING HOME AND LANDED ONTO HEAD CLOSED HEAD INJURY\"                                     \n#>  [5] \"7YOF LAC CHIN- FELL OFF TOILET, STRUCK TUB\"                                                                                            \n#>  [6] \"25 YOM  CUT FINGER ON BROKEN TOILET.DX:  FINGER LAC 3 CM.\"                                                                             \n#>  [7] \"17 YO F C/O LT BACK PAIN BEGAN AFTER GETTING UP FROM SEATED POSITION ONTOILET DX PROBABLY MUSCLE PAIN\"                                 \n#>  [8] \"18 YOM WAS URINATING, PASSED OUT, STRUCK HEAD ON TOILET. NO TRAUMATIC INJURY NOTED. DX VASOVAGAL SYNCOPE\"                              \n#>  [9] \"SCROTUM HEMATOMA.  87YOM FELL AGAINST TOILET BOWL AT HOME.\"                                                                            \n#> [10] \"69YOF GETTING ON HER TOILET AND MISSED IT HIT HEAD ON THE FLOOR CLOSEDHEAD INJURY\""},{"path":"basic-case-study.html","id":"prototype","chapter":"4 Case study: ER injuries","heading":"4.4 Prototype","text":"在构建复杂的 app 时，我强烈建议从尽可能简单的开始，以便您可以在开始做更复杂的事情之前确认基本机制的工作。\n在这里，我将从一个 input（product code）、三个 tables 和一个 plot 开始。在设计第一个原型时，挑战在于使其“尽可能简单”。\n快速掌握基础知识和规划 app 的未来之间存在着紧张关系。\n任何一个极端都可能是糟糕的：如果你的设计范围太窄，你以后会花很多时间来重新设计你的 app；如果你设计得太严格，你就会花大量时间编写代码，而这些代码最终会被砍掉。\n为了帮助实现正确的平衡，我经常在提交代码之前画一些纸笔草图来快速探索 UI 和响应式图。在这里，我决定为 inputs 设置一行（接受在完成此 app 之前我可能会添加更多输入），为所有三个 tables 设置一行（为每个 table 提供 4 columns，12 column 宽度的 1/3），然后为 plot 设置一行：我们还没有讨论过 fluidRow() 和 column()，但是你应该能够从上下文中猜出它们的作用，我们将在 Section ?? 中回来讨论它们。\n另请注意 selectInput() choices 中 setNames() 的使用：这会在 UI 中显示产品名称并将产品代码返回到 server。server 函数相对简单。\n我首先将上一节中创建的 selected 变量和 summary 变量转换为响应式表达式。\n这是一个合理的一般模式：您在数据分析中创建变量以将分析分解为步骤，并避免多次重新计算，并且响应式表达式在 Shiny apps 中发挥相同的作用。通常，在启动 Shiny app 之前花一点时间清理分析代码是个好主意，这样您就可以在添加额外的响应式复杂性之前在常规 R 代码中考虑这些问题。请注意，创建响应式 summary 在这里并不是绝对必要的，因为它仅由单个响应式使用者使用。\n但最好将计算和绘图分开，因为这样可以使 app 的流程更容易理解，并且在将来更容易推广。生成的 app 的屏幕截图如 Figure 4.3 所示。\n您可以在 https://github.com/hadley/mastering-shiny/tree/main/neiss/prototype.R 找到源代码，并在 https://hadley.shinyapps.io/ms-prototype/ 尝试该 app 的实时版本。\nFigure 4.3: NEISS 探索 app 的第一个原型\n","code":"\nprod_codes <- setNames(products$prod_code, products$title)\n\nui <- fluidPage(\n  fluidRow(\n    column(6,\n      selectInput(\"code\", \"Product\", choices = prod_codes)\n    )\n  ),\n  fluidRow(\n    column(4, tableOutput(\"diag\")),\n    column(4, tableOutput(\"body_part\")),\n    column(4, tableOutput(\"location\"))\n  ),\n  fluidRow(\n    column(12, plotOutput(\"age_sex\"))\n  )\n)\nserver <- function(input, output, session) {\n  selected <- reactive(injuries %>% filter(prod_code == input$code))\n\n  output$diag <- renderTable(\n    selected() %>% count(diag, wt = weight, sort = TRUE)\n  )\n  output$body_part <- renderTable(\n    selected() %>% count(body_part, wt = weight, sort = TRUE)\n  )\n  output$location <- renderTable(\n    selected() %>% count(location, wt = weight, sort = TRUE)\n  )\n\n  summary <- reactive({\n    selected() %>%\n      count(age, sex, wt = weight) %>%\n      left_join(population, by = c(\"age\", \"sex\")) %>%\n      mutate(rate = n / population * 1e4)\n  })\n\n  output$age_sex <- renderPlot({\n    summary() %>%\n      ggplot(aes(age, n, colour = sex)) +\n      geom_line() +\n      labs(y = \"Estimated number of injuries\")\n  }, res = 96)\n}"},{"path":"basic-case-study.html","id":"polish-tables","chapter":"4 Case study: ER injuries","heading":"4.5 Polish tables","text":"现在我们已经具备了基本组件并可以运行，我们可以逐步改进我们的 app。\n这个 app 的第一个问题是它在表格中显示了大量信息，而我们可能只需要突出显示。\n为了解决这个问题，我们需要首先弄清楚如何截断表。\n我选择使用 forcats 函数的组合来实现这一点：我将变量转换为一个 factor，按 levels 的频率排序，然后将前 5 个级别之后的所有 levels 集中在一起。因为我知道如何做到这一点，所以我编写了一个小函数来自动处理任何变量。\n细节在这里并不重要，但我们将在 Chapter ?? 中再次讨论它们。\n您还可以通过复制和粘贴来解决问题，因此不必担心代码看起来完全陌生。然后我在 server 函数中使用它：我做了另一项更改来提高 app 的美观性：我强制所有表格占据最大宽度（即填充它们出现的列）。\n这使得输出更加美观，因为它减少了附带变化的量。生成的 app 的屏幕截图如 Figure 4.4 所示。\n您可以在 https://github.com/hadley/mastering-shiny/tree/main/neiss/polish-tables.R 找到源代码，并在 https://hadley.shinyapps.io/ms-polish-tables 尝试该 app 的实时版本。\nFigure 4.4: app 的第二次迭代通过仅显示汇总表中最常见的行来改进显示\n","code":"\ninjuries %>%\n  mutate(diag = fct_lump(fct_infreq(diag), n = 5)) %>%\n  group_by(diag) %>%\n  summarise(n = as.integer(sum(weight)))\n#> # A tibble: 6 × 2\n#>   diag                        n\n#>   <fct>                   <int>\n#> 1 Other Or Not Stated   1806436\n#> 2 Fracture              1558961\n#> 3 Laceration            1432407\n#> 4 Strain, Sprain        1432556\n#> 5 Contusion Or Abrasion 1451987\n#> 6 Other                 1929147\ncount_top <- function(df, var, n = 5) {\n  df %>%\n    mutate({{ var }} := fct_lump(fct_infreq({{ var }}), n = n)) %>%\n    group_by({{ var }}) %>%\n    summarise(n = as.integer(sum(weight)))\n}\n  output$diag <- renderTable(count_top(selected(), diag), width = \"100%\")\n  output$body_part <- renderTable(count_top(selected(), body_part), width = \"100%\")\n  output$location <- renderTable(count_top(selected(), location), width = \"100%\")"},{"path":"basic-case-study.html","id":"rate-vs-count","chapter":"4 Case study: ER injuries","heading":"4.6 Rate vs count","text":"到目前为止，我们只显示了一个图，但我们希望用户可以选择是可视化受伤人数还是人口标准化率。\n首先，我向 UI 添加一个控件。\n这里我选择使用 selectInput() 因为它使两种状态都明确，并且将来添加新状态会很容易：（我默认为 rate，因为我认为这样更安全；您不需要了解人口分布即可正确解释该图。）然后我在生成绘图时以该输入为条件：生成的 app 的屏幕截图如 Figure 4.5 所示。\n您可以在 https://github.com/hadley/mastering-shiny/tree/main/neiss/rate-vs-count.R 找到源代码，并在 https://hadley.shinyapps.io/ms-rate-vs-count 上尝试该 app 的实时版本。\nFigure 4.5: 在此迭代中，我们使用户能够在 y 轴上显示计数或人口标准化率之间进行切换。\n","code":"  fluidRow(\n    column(8,\n      selectInput(\"code\", \"Product\",\n        choices = setNames(products$prod_code, products$title),\n        width = \"100%\"\n      )\n    ),\n    column(2, selectInput(\"y\", \"Y axis\", c(\"rate\", \"count\")))\n  ),\n  output$age_sex <- renderPlot({\n    if (input$y == \"count\") {\n      summary() %>%\n        ggplot(aes(age, n, colour = sex)) +\n        geom_line() +\n        labs(y = \"Estimated number of injuries\")\n    } else {\n      summary() %>%\n        ggplot(aes(age, rate, colour = sex)) +\n        geom_line(na.rm = TRUE) +\n        labs(y = \"Injuries per 10,000 people\")\n    }\n  }, res = 96)"},{"path":"basic-case-study.html","id":"narrative","chapter":"4 Case study: ER injuries","heading":"4.7 Narrative","text":"最后，我想提供一些访问叙述的方式，因为它们非常有趣，并且它们提供了一种非正式的方式来交叉检查您在查看绘图时提出的假设。\n在 R 代码中，我一次采样多个叙述，但没有理由在可以交互式探索的 app 中这样做。解决方案有两个部分。\n首先，我们在 UI 底部添加一个新行。\n我使用 action button 触发新故事，并将叙述放入 textOutput() 中：然后，我使用 eventReactive() 创建一个响应，仅在单击按钮或底层数据更改时更新。生成的 app 的屏幕截图如 Figure 4.6 所示。\n您可以在 https://github.com/hadley/mastering-shiny/tree/main/neiss/narrative.R 找到源代码，并在 https://hadley.shinyapps.io/ms-narrative 尝试该 app 的实时版本。\nFigure 4.6: 最终迭代增加了从所选行中提取随机叙述的能力\n","code":"\n  fluidRow(\n    column(2, actionButton(\"story\", \"Tell me a story\")),\n    column(10, textOutput(\"narrative\"))\n  )\n  narrative_sample <- eventReactive(\n    list(input$story, selected()),\n    selected() %>% pull(narrative) %>% sample(1)\n  )\n  output$narrative <- renderText(narrative_sample())"},{"path":"basic-case-study.html","id":"exercises-4","chapter":"4 Case study: ER injuries","heading":"4.8 Exercises","text":"绘制每个 app 的响应式图。绘制每个 app 的响应式图。如果在减少汇总表格的代码中翻转 fct_infreq() 和 fct_lump() 会发生什么？如果在减少汇总表格的代码中翻转 fct_infreq() 和 fct_lump() 会发生什么？添加一个输入控件，让用户决定在汇总表中显示多少行。添加一个输入控件，让用户决定在汇总表中显示多少行。提供一种通过前进和后退按钮系统地逐步浏览每个叙述的方法。\nAdvanced：将叙述列表设为 “circular”，以便从最后一个叙述前进到第一个叙述。提供一种通过前进和后退按钮系统地逐步浏览每个叙述的方法。Advanced：将叙述列表设为 “circular”，以便从最后一个叙述前进到第一个叙述。","code":""},{"path":"basic-case-study.html","id":"summary-3","chapter":"4 Case study: ER injuries","heading":"4.9 Summary","text":"现在您已经掌握了 Shiny apps 的基础知识，接下来的七章将为您提供重要的技术。\n一旦您阅读了有关工作流程的下一章，我建议您浏览一下剩余的章节，以便您更好地了解它们所涵盖的内容，然后在您需要 app 的技术时再重新开始。","code":""},{"path":"action-intro.html","id":"action-intro","chapter":"Introduction","heading":"Introduction","text":"以下章节为您提供了一系列有用的技术。\n我认为每个人都应该从 Chapter ?? 开始，因为它为您提供了开发和调试 apps 的重要工具，并在遇到困难时获得帮助。之后，没有规定的顺序，各章之间的联系也相对较少：我建议快速浏览以了解总体情况（因此，如果将来出现相关问题，您可能会记住这些工具），否则只能深入了解读取您当前需要的位。\n以下是主要主题的快速概述：Chapter ?? 详细介绍了在页面上布局输入和输出组件的各种方法，以及如何使用主题自定义它们的外观。Chapter ?? 详细介绍了在页面上布局输入和输出组件的各种方法，以及如何使用主题自定义它们的外观。Chapter ?? 向您展示如何向绘图添加直接交互以及如何显示以其他方式生成的图像。Chapter ?? 向您展示如何向绘图添加直接交互以及如何显示以其他方式生成的图像。Chapter ?? 介绍了一系列技术（包括内联错误、通知、进度条和对话框），用于在 app 运行时向用户提供反馈。Chapter ?? 介绍了一系列技术（包括内联错误、通知、进度条和对话框），用于在 app 运行时向用户提供反馈。Chapter ?? 讨论如何在 app 之间传输文件。Chapter ?? 讨论如何在 app 之间传输文件。Chapter 6 向您展示如何在 apps 运行时动态修改 apps 用户界面。Chapter 6 向您展示如何在 apps 运行时动态修改 apps 用户界面。Chapter ?? 展示了如何以用户可以为其添加书签的方式记录 app 状态。Chapter ?? 展示了如何以用户可以为其添加书签的方式记录 app 状态。Chapter ?? 向您展示如何允许用户在使用 tidyverse 包时选择变量。Chapter ?? 向您展示如何允许用户在使用 tidyverse 包时选择变量。让我们从开发 apps 的工作流程开始。","code":""},{"path":"action-workflow.html","id":"action-workflow","chapter":"5 Workflow","heading":"5 Workflow","text":"如果您要编写大量 Shiny apps（既然您正在阅读这本书，我希望您会这么做！），那么在基本工作流程上投入一些时间是值得的。\n改进工作流程是投入时间的好地方，因为从长远来看，它往往会带来巨大的回报。\n它不仅增加了您编写 R 代码所花费的时间比例，而且因为您更快地看到结果，它使编写 Shiny apps 的过程变得更加愉快，并帮助您更快地提高技能。本章的目标是帮助您改进三个重要的 Shiny 工作流程：创建 apps、进行更改和试验结果的基本开发周期。创建 apps、进行更改和试验结果的基本开发周期。调试，在这个工作流程中，您找出代码出了什么问题，然后集体讨论解决方案来修复它。调试，在这个工作流程中，您找出代码出了什么问题，然后集体讨论解决方案来修复它。编写 reprexes，即说明问题的独立代码块。\nReprexes 是一种强大的调试技术，如果您想从其他人那里获得帮助，它们是必不可少的。编写 reprexes，即说明问题的独立代码块。\nReprexes 是一种强大的调试技术，如果您想从其他人那里获得帮助，它们是必不可少的。","code":""},{"path":"action-workflow.html","id":"development-workflow","chapter":"5 Workflow","heading":"5.1 Development workflow","text":"优化开发工作流程的目标是缩短做出更改和看到结果之间的时间。\n你迭代的速度越快，你的实验速度就越快，你就能越快地成为一名更好的 Shiny 开发人员。\n这里有两个主要的工作流程需要优化：首次创建 app，以及加快调整代码和尝试结果的迭代周期。","code":""},{"path":"action-workflow.html","id":"creating-the-app","chapter":"5 Workflow","heading":"5.1.1 Creating the app","text":"您将使用相同的六行 R 代码启动每个 app：您可能很快就会厌倦输入这些代码，因此 RStudio 提供了一些快捷方式：如果您已经打开了未来的 app.R，请输入 shinyapp，然后按 Shift + Tab 插入 Shiny app 片段。15如果您已经打开了未来的 app.R，请输入 shinyapp，然后按 Shift + Tab 插入 Shiny app 片段。15如果您想启动一个新项目16，请进入 File 菜单，选择 “New Project”，然后选择 “Shiny Web Application”，如 Figure 5.1 所示。如果您想启动一个新项目16，请进入 File 菜单，选择 “New Project”，然后选择 “Shiny Web Application”，如 Figure 5.1 所示。\nFigure 5.1: 要在 RStudio 中创建新的 Shiny app，请选择 ‘Shiny Web Application’ 作为项目类型\n您可能认为学习这些快捷方式不值得，因为您每天只会创建一两个 app，但是创建简单的 app 是在开始更大的项目之前检查您是否掌握了基本概念的好方法，并且它们是一个很棒的调试工具。","code":"\nlibrary(shiny)\nui <- fluidPage(\n)\nserver <- function(input, output, session) {\n}\nshinyApp(ui, server)"},{"path":"action-workflow.html","id":"seeing-your-changes","chapter":"5 Workflow","heading":"5.1.2 Seeing your changes","text":"最多，您一天会创建几个 apps，但您会运行 apps 数百次，因此掌握开发工作流程尤为重要。\n减少迭代时间的第一个方法是避免单击 “Run App” 按钮，而是学习键盘快捷键 Cmd/Ctrl + Shift + Enter。\n这将为您提供以下开发工作流程：写一些代码。使用 Cmd/Ctrl + Shift + Enter 启动 app。使用该 app 进行交互式实验。关闭 app。回到 1。进一步提高迭代速度的另一种方法是打开自动重新加载并在后台作业中运行 app，如 https://github.com/sol-eng/background-jobs/tree/master/shiny-job 中所述。\n通过此工作流程，只要您保存文件，您的 app 就会重新启动：无需关闭并重新启动。\n这会带来更快的工作流程：编写一些代码并按 Cmd/Ctrl + S 保存文件。交互式实验。回到 1。这种技术的主要缺点是调试起来相当困难，因为 app 在单独的进程中运行。随着您的 app 变得越来越大，您会发现“交互式实验”步骤开始变得繁重。\n记住重新检查 app 中可能受到更改影响的每个组件太困难了。\n稍后，在 Chapter ?? 中，您将学习自动化测试工具，它允许您将正在运行的交互式实验转换为自动化代码。\n这可以让您更快地运行测试（因为它们是自动化的），并且意味着您不会忘记运行重要的测试。\n开发测试需要一些初始投资，但对于大型 apps 来说，投资回报丰厚。","code":""},{"path":"action-workflow.html","id":"controlling-the-view","chapter":"5 Workflow","heading":"5.1.3 Controlling the view","text":"默认情况下，当您运行 app 时，它将显示在弹出窗口中。\n您可以从 Run App 下拉列表中选择其他两个选项，如 Figure 1.1 所示：Run Viewer Pane 会在 viewer 窗格（通常位于 IDE 的右侧）中打开 app。\n它对于较小的 apps 很有用，因为您可以在运行 app 代码的同时看到它。Run Viewer Pane 会在 viewer 窗格（通常位于 IDE 的右侧）中打开 app。\n它对于较小的 apps 很有用，因为您可以在运行 app 代码的同时看到它。Run External 在您常用的网络浏览器中打开 app。\n它对于较大的 apps 以及当您想查看 app 在大多数用户将体验的环境的外观时非常有用。Run External 在您常用的网络浏览器中打开 app。\n它对于较大的 apps 以及当您想查看 app 在大多数用户将体验的环境的外观时非常有用。\nFigure 1.1: Run App 按钮允许您选择如何显示正在运行的 app。\n","code":""},{"path":"action-workflow.html","id":"debugging","chapter":"5 Workflow","heading":"5.2 Debugging","text":"当你开始编写 apps 时，几乎肯定会出现问题。\n大多数错误的原因是您对 Shiny 的心理模型与 Shiny 实际所做的事情不匹配。\n当你阅读这本书时，你的心理模型将会得到改善，从而减少你犯的错误，当你犯错误时，你会更容易发现问题。\n然而，在您能够可靠地编写首次运行的代码之前，您需要拥有多年使用任何语言的经验。\n这意味着您需要开发一个强大的工作流程来识别和修复错误。\n在这里，我们将重点关注 Shiny apps 特有的挑战；如果您不熟悉 R 调试，请从 Jenny Bryan 的 rstudio::conf(2020) 主题演讲 “Object type ‘closure’ subsettable” 开始。我们将在下面讨论三种主要的问题情况：您收到意外报错。\n这是最简单的情况，因为您将获得回溯，使您能够准确地找出错误发生的位置。\n一旦发现问题，您就需要系统地测试您的假设，直到发现您的期望与现实之间的差异。\n交互式调试器是这个过程的有力助手。您收到意外报错。\n这是最简单的情况，因为您将获得回溯，使您能够准确地找出错误发生的位置。\n一旦发现问题，您就需要系统地测试您的假设，直到发现您的期望与现实之间的差异。\n交互式调试器是这个过程的有力助手。您没有收到任何报错，但某些值不正确。\n在这里，您需要使用交互式调试器以及您的调查技能来追踪根本原因。您没有收到任何报错，但某些值不正确。\n在这里，您需要使用交互式调试器以及您的调查技能来追踪根本原因。所有值都是正确的，但它们没有按您的预期更新。\n这是最具挑战性的问题，因为它是 Shiny 所独有的，因此您无法利用现有的 R 调试技能。所有值都是正确的，但它们没有按您的预期更新。\n这是最具挑战性的问题，因为它是 Shiny 所独有的，因此您无法利用现有的 R 调试技能。出现这些情况时会令人沮丧，但您可以将其转化为练习调试技能的机会。在下一节中，我们将回到另一个重要的技术，制作一个最小的可重复示例。\n如果您遇到困难并需要从其他人那里获得帮助，那么创建一个最小的示例至关重要。\n但是，在调试自己的代码时，创建一个最小的示例也是一项非常重要的技能。\n通常情况下，您有很多代码可以正常工作，而只有极少量的代码会导致问题。\n如果您可以通过删除有效的代码来缩小有问题的代码范围，那么您将能够更快地迭代解决方案。\n这是我每天都使用的技巧。","code":""},{"path":"action-workflow.html","id":"reading-tracebacks","chapter":"5 Workflow","heading":"5.2.1 Reading tracebacks","text":"在 R 中，每个错误都伴随着回溯或调用堆栈，它实际上可以追溯到导致错误的调用序列。\n例如，采用以下简单的调用序列：f() 调用 g() 调用 h()，后者调用乘法运算符：如果这段代码出错，如下：您可以调用 traceback() 来查找问题的调用顺序：我认为将回溯颠倒过来是最容易理解的：现在，这会告诉您导致错误的调用顺序 — f() 调用 g() 调用 h() （哪些错误）。","code":"\nf <- function(x) g(x)\ng <- function(x) h(x)\nh <- function(x) x * 2\nf(\"a\")\n#> Error in x * 2: non-numeric argument to binary operator\ntraceback()\n#> 3: h(x)\n#> 2: g(x)\n#> 1: f(\"a\")1: f(\"a\")\n2: g(x)\n3: h(x)"},{"path":"action-workflow.html","id":"tracebacks-in-shiny","chapter":"5 Workflow","heading":"5.2.2 Tracebacks in Shiny","text":"不幸的是，您无法在 Shiny 中使用 traceback()，因为您无法在 app 运行时运行代码。\n相反，Shiny 会自动为您打印回溯。\n例如，使用我上面定义的 f() 函数来获取这个简单的 app：如果您运行此 app，您将在 app 中看到一条错误消息，并在控制台中看到一条回溯：为了了解发生了什么，我们再次将其颠倒过来，这样您就可以按照调用的出现顺序查看调用顺序：调用堆栈由三个基本部分组成：前几次调用会启动 app。在这种情况下，您只会看到 runApp()，但根据您启动 app 的方式，您可能会看到更复杂的内容。\n例如，如果您调用 source() 来运行 app，您可能会看到以下内容：\n1: source\n3: print.shiny.appobj\n5: runApp\n一般来说，您可以忽略第一个 runApp(); 之前的任何内容；这只是让 app 运行的设置代码。前几次调用会启动 app。在这种情况下，您只会看到 runApp()，但根据您启动 app 的方式，您可能会看到更复杂的内容。\n例如，如果您调用 source() 来运行 app，您可能会看到以下内容：一般来说，您可以忽略第一个 runApp(); 之前的任何内容；这只是让 app 运行的设置代码。接下来，您将看到一些负责调用响应式表达式的内部 Shiny 代码：\n 81: output$plot\n 82: renderFunc\n 95: drawReactive\n111: <reactive:plotObj>\n125: drawPlot\n165: func\n在这里，发现 output$plot 非常重要 — 它可以告诉您哪个响应式（plot）导致了错误。\n接下来的几个函数是内部函数，您可以忽略它们。接下来，您将看到一些负责调用响应式表达式的内部 Shiny 代码：在这里，发现 output$plot 非常重要 — 它可以告诉您哪个响应式（plot）导致了错误。\n接下来的几个函数是内部函数，您可以忽略它们。最后，在最底部，您将看到您编写的代码：\n167: renderPlot [app.R#13]\n168: f [app.R#3]\n169: g [app.R#4]\n这是 renderPlot() 内部调用的代码。\n由于文件路径和行号，您可以告诉您应该注意这里；这让您知道这是您的代码。最后，在最底部，您将看到您编写的代码：这是 renderPlot() 内部调用的代码。\n由于文件路径和行号，您可以告诉您应该注意这里；这让您知道这是您的代码。如果您的 app 出现错误，但没有看到回溯，请确保您正在使用 Cmd/Ctrl + Shift + Enter 运行 app（或者如果不在 RStudio 中，则调用 runApp()），并且您已经保存了您运行它的文件。\n运行 app 的其他方式并不总能捕获进行回溯所需的信息。","code":"\nlibrary(shiny)\n\nf <- function(x) g(x)\ng <- function(x) h(x)\nh <- function(x) x * 2\n\nui <- fluidPage(\n  selectInput(\"n\", \"N\", 1:10),\n  plotOutput(\"plot\")\n)\nserver <- function(input, output, session) {\n  output$plot <- renderPlot({\n    n <- f(input$n)\n    plot(head(cars, n))\n  }, res = 96)\n}\nshinyApp(ui, server)Error in *: non-numeric argument to binary operator\n  169: g [app.R#4]\n  168: f [app.R#3]\n  167: renderPlot [app.R#13]\n  165: func\n  125: drawPlot\n  111: <reactive:plotObj>\n   95: drawReactive\n   82: renderFunc\n   81: output$plot\n    1: runAppError in *: non-numeric argument to binary operator\n   1: runApp\n  81: output$plot\n  82: renderFunc\n  95: drawReactive\n 111: <reactive:plotObj>\n 125: drawPlot\n 165: func\n 167: renderPlot [app.R#13]\n 168: f [app.R#3]\n 169: g [app.R#4]1: source\n3: print.shiny.appobj\n5: runApp 81: output$plot\n 82: renderFunc\n 95: drawReactive\n111: <reactive:plotObj>\n125: drawPlot\n165: func167: renderPlot [app.R#13]\n168: f [app.R#3]\n169: g [app.R#4]"},{"path":"action-workflow.html","id":"browser","chapter":"5 Workflow","heading":"5.2.3 The interactive debugger","text":"一旦找到错误的根源并想找出导致错误的原因，您可以使用的最强大的工具就是交互式调试器。\n调试器会暂停执行，并为您提供一个交互式 R 控制台，您可以在其中运行任何代码来找出问题所在。\n有两种启动调试器的方法：在源代码中添加对 browser() 的调用。\n这是启动交互式调试器的标准 R 方式，无论您如何运行 Shiny，它都可以工作。\nbrowser() 的另一个优点是，因为它是 R 代码，所以您可以通过将其与 语句组合来使其成为条件。\n这允许您仅针对有问题的输入启动调试器。\n\n(input$value == \"\") {\n  browser()\n}\n# maybe\n(my_reactive() < 0) {\n  browser()\n}在源代码中添加对 browser() 的调用。\n这是启动交互式调试器的标准 R 方式，无论您如何运行 Shiny，它都可以工作。browser() 的另一个优点是，因为它是 R 代码，所以您可以通过将其与 语句组合来使其成为条件。\n这允许您仅针对有问题的输入启动调试器。单击行号左侧添加 RStudio 断点。\n您可以通过单击红色圆圈来删除断点。\n\n断点的优点是它们不是代码，因此您永远不必担心意外地将它们签入版本控制系统。单击行号左侧添加 RStudio 断点。\n您可以通过单击红色圆圈来删除断点。断点的优点是它们不是代码，因此您永远不必担心意外地将它们签入版本控制系统。如果您使用 RStudio，当您处于调试器中时，Figure 5.2 中的工具栏将出现在控制台顶部。\n工具栏是记住现在可用的调试命令的简单方法。\n它们也可以在 RStudio 之外使用；您只需要记住一个字母命令即可激活它们。\n三个最有用的命令是：下一步（按 n）：执行函数中的下一步。\n请注意，如果您有一个名为 n 的变量，则需要使用 print(n) 来显示其值。下一步（按 n）：执行函数中的下一步。\n请注意，如果您有一个名为 n 的变量，则需要使用 print(n) 来显示其值。继续（按 c）：离开交互式调试并继续函数的常规执行。\n如果您已经修复了错误状态并想要检查函数是否正常运行，这非常有用。继续（按 c）：离开交互式调试并继续函数的常规执行。\n如果您已经修复了错误状态并想要检查函数是否正常运行，这非常有用。停止（按 Q）：停止调试，终止函数，并返回全局工作区。\n一旦找出问题所在，并准备好修复它并重新加载代码，就可以使用它。停止（按 Q）：停止调试，终止函数，并返回全局工作区。\n一旦找出问题所在，并准备好修复它并重新加载代码，就可以使用它。\nFigure 5.2: RStudio’s debugging toolbar\n除了使用这些工具逐行执行代码之外，您还将编写并运行一堆交互式代码来跟踪出了什么问题。\n调试是系统地将您的期望与现实进行比较，直到发现不匹配的过程。\n如果您不熟悉 R 调试，您可能需要阅读 “Advanced R” 的 Debugging chapter 来学习一些通用技术。","code":"\nif (input$value == \"a\") {\n  browser()\n}\n# Or maybe\nif (my_reactive() < 0) {\n  browser()\n}"},{"path":"action-workflow.html","id":"case-study","chapter":"5 Workflow","heading":"5.2.4 Case study","text":"eliminate impossible, whatever remains, matter improbable, must truth — Sherlock Holmes为了演示基本的调试方法，我将向您展示我在编写 Section 6.1.2 时遇到的一个小问题。\n我将首先向您展示基本情景，然后您会看到一个我没有使用交互式调试工具解决的问题，一个需要交互式调试的问题，并发现最后的惊喜。最初的目标非常简单：我有一个销售数据集，我想按地区过滤它。\n数据如下：以下是 territories：当我第一次开始解决这个问题时，我认为它很简单，我可以编写 app 而无需进行任何其他研究：我想，这是一个八行 app，可能会出什么问题吗？好吧，当我打开 app 时，我看到很多缺失值，无论我选择哪个区域。\n最有可能成为问题根源的代码是选择要显示的数据的响应式：sales[sales$TERRITORY == input$territory, ]。\n因此，我停止了该 app，并快速验证了子集化是否按照我想象的方式工作：哎呀！我忘记了 TERRITORY 包含一堆缺失值，这意味着 sales$TERRITORY == \"EMEA\" 将包含一堆缺失值：当我使用 [ 对 sales data frame 进行子集化时，这些缺失值将成为缺失行；输入中的任何缺失值都将保留在输出中。\n有很多方法可以解决这个问题，但我决定使用 subset()17，因为会自动删除缺失值并减少我需要输入 sales 的次数。然后我仔细检查了这是否确实有效：这解决了大部分问题，但当我在区域下拉列表中选择 NA 时仍然遇到问题：仍然没有出现行。\n于是，我再次检查控制台：然后我想起这当然行不通，因为缺失值具有传染性：您可以使用另一个技巧来解决此问题：从 == 切换到 %%：所以我更新了 app 并再次尝试。\n还是没成功！\n当我在下拉列表中选择 “NA” 时，我没有看到任何行。此时，我想我已经在控制台上做了我能做的一切，我需要进行一个实验来找出为什么 Shiny 内部的代码没有按照我预期的方式工作。\n我猜测问题最有可能的根源在于所选的响应式，因此我在那里添加了一个 browser() 语句。\n（这使其成为两行响应式，因此我还需要将其包装在 {} 中。）现在，当我的 app 运行时，我立即被转入交互式控制台。\n我的第一步是验证我是否处于有问题的情况，因此我运行了 subset(sales, TERRITORY %% input$territory)。\n它返回一个空的数据框，所以我知道我在我需要的地方。\n如果我没有看到这个问题，我会输入 c 让 app 继续运行，然后与更多的交互以使其达到失败状态。然后我检查了 subset() 的输入是否符合我的预期。\n我首先仔细检查 sales 数据集是否正常。\n我真的没想到它会被损坏，因为 app 中没有任何内容触及它，但仔细检查您所做的每一个假设是最安全的。\nsales 看起来不错，所以问题一定出在 TERRITORY %% input$territory 中。\n由于 TERRITORY 是 sales 的一部分，我首先检查 input$territory：我盯着这个看了一会儿，因为它看起来也不错。\n然后我想到了！\n我以为是 NA，但实际上是 \"NA\"！\n现在我可以在 Shiny app 之外重现问题：然后我想出了一个简单的修复方法并将其应用于我的 server，然后重新运行该 app：万岁！\n问题解决了！\n但这让我感到非常惊讶 — Shiny 默默地将 NA 转换为 \"NA\"，所以我还提交了一份错误报告：https://github.com/rstudio/shiny/issues/2884。几周后，我再次查看这个示例，并开始思考不同的 territories。\n我们有 Europe、Middle-East、Africa (EMEA)、Asia-Pacific (APAC)。\nNorth America 在哪里？\n然后我突然意识到：源数据可能使用缩写 NA，而 R 将其作为缺失值读入。\n所以真正的修复应该发生在数据加载期间：这让生活变得更加简单！这是调试时的常见模式：在完全了解问题的根源之前，您通常需要剥开多层洋葱。","code":"\nsales <- readr::read_csv(\"sales-dashboard/sales_data_sample.csv\")\nsales <- sales[c(\n  \"TERRITORY\", \"ORDERDATE\", \"ORDERNUMBER\", \"PRODUCTCODE\",\n  \"QUANTITYORDERED\", \"PRICEEACH\"\n)]\nsales\n#> # A tibble: 2,823 × 6\n#>   TERRITORY ORDERDATE      ORDERNUMBER PRODUCTCODE QUANTITYORDERED PRICEEACH\n#>   <chr>     <chr>                <dbl> <chr>                 <dbl>     <dbl>\n#> 1 <NA>      2/24/2003 0:00       10107 S10_1678                 30      95.7\n#> 2 EMEA      5/7/2003 0:00        10121 S10_1678                 34      81.4\n#> 3 EMEA      7/1/2003 0:00        10134 S10_1678                 41      94.7\n#> 4 <NA>      8/25/2003 0:00       10145 S10_1678                 45      83.3\n#> # ℹ 2,819 more rows\nunique(sales$TERRITORY)\n#> [1] NA      \"EMEA\"  \"APAC\"  \"Japan\"\nui <- fluidPage(\n  selectInput(\"territory\", \"territory\", choices = unique(sales$TERRITORY)),\n  tableOutput(\"selected\")\n)\nserver <- function(input, output, session) {\n  selected <- reactive(sales[sales$TERRITORY == input$territory, ])\n  output$selected <- renderTable(head(selected(), 10))\n}\nsales[sales$TERRITORY == \"EMEA\", ]\n#> # A tibble: 2,481 × 6\n#>   TERRITORY ORDERDATE     ORDERNUMBER PRODUCTCODE QUANTITYORDERED PRICEEACH\n#>   <chr>     <chr>               <dbl> <chr>                 <dbl>     <dbl>\n#> 1 <NA>      <NA>                   NA <NA>                     NA      NA  \n#> 2 EMEA      5/7/2003 0:00       10121 S10_1678                 34      81.4\n#> 3 EMEA      7/1/2003 0:00       10134 S10_1678                 41      94.7\n#> 4 <NA>      <NA>                   NA <NA>                     NA      NA  \n#> # ℹ 2,477 more rows\nhead(sales$TERRITORY == \"EMEA\", 25)\n#>  [1]    NA  TRUE  TRUE    NA    NA    NA  TRUE  TRUE    NA  TRUE FALSE    NA\n#> [13]    NA    NA  TRUE    NA  TRUE  TRUE    NA    NA  TRUE FALSE  TRUE    NA\n#> [25]  TRUE\nsubset(sales, TERRITORY == \"EMEA\")\n#> # A tibble: 1,407 × 6\n#>   TERRITORY ORDERDATE       ORDERNUMBER PRODUCTCODE QUANTITYORDERED PRICEEACH\n#>   <chr>     <chr>                 <dbl> <chr>                 <dbl>     <dbl>\n#> 1 EMEA      5/7/2003 0:00         10121 S10_1678                 34      81.4\n#> 2 EMEA      7/1/2003 0:00         10134 S10_1678                 41      94.7\n#> 3 EMEA      11/11/2003 0:00       10180 S10_1678                 29      86.1\n#> 4 EMEA      11/18/2003 0:00       10188 S10_1678                 48     100  \n#> # ℹ 1,403 more rows\nsubset(sales, TERRITORY == NA)\n#> # A tibble: 0 × 6\n#> # ℹ 6 variables: TERRITORY <chr>, ORDERDATE <chr>, ORDERNUMBER <dbl>,\n#> #   PRODUCTCODE <chr>, QUANTITYORDERED <dbl>, PRICEEACH <dbl>\nhead(sales$TERRITORY == NA, 25)\n#>  [1] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\nhead(sales$TERRITORY %in% NA, 25)\n#>  [1]  TRUE FALSE FALSE  TRUE  TRUE  TRUE FALSE FALSE  TRUE FALSE FALSE  TRUE\n#> [13]  TRUE  TRUE FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE  TRUE\n#> [25] FALSE\nsubset(sales, TERRITORY %in% NA)\n#> # A tibble: 1,074 × 6\n#>   TERRITORY ORDERDATE       ORDERNUMBER PRODUCTCODE QUANTITYORDERED PRICEEACH\n#>   <chr>     <chr>                 <dbl> <chr>                 <dbl>     <dbl>\n#> 1 <NA>      2/24/2003 0:00        10107 S10_1678                 30      95.7\n#> 2 <NA>      8/25/2003 0:00        10145 S10_1678                 45      83.3\n#> 3 <NA>      10/10/2003 0:00       10159 S10_1678                 49     100  \n#> 4 <NA>      10/28/2003 0:00       10168 S10_1678                 36      96.7\n#> # ℹ 1,070 more rows\nserver <- function(input, output, session) {\n  selected <- reactive({\n    browser()\n    subset(sales, TERRITORY %in% input$territory)\n  })\n  output$selected <- renderTable(head(selected(), 10))\n}\ninput$territory\n#> [1] \"NA\"\nsubset(sales, TERRITORY %in% \"NA\")\n#> # A tibble: 0 × 6\n#> # ℹ 6 variables: TERRITORY <chr>, ORDERDATE <chr>, ORDERNUMBER <dbl>,\n#> #   PRODUCTCODE <chr>, QUANTITYORDERED <dbl>, PRICEEACH <dbl>\nserver <- function(input, output, session) {\n  selected <- reactive({\n    if (input$territory == \"NA\") {\n      subset(sales, is.na(TERRITORY))\n    } else {\n      subset(sales, TERRITORY == input$territory)\n    }\n  })\n  output$selected <- renderTable(head(selected(), 10))\n}\nsales <- readr::read_csv(\"sales-dashboard/sales_data_sample.csv\", na = \"\")\nunique(sales$TERRITORY)\n#> [1] \"NA\"    \"EMEA\"  \"APAC\"  \"Japan\""},{"path":"action-workflow.html","id":"debugging-reactivity","chapter":"5 Workflow","heading":"5.2.5 Debugging reactivity","text":"最难调试的问题是当你的响应式以意想不到的顺序触发时。\n在本书中，我们推荐的工具相对较少，可以帮助您调试此问题。\n在下一节中，您将学习如何创建一个最小的 reprex，这对于此类问题至关重要，在本书的后面部分，您将了解有关基础理论以及响应式日志等工具的更多信息，https://github.com/rstudio/reactlog。\n但现在，我们将重点关注这里有用的经典技术：“print” 调试。打印调试的基本思想是，只要您需要了解代码的一部分何时被评估，并显示重要变量的值，就调用 print()。\n我们称之为 “print” 调试（因为在大多数语言中你会使用打印函数），但在 R 中，使用 message() 更有意义：print() 设计用于显示数据向量，因此它在字符串周围加上引号，并以 [1] 开始第一行。message() 将其结果发送到“标准错误”，而不是“标准输出”。这些是描述输出流的技术术语，您通常不会注意到它们，因为它们在交互运行时以相同的方式显示。但如果您的 app 托管在其他地方，则发送到“标准错误”的输出将记录在日志中。我还建议将 message() 与 glue::glue() 结合起来，这样可以轻松地在消息中交错文本和值。\n如果您以前没有见过 glue ，其基本思想是，包装在 {} 内的任何内容都将被评估并插入到输出中：最后一个有用的工具是 str()，它可以打印任何对象的详细结构。\n如果您需要仔细检查是否拥有所需的对象类型，这尤其有用。这是一个展示一些基本想法的玩具 app。\n请注意我如何在 reactive() 中使用 message()：我必须执行计算，发送消息，然后返回之前计算的值。当我启动 app 时，控制台显示：如果我将 x 滑块拖动到 3，我会看到如果您发现结果有点令人惊讶，请不要担心。\n您将在 Chapter ?? 和 Chapter 3.3.3 中了解更多有关发生了什么的信息。","code":"\nlibrary(glue)\nname <- \"Hadley\"\nmessage(glue(\"Hello {name}\"))\n#> Hello Hadley\nui <- fluidPage(\n  sliderInput(\"x\", \"x\", value = 1, min = 0, max = 10),\n  sliderInput(\"y\", \"y\", value = 2, min = 0, max = 10),\n  sliderInput(\"z\", \"z\", value = 3, min = 0, max = 10),\n  textOutput(\"total\")\n)\nserver <- function(input, output, session) {\n  observeEvent(input$x, {\n    message(glue(\"Updating y from {input$y} to {input$x * 2}\"))\n    updateSliderInput(session, \"y\", value = input$x * 2)\n  })\n  \n  total <- reactive({\n    total <- input$x + input$y + input$z\n    message(glue(\"New total is {total}\"))\n    total\n  })\n  \n  output$total <- renderText({\n    total()\n  })\n}Updating y from 2 to 2\nNew total is 6Updating y from 2 to 6\nNew total is 8\nNew total is 12"},{"path":"action-workflow.html","id":"getting-help","chapter":"5 Workflow","heading":"5.3 Getting help","text":"如果您在尝试这些技术后仍然遇到困难，那么可能是时候询问其他人了。\nShiny community site 是获得帮助的好地方。\n许多 Shiny 用户以及 Shiny 包本身的开发人员都会阅读该网站。\n如果您想通过帮助他人来提高自己的 Shiny 技能，这里也是一个值得参观的好地方。为了尽快获得最有用的帮助，您需要创建一个 reprex 或可重现的示例。\nreprex 的目标是提供尽可能最小的 R 代码片段来说明问题并且可以轻松地在另一台计算机上运行。\n创建 reprex 是一种常见的礼貌（并且符合您自己的最大利益）：如果您希望有人帮助您，您应该让他们尽可能轻松！制作 reprex 是有礼貌的，因为它将问题的基本要素捕获为其他任何人都可以运行的形式，以便任何试图帮助您的人都可以快速准确地了解问题是什么，并且可以轻松地尝试可能的解决方案。","code":""},{"path":"action-workflow.html","id":"reprex-basics","chapter":"5 Workflow","heading":"5.3.1 Reprex basics","text":"reprex 只是一些 R 代码，当您将其复制并粘贴到另一台计算机上的 R 会话中时，它就会起作用。\n这是一个简单的 Shiny app reprex：这段代码不会对运行它的计算机做出任何假设（除了安装了 Shiny！），因此任何人都可以运行这段代码并看到问题：app 抛出一个错误，指出 “non-numeric argument binary operator”。清楚地说明问题是获得帮助的第一步，因为任何人都可以通过复制和粘贴代码来重现问题，因此他们可以轻松地探索您的代码并测试可能的解决方案。\n（在这种情况下，您需要 .numeric(input$n) 因为 selectInput() 在 input$n 中创建一个字符串。）","code":"\nlibrary(shiny)\nui <- fluidPage(\n  selectInput(\"n\", \"N\", 1:10),\n  plotOutput(\"plot\")\n)\nserver <- function(input, output, session) {\n  output$plot <- renderPlot({\n    n <- input$n * 2\n    plot(head(cars, n))\n  })\n}\nshinyApp(ui, server)"},{"path":"action-workflow.html","id":"making-a-reprex","chapter":"5 Workflow","heading":"5.3.2 Making a reprex","text":"制作 reprex 的第一步是创建一个独立的文件，其中包含运行代码所需的所有内容。\n您应该通过启动新的 R 会话然后运行代码来检查它是否有效。\n确保您没有忘记加载任何使您的 app 正常运行的软件包18。通常，让您的 app 在其他人的计算机上运行的最具挑战性的部分是消除仅存储在您的计算机上的数据的使用。\n共有三种有用的模式：通常，您使用的数据与问题没有直接关系，您可以使用 mtcars 或 iris 等内置数据集。通常，您使用的数据与问题没有直接关系，您可以使用 mtcars 或 iris 等内置数据集。其他时候，您也许可以编写一些 R 代码来创建一个数据集来说明问题：其他时候，您也许可以编写一些 R 代码来创建一个数据集来说明问题：如果这两种技术都失败了，您可以使用 dput() 将数据转换为代码。\n例如，dput(mydata) 生成重新创建 mydata 的代码：获得该代码后，您可以将其放入您的 reprex 中以生成 mydata：通常，在原始数据上运行 dput() 会生成大量代码，因此请找到能够说明问题的数据子集。\n您提供的数据集越小，其他人就越容易帮助您解决问题。如果从磁盘读取数据似乎是问题的一个不可简化的部分，那么最后的策略是提供一个包含 app.R 和所需数据文件的完整项目。\n提供此功能的最佳方法是作为托管在 GitHub 上的 RStudio 项目，但如果做不到这一点，您可以仔细制作一个可以在本地运行的 zip 文件。\n确保您使用相对路径（即 read.csv(\"-data.csv\") 而不是 read.csv(\"c:\\\\-user-name\\\\files\\\\-data.csv\")），以便您的代码在另一台计算机上运行时仍然有效。您还应该考虑读者并花一些时间格式化您的代码，以便于阅读。\n如果您采用 tidyverse style guide，您可以使用 styler 包自动重新格式化您的代码；这可以快速将您的代码转移到更易于阅读的位置。","code":"\nmydata <- data.frame(x = 1:5, y = c(\"a\", \"b\", \"c\", \"d\", \"e\"))\ndput(mydata)\nmydata <- structure(list(x = 1:5, y = structure(1:5, .Label = c(\"a\", \"b\",\"c\", \"d\", \"e\"), class = \"factor\")), class = \"data.frame\", row.names = c(NA, -5L))"},{"path":"action-workflow.html","id":"making-a-minimal-reprex","chapter":"5 Workflow","heading":"5.3.3 Making a minimal reprex","text":"创建一个可重现的示例是一个很好的第一步，因为它允许其他人精确地重现您的问题。\n然而，有问题的代码通常会隐藏在运行良好的代码中，因此您可以通过删除正常的代码来使帮助者的工作变得更加轻松。创建尽可能最小的 reprex 对于 Shiny apps 尤其重要，因为这些 apps 通常很复杂。\n如果您能够提取出您遇到困难的 app 的确切部分，而不是强迫潜在的帮助者了解您的整个 app，您将获得更快、更高质量的帮助。\n作为一个额外的好处，这个过程通常会引导您发现问题所在，因此您不必等待其他人的帮助！将一堆代码简化为本质问题是一项技能，一开始你可能不会很擅长。\n没关系！\n即使代码复杂性的最小降低也会帮助帮助你的人，并且随着时间的推移，你的 reprex 缩减技能将会提高。如果您不知道代码的哪一部分触发了问题，找到它的一个好方法是从应用程序中逐段删除代码段，直到问题消失。\n如果删除特定代码段可以使问题停止，则该代码很可能与问题相关。\n或者，有时更简单的做法是从一个全新的、空的 app 开始，然后逐步构建它，直到再次发现问题。一旦您简化了 app 以演示问题，就值得进行最后一次检查：UI 中的每个输入和输出都与问题相关吗？UI 中的每个输入和输出都与问题相关吗？您的 app 是否具有复杂的布局，您可以简化该布局以帮助专注于手头的问题？\n您是否删除了所有使您的 app 看起来不错但与问题无关的 UI 自定义？您的 app 是否具有复杂的布局，您可以简化该布局以帮助专注于手头的问题？\n您是否删除了所有使您的 app 看起来不错但与问题无关的 UI 自定义？现在可以删除 server() 中的任何响应式吗？现在可以删除 server() 中的任何响应式吗？如果您尝试了多种方法来解决问题，您是否已清除所有无效尝试的痕迹？如果您尝试了多种方法来解决问题，您是否已清除所有无效尝试的痕迹？您加载的每个包是否都需要说明问题？\n您可以通过用虚拟代码替换函数来消除包吗？您加载的每个包是否都需要说明问题？\n您可以通过用虚拟代码替换函数来消除包吗？这可能需要大量工作，但回报是巨大的：通常您会在进行 reprex 时发现解决方案，如果没有，获得帮助也会容易得多。","code":""},{"path":"action-workflow.html","id":"case-study-1","chapter":"5 Workflow","heading":"5.3.4 Case study","text":"为了说明制作一流 reprex 的过程，我将使用 Scott Novogoratz 在 RStudio community 上发布的一个示例。\n最初的代码非常接近 reprex，但不太可重现，因为它忘记加载一对包。\n作为起点，我：添加了缺失的 library(lubridate) 和 library(xts)。将 ui 和 server 拆分为单独的对象。使用 styler::style_selection() 重新格式化代码。这产生了以下 reprex：如果您运行此 reprex，您将在最初的帖子中看到相同的问题：错误指出 “Type mismatch min, max, value. must Date, POSIXt, number”。\n这是一个可靠的 reprex：我可以轻松地在我的计算机上运行它，它立即说明了问题。\n不过，它有点长，所以还不清楚是什么原因造成的。为了使这个 reprex 更简单，我们可以仔细检查每一行代码，看看它是否重要。\n在这样做的过程中，我发现：删除以 print() 开头的两行不会影响错误。\n这两行使用了 lubridate::.POSIXt()，这是 lubridate 的唯一用途，所以一旦我删除它们，我就不再需要加载 lubridate。删除以 print() 开头的两行不会影响错误。\n这两行使用了 lubridate::.POSIXt()，这是 lubridate 的唯一用途，所以一旦我删除它们，我就不再需要加载 lubridate。df 是一个转换为 xts 数据框（称为 timeSeries）的数据帧。但使用 timeSeries 的唯一方法是通过 time(timeSeries) 返回日期时间。\n因此，我创建了一个新的变量 datetime，其中包含一些虚拟日期时间数据。\n这仍然产生相同的错误，所以我删除了 timeSeries 和 df，并且由于这是唯一使用 xts 的地方，我还删除了 library(xts)。df 是一个转换为 xts 数据框（称为 timeSeries）的数据帧。但使用 timeSeries 的唯一方法是通过 time(timeSeries) 返回日期时间。\n因此，我创建了一个新的变量 datetime，其中包含一些虚拟日期时间数据。\n这仍然产生相同的错误，所以我删除了 timeSeries 和 df，并且由于这是唯一使用 xts 的地方，我还删除了 library(xts)。这些更改共同产生了一个新的 server()，如下所示：接下来，我注意到这个示例使用了相对复杂的 Shiny 技术，其中 UI 是在 server 函数中生成的。\n但这里 renderUI() 不使用任何响应式输入，因此如果从 server 函数移出并进入 UI，它应该以相同的方式工作。这产生了一个特别好的结果，因为现在错误发生得更早，甚至在我们启动 app 之前：现在我们可以从错误消息中获取提示，并查看我们提供给 min、max 和 value 的每个输入，以了解问题出在哪里：现在问题很明显：我们还没有分配 min 和 max 变量，所以我们不小心将 min() 和 max() 函数传递给了 sliderInput()。\n解决该问题的一种方法是使用 range() 代替：这是创建 reprex 的相当典型的结果：一旦将问题简化为其关键组件，解决方案就变得显而易见。\n创建一个好的 reprex 是一种非常强大的调试技术。为了简化这个 reprex，我必须对我不太熟悉的函数进行大量实验和阅读。19\n如果这是您的 reprex，那么通常会更容易做到这一点，因为您已经了解代码的意图。\n不过，您通常需要进行大量实验才能找出问题到底出在哪里。\n这可能会令人沮丧并且耗时，但它有很多好处：它使您能够创建问题的描述，任何了解 Shiny 的人都可以访问该描述，而不是任何了解 Shiny 和您正在工作的特定领域的人都可以访问。它使您能够创建问题的描述，任何了解 Shiny 的人都可以访问该描述，而不是任何了解 Shiny 和您正在工作的特定领域的人都可以访问。您将为代码的工作原理建立一个更好的思维模型，这意味着您将来不太可能犯相同或类似的错误。您将为代码的工作原理建立一个更好的思维模型，这意味着您将来不太可能犯相同或类似的错误。随着时间的推移，您创建 reprex 的速度会越来越快，这将成为调试时的常用技术之一。随着时间的推移，您创建 reprex 的速度会越来越快，这将成为调试时的常用技术之一。即使你没有创造出完美的 reprex，你可以做的任何改善你的 reprex 的工作都比别人做的工作要少。\n如果您试图从软件包开发人员那里获得帮助，这一点尤其重要，因为他们通常对时间有很多要求。即使你没有创造出完美的 reprex，你可以做的任何改善你的 reprex 的工作都比别人做的工作要少。\n如果您试图从软件包开发人员那里获得帮助，这一点尤其重要，因为他们通常对时间有很多要求。当我尝试在 RStudio community 上帮助某人使用他们的 app 时，创建 reprex 始终是我做的第一件事。\n这不是我用来欺骗那些我不想帮助的人的工作练习：这正是我的起点！","code":"\nlibrary(xts)\nlibrary(lubridate)\nlibrary(shiny)\n\nui <- fluidPage(\n  uiOutput(\"interaction_slider\"),\n  verbatimTextOutput(\"breaks\")\n)\nserver <- function(input, output, session) {\n  df <- data.frame(\n    dateTime = c(\n      \"2019-08-20 16:00:00\",\n      \"2019-08-20 16:00:01\",\n      \"2019-08-20 16:00:02\",\n      \"2019-08-20 16:00:03\",\n      \"2019-08-20 16:00:04\",\n      \"2019-08-20 16:00:05\"\n    ),\n    var1 = c(9, 8, 11, 14, 16, 1),\n    var2 = c(3, 4, 15, 12, 11, 19),\n    var3 = c(2, 11, 9, 7, 14, 1)\n  )\n\n  timeSeries <- as.xts(df[, 2:4], \n    order.by = strptime(df[, 1], format = \"%Y-%m-%d %H:%M:%S\")\n  )\n  print(paste(min(time(timeSeries)), is.POSIXt(min(time(timeSeries))), sep = \" \"))\n  print(paste(max(time(timeSeries)), is.POSIXt(max(time(timeSeries))), sep = \" \"))\n\n  output$interaction_slider <- renderUI({\n    sliderInput(\n      \"slider\",\n      \"Select Range:\",\n      min = min(time(timeSeries)),\n      max = max(time(timeSeries)),\n      value = c(min, max)\n    )\n  })\n\n  brks <- reactive({\n    req(input$slider)\n    seq(input$slider[1], input$slider[2], length.out = 10)\n  })\n\n  output$breaks <- brks\n}\nshinyApp(ui, server)\ndatetime <- Sys.time() + (86400 * 0:10)\n\nserver <- function(input, output, session) {\n  output$interaction_slider <- renderUI({\n    sliderInput(\n      \"slider\",\n      \"Select Range:\",\n      min   = min(datetime),\n      max   = max(datetime),\n      value = c(min, max)\n    )\n  })\n  \n  brks <- reactive({\n    req(input$slider)\n    seq(input$slider[1], input$slider[2], length.out = 10)\n  })\n  \n  output$breaks <- brks\n}\nui <- fluidPage(\n  sliderInput(\"slider\",\n    \"Select Range:\",\n    min   = min(datetime),\n    max   = max(datetime),\n    value = c(min, max)\n  ),\n  verbatimTextOutput(\"breaks\")\n)\n#> Error: Type mismatch for `min`, `max`, and `value`.\n#> i All values must have same type: either numeric, Date, or POSIXt.\nmin(datetime)\nmax(datetime)\nc(min, max)\nui <- fluidPage(\n  sliderInput(\"slider\",\n              \"Select Range:\",\n              min   = min(datetime),\n              max   = max(datetime),\n              value = range(datetime)\n  ),\n  verbatimTextOutput(\"breaks\")\n)"},{"path":"action-workflow.html","id":"summary-4","chapter":"5 Workflow","heading":"5.4 Summary","text":"本章为您提供了一些用于开发 apps、调试问题和获取帮助的有用工作流程。\n这些工作流程可能看起来有点抽象并且很容易被忽视，因为它们并没有具体改进单个 app。\n但我认为工作流程是我的“秘密”力量之一：我能够取得如此多成就的原因之一是我投入时间来分析和改进我的工作流程。\n我强烈鼓励您也这样做！关于布局和主题的下一章是有用技术的第一章。\n无需按顺序阅读；请随意跳至当前 app 所需的章节。","code":""},{"path":"action-dynamic.html","id":"action-dynamic","chapter":"6 Dynamic UI","heading":"6 Dynamic UI","text":"到目前为止，我们已经看到用户界面和 server 函数之间的清晰分离：用户界面是在 app 启动时静态定义的，因此它无法响应 app 中发生的任何情况。\n在本章中，您将学习如何创建动态（dynamic）用户界面，使用在 server 函数中运行的代码更改 UI。创建动态用户界面有以下三种关键技术：使用 update 系列函数修改输入控件的参数。使用 update 系列函数修改输入控件的参数。使用 tabsetPanel() 有条件地显示和隐藏部分用户界面。使用 tabsetPanel() 有条件地显示和隐藏部分用户界面。使用 uiOutput() 和 renderUI() 通过代码生成用户界面的选定部分。使用 uiOutput() 和 renderUI() 通过代码生成用户界面的选定部分。这三个工具使您能够通过修改输入和输出来响应用户。\n我将演示一些更有用的方法来应用它们，但最终您只会受到创造力的限制。\n同时，这些工具可能会使您的 app 更加难以推理，因此请谨慎部署它们，并始终努力使用最简单的技术来解决您的问题。","code":"\nlibrary(shiny)\nlibrary(dplyr, warn.conflicts = FALSE)"},{"path":"action-dynamic.html","id":"updating-inputs","chapter":"6 Dynamic UI","heading":"6.1 Updating inputs","text":"我们将从一种简单的技术开始，该技术允许您在创建输入后对其进行修改：更新函数系列。\n每个输入控件，例如 textInput() 与更新函数配对，例如 updateTextInput()，允许您在创建控件后对其进行修改。以下面代码为例，结果如 Figure 6.1 所示。\n该 app 有两个输入，用于控制另一个输入（滑块）的范围（min 和 max）。\n关键思想是每当 min 或 max 输入发生变化时，使用 observeEvent()20 触发 updateSliderInput()。\nFigure 6.1: 加载时的 app（左），增加 max（中），然后减少 min（右）。 See live https://hadley.shinyapps.io/ms-update-basics.\n更新函数看起来与其他 Shiny 函数略有不同：它们都将输入的名称（作为字符串）作为 inputId 参数21。\n其余参数对应于输入构造函数的参数，可以在创建后进行修改。为了帮助您掌握更新函数，我将展示几个更简单的示例，然后我们将使用分层选择框深入研究更复杂的案例，最后讨论循环引用问题。","code":"\nui <- fluidPage(\n  numericInput(\"min\", \"Minimum\", 0),\n  numericInput(\"max\", \"Maximum\", 3),\n  sliderInput(\"n\", \"n\", min = 0, max = 3, value = 1)\n)\nserver <- function(input, output, session) {\n  observeEvent(input$min, {\n    updateSliderInput(inputId = \"n\", min = input$min)\n  })  \n  observeEvent(input$max, {\n    updateSliderInput(inputId = \"n\", max = input$max)\n  })\n}"},{"path":"action-dynamic.html","id":"simple-uses","chapter":"6 Dynamic UI","heading":"6.1.1 Simple uses","text":"更新函数最简单的用途是为用户提供一些小便利。\n例如，也许您希望能够轻松地将参数重置回其初始值。\n下面的代码片段展示了如何组合 actionButton()、observeEvent() 和 updateSliderInput()，输出如 Figure 6.2 所示。\nFigure 6.2: 加载 app（左），拖动一些滑块后（中），后然后单击 reset（右）。 See live https://hadley.shinyapps.io/ms-update-reset.\n类似的应用程序是调整操作按钮的文本，以便您确切地知道它将做什么。\nFigure 6.3 显示了下面代码的结果。\nFigure 6.3: 加载时的 app（左），将 simulations 设置为 1（中），然后将 simulations 设置为 100（右）。 See live https://hadley.shinyapps.io/ms-update-button.\n以这种方式使用更新函数的方法有很多种；当您开发复杂的应用程序时，请寻找向用户提供更多信息的方法。\n一个特别重要的应用是通过逐步过滤，可以更轻松地从一长串可能的选项中进行选择。\n这通常是“分层选择框”的问题。","code":"\nui <- fluidPage(\n  sliderInput(\"x1\", \"x1\", 0, min = -10, max = 10),\n  sliderInput(\"x2\", \"x2\", 0, min = -10, max = 10),\n  sliderInput(\"x3\", \"x3\", 0, min = -10, max = 10),\n  actionButton(\"reset\", \"Reset\")\n)\n\nserver <- function(input, output, session) {\n  observeEvent(input$reset, {\n    updateSliderInput(inputId = \"x1\", value = 0)\n    updateSliderInput(inputId = \"x2\", value = 0)\n    updateSliderInput(inputId = \"x3\", value = 0)\n  })\n}\nui <- fluidPage(\n  numericInput(\"n\", \"Simulations\", 10),\n  actionButton(\"simulate\", \"Simulate\")\n)\n\nserver <- function(input, output, session) {\n  observeEvent(input$n, {\n    label <- paste0(\"Simulate \", input$n, \" times\")\n    updateActionButton(inputId = \"simulate\", label = label)\n  })\n}"},{"path":"action-dynamic.html","id":"hierarchical-select","chapter":"6 Dynamic UI","heading":"6.1.2 Hierarchical select boxes","text":"更新函数的一个更复杂但特别有用的应用是允许跨多个类别进行交互式钻取。\n我将使用来自 https://www.kaggle.com/kyanyoga/sample-sales-data 的销售仪表盘的一些虚构数据来说明它们的用法。在这个演示中，我将重点关注数据中的自然层次结构：每个 territory 都包含 customers。每个 customer 有多个 orders。每个 order 包含多行。我想创建一个用户界面，您可以：选择一个 territory 以查看所有 customers。选择一个 customer 以查看所有 orders。选择一个 order 以查看基础行。UI 的本质很简单：我将创建三个选择框和一个输出表。\ncustomername 和 ordernumber 选择框的选项将动态生成，因此我设置 choices = NULL。在 server 函数中，我自上而下地工作：我创建了一个响应式 territory()，其中包含与来自 sales 所选 territory 匹配的行。我创建了一个响应式 territory()，其中包含与来自 sales 所选 territory 匹配的行。每当 territory() 发生变化时，我都会更新 input$customername 选择框中的 choices 列表。每当 territory() 发生变化时，我都会更新 input$customername 选择框中的 choices 列表。我创建了另一个响应式 customer()，其中包含与来自 territory() 所选 customer 匹配的行。我创建了另一个响应式 customer()，其中包含与来自 territory() 所选 customer 匹配的行。每当 customer() 更改时，我都会更新 input$ordernumber 选择框中的 choices 列表。每当 customer() 更改时，我都会更新 input$ordernumber 选择框中的 choices 列表。我在 output$data 中显示选定的 orders。我在 output$data 中显示选定的 orders。您可以在下面看到该组织：\nFigure 6.4: 我选择 “EMEA”（左），然后选择 “Lyon Souveniers”（中），然后（右）查看 orders。 See live https://hadley.shinyapps.io/ms-update-nested.\n在 https://hadley.shinyapps.io/ms-update-nested 尝试这个简单的示例，或者在 https://github.com/hadley/mastering-shiny/tree/master/sales-dashboard 查看更完整的应用程序仪表盘。","code":"\nsales <- vroom::vroom(\"sales-dashboard/sales_data_sample.csv\", col_types = list(), na = \"\")\nsales %>% \n  select(TERRITORY, CUSTOMERNAME, ORDERNUMBER, everything()) %>%\n  arrange(ORDERNUMBER)\n#> # A tibble: 2,823 × 25\n#>    TERRITORY CUSTOMERNAME   ORDERNUMBER QUANTITYORDERED PRICEEACH ORDERLINENUMBER\n#>    <chr>     <chr>                <dbl>           <dbl>     <dbl>           <dbl>\n#>  1 NA        Online Diecas…       10100              30     100                 3\n#>  2 NA        Online Diecas…       10100              50      67.8               2\n#>  3 NA        Online Diecas…       10100              22      86.5               4\n#>  4 NA        Online Diecas…       10100              49      34.5               1\n#>  5 EMEA      Blauer See Au…       10101              25     100                 4\n#>  6 EMEA      Blauer See Au…       10101              26     100                 1\n#>  7 EMEA      Blauer See Au…       10101              45      31.2               3\n#>  8 EMEA      Blauer See Au…       10101              46      53.8               2\n#>  9 NA        Vitachrome In…       10102              39     100                 2\n#> 10 NA        Vitachrome In…       10102              41      50.1               1\n#> # ℹ 2,813 more rows\n#> # ℹ 19 more variables: SALES <dbl>, ORDERDATE <chr>, STATUS <chr>, QTR_ID <dbl>,\n#> #   MONTH_ID <dbl>, YEAR_ID <dbl>, PRODUCTLINE <chr>, MSRP <dbl>,\n#> #   PRODUCTCODE <chr>, PHONE <chr>, ADDRESSLINE1 <chr>, ADDRESSLINE2 <chr>,\n#> #   CITY <chr>, STATE <chr>, POSTALCODE <chr>, COUNTRY <chr>,\n#> #   CONTACTLASTNAME <chr>, CONTACTFIRSTNAME <chr>, DEALSIZE <chr>\nui <- fluidPage(\n  selectInput(\"territory\", \"Territory\", choices = unique(sales$TERRITORY)),\n  selectInput(\"customername\", \"Customer\", choices = NULL),\n  selectInput(\"ordernumber\", \"Order number\", choices = NULL),\n  tableOutput(\"data\")\n)\nserver <- function(input, output, session) {\n  territory <- reactive({\n    filter(sales, TERRITORY == input$territory)\n  })\n  observeEvent(territory(), {\n    choices <- unique(territory()$CUSTOMERNAME)\n    updateSelectInput(inputId = \"customername\", choices = choices) \n  })\n  \n  customer <- reactive({\n    req(input$customername)\n    filter(territory(), CUSTOMERNAME == input$customername)\n  })\n  observeEvent(customer(), {\n    choices <- unique(customer()$ORDERNUMBER)\n    updateSelectInput(inputId = \"ordernumber\", choices = choices)\n  })\n  \n  output$data <- renderTable({\n    req(input$ordernumber)\n    customer() %>% \n      filter(ORDERNUMBER == input$ordernumber) %>% \n      select(QUANTITYORDERED, PRICEEACH, PRODUCTCODE)\n  })\n}"},{"path":"action-dynamic.html","id":"freezing-reactive-inputs","chapter":"6 Dynamic UI","heading":"6.1.3 Freezing reactive inputs","text":"有时，这种分层选择可能会短暂地创建一组无效的输入，从而导致出现不希望的输出。\n例如，考虑这个简单的 app，您可以在其中选择数据集，然后选择要汇总的变量：如果您尝试 https://hadley.shinyapps.io/ms-freeze 上的实时 app，您会注意到当您切换数据集时，摘要输出会短暂闪烁。\n这是因为 updateSelectInput() 仅在所有输出和观察者运行后才产生影响，因此暂时存在一种状态，其中具有数据集 B 和数据集 中的变量，因此输出包含 summary(NULL)。您可以通过使用 freezeReactiveValue() “冻结（freezing）”输入来解决此问题。\n这确保了使用输入的任何响应式或输出在下一轮完整的失效之前不会被更新22。请注意，无需“解冻”输入值；在 Shiny 检测到会话和 server 再次同步后，这种情况会自动发生。您可能想知道何时应该使用 freezeReactiveValue()：当您动态更改输入 value 时始终使用它实际上是一个很好的做法。\n实际的修改需要一些时间才能流到浏览器，然后返回到 Shiny，在此期间，任何值的读取充其量都是浪费，最坏的情况会导致错误。\n使用 freezeReactiveValue() 告诉所有下游计算输入值已过时，他们应该节省精力直到它有用为止。","code":"\nui <- fluidPage(\n  selectInput(\"dataset\", \"Choose a dataset\", c(\"pressure\", \"cars\")),\n  selectInput(\"column\", \"Choose column\", character(0)),\n  verbatimTextOutput(\"summary\")\n)\n\nserver <- function(input, output, session) {\n  dataset <- reactive(get(input$dataset, \"package:datasets\"))\n  \n  observeEvent(input$dataset, {\n    updateSelectInput(inputId = \"column\", choices = names(dataset()))\n  })\n  \n  output$summary <- renderPrint({\n    summary(dataset()[[input$column]])\n  })\n}\nserver <- function(input, output, session) {\n  dataset <- reactive(get(input$dataset, \"package:datasets\"))\n  \n  observeEvent(input$dataset, {\n    freezeReactiveValue(input, \"column\")\n    updateSelectInput(inputId = \"column\", choices = names(dataset()))\n  })\n  \n  output$summary <- renderPrint({\n    summary(dataset()[[input$column]])\n  })\n}"},{"path":"action-dynamic.html","id":"circular-references","chapter":"6 Dynamic UI","heading":"6.1.4 Circular references","text":"如果您想使用更新函数来更改输入的当前 value23，我们需要讨论一个重要问题。\n从 Shiny 的角度来看，使用更新函数修改 value 与用户通过单击或键入来修改 value 没有什么不同。\n这意味着更新函数可以以与人类完全相同的方式触发响应式更新。\n这意味着您现在已经超出了纯响应式编程的范围，并且您需要开始担心循环引用和无限循环。例如，采用以下简单的 app。\n它包含一个输入控件和一个将其值加一的观察者。\n每次 updateNumericInput() 运行时，它都会更改 input$n，导致 updateNumericInput() 再次运行，因此 app 陷入无限循环，不断增加 input$n 的值。您不太可能在自己的 app 中产生如此明显的问题，但如果您更新彼此依赖的多个控件，则可能会出现这种问题，如下一个示例所示。","code":"\nui <- fluidPage(\n  numericInput(\"n\", \"n\", 0)\n)\nserver <- function(input, output, session) {\n  observeEvent(input$n,\n               updateNumericInput(inputId = \"n\", value = input$n + 1)\n  )\n}"},{"path":"action-dynamic.html","id":"inter-related-inputs","chapter":"6 Dynamic UI","heading":"6.1.5 Inter-related inputs","text":"当 app 中有多个“事实来源”时，很容易出现循环引用。\n例如，假设您想要创建一个温度转换 app，您可以在其中输入摄氏温度或华氏温度：如果您使用这个 app，https://hadley.shinyapps.io/ms-temperature，您会发现它大部分工作正常，但您可能会注意到它有时会触发多个更改。\n例如：设置 120 F，然后单击向下箭头。F 更改为 119，C 更新为 48。48 C 转换为 118 F，因此 F 再次变为 118。幸运的是 118 F 仍然是 48 C，所以更新就到此为止。这个问题没有办法解决，因为您只有一个想法（温度），app 中有两种表达式（摄氏度和华氏度）。\n幸运的是，循环很快收敛到满足这两个约束的值。\n一般来说，最好避免这些情况，除非您愿意非常仔细地分析您所创建的底层动态系统的收敛特性。","code":"\nui <- fluidPage(\n  numericInput(\"temp_c\", \"Celsius\", NA, step = 1),\n  numericInput(\"temp_f\", \"Fahrenheit\", NA, step = 1)\n)\n\nserver <- function(input, output, session) {\n  observeEvent(input$temp_f, {\n    c <- round((input$temp_f - 32) * 5 / 9)\n    updateNumericInput(inputId = \"temp_c\", value = c)\n  })\n  \n  observeEvent(input$temp_c, {\n    f <- round((input$temp_c * 9 / 5) + 32)\n    updateNumericInput(inputId = \"temp_f\", value = f)\n  })\n}"},{"path":"action-dynamic.html","id":"exercises-5","chapter":"6 Dynamic UI","heading":"6.1.6 Exercises","text":"使用更新 input$date 的 server 函数完成下面的用户界面，以便您只能选择 input$year 中的日期。使用 server 函数完成下面的用户界面，该函数根据 input$state 更新 input$county 选择。\n对于额外的挑战，还可以将 Louisiana 的标签从 “County” 更改为 “Parish”，将 Alaska 的标签从 “County” 更改为 “Borough”。使用 server 函数完成下面的用户界面，该函数根据 input$continent 更新 input$country 选择。\n使用 output$data 显示所有匹配的行。扩展之前的 app，以便您还可以选择所有 continents，从而查看所有 countries。\n您需要将 \"()\" 添加到选项列表中，然后在过滤时特殊处理。扩展之前的 app，以便您还可以选择所有 continents，从而查看所有 countries。\n您需要将 \"()\" 添加到选项列表中，然后在过滤时特殊处理。https://community.rstudio.com/t/29307 所描述问题的核心是什么 ?https://community.rstudio.com/t/29307 所描述问题的核心是什么 ?","code":"\nui <- fluidPage(\n  numericInput(\"year\", \"year\", value = 2020),\n  dateInput(\"date\", \"date\")\n)\nlibrary(openintro, warn.conflicts = FALSE)\n#> Loading required package: airports\n#> Loading required package: cherryblossom\n#> Loading required package: usdata\n#> Registered S3 methods overwritten by 'readr':\n#>   method                    from \n#>   as.data.frame.spec_tbl_df vroom\n#>   as_tibble.spec_tbl_df     vroom\n#>   format.col_spec           vroom\n#>   print.col_spec            vroom\n#>   print.collector           vroom\n#>   print.date_names          vroom\n#>   print.locale              vroom\n#>   str.col_spec              vroom\nstates <- unique(county$state)\n\nui <- fluidPage(\n  selectInput(\"state\", \"State\", choices = states),\n  selectInput(\"county\", \"County\", choices = NULL)\n)\nlibrary(gapminder)\ncontinents <- unique(gapminder$continent)\n\nui <- fluidPage(\n  selectInput(\"continent\", \"Continent\", choices = continents), \n  selectInput(\"country\", \"Country\", choices = NULL),\n  tableOutput(\"data\")\n)"},{"path":"action-dynamic.html","id":"dynamic-visibility","chapter":"6 Dynamic UI","heading":"6.2 Dynamic visibility","text":"复杂性的下一步是有选择地显示和隐藏部分 UI。\n如果您了解一点 JavaScript 和 CSS，还有更复杂的方法，但有一种不需要任何额外知识的有用技术：使用选项卡集隐藏可选 UI（如 Section ?? 中介绍的）。\n这是一个聪明的技巧，允许您根据需要显示和隐藏 UI，而无需从头开始重新生成它（正如您将在下一节中学到的）。\nFigure 6.5: 选择 panel1（左），然后选择 panel2（中），然后选择 panel3（右）。 See live https://hadley.shinyapps.io/ms-dynamic-panels.\n这里有两个主要想法：使用带有隐藏选项卡的选项卡集面板。使用 updateTabsetPanel() 从 server 切换选项卡。这是一个简单的想法，但是当与一点创造力相结合时，它会给你带来相当大的力量。\n以下两节介绍了如何在实践中使用它的几个小示例。","code":"\nui <- fluidPage(\n  sidebarLayout(\n    sidebarPanel(\n      selectInput(\"controller\", \"Show\", choices = paste0(\"panel\", 1:3))\n    ),\n    mainPanel(\n      tabsetPanel(\n        id = \"switcher\",\n        type = \"hidden\",\n        tabPanelBody(\"panel1\", \"Panel 1 content\"),\n        tabPanelBody(\"panel2\", \"Panel 2 content\"),\n        tabPanelBody(\"panel3\", \"Panel 3 content\")\n      )\n    )\n  )\n)\n\nserver <- function(input, output, session) {\n  observeEvent(input$controller, {\n    updateTabsetPanel(inputId = \"switcher\", selected = input$controller)\n  })\n}"},{"path":"action-dynamic.html","id":"conditional-ui","chapter":"6 Dynamic UI","heading":"6.2.1 Conditional UI","text":"想象一下，您想要一个允许用户模拟正态分布、均匀分布和指数分布的 app。\n每个分布都有不同的参数，因此我们需要某种方法来显示不同分布的不同控件。\n在这里，我将把每个发行版的唯一用户界面放在自己的 tabPanel() 中，然后将三个选项卡排列到一个 tabsetPanel() 中。然后，我将其嵌入到更完整的 UI 中，该 UI 允许用户选择样本数量并显示结果的直方图：请注意，我已经仔细地将 input$dist 中的 choices 与选项卡面板的名称进行了匹配。\n这使得编写下面的 observeEvent() 代码变得很容易，该代码可以在分布发生变化时自动切换控件。\n该 app 的其余部分使用您已经熟悉的技术。\n最终结果如 Figure 6.6 所示。\nFigure 6.6: 正态分布（左）、均匀分布（中）和指数分布（右）的结果。 See live https://hadley.shinyapps.io/ms-dynamic-conditional.\n请注意，（例如）input$mean 的值与其对用户是否可见无关。\n底层的 HTML 控件仍然存在；你只是看不到它。","code":"\nparameter_tabs <- tabsetPanel(\n  id = \"params\",\n  type = \"hidden\",\n  tabPanel(\"normal\",\n           numericInput(\"mean\", \"mean\", value = 1),\n           numericInput(\"sd\", \"standard deviation\", min = 0, value = 1)\n  ),\n  tabPanel(\"uniform\", \n           numericInput(\"min\", \"min\", value = 0),\n           numericInput(\"max\", \"max\", value = 1)\n  ),\n  tabPanel(\"exponential\",\n           numericInput(\"rate\", \"rate\", value = 1, min = 0),\n  )\n)\nui <- fluidPage(\n  sidebarLayout(\n    sidebarPanel(\n      selectInput(\"dist\", \"Distribution\", \n        choices = c(\"normal\", \"uniform\", \"exponential\")\n      ),\n      numericInput(\"n\", \"Number of samples\", value = 100),\n      parameter_tabs,\n    ),\n    mainPanel(\n      plotOutput(\"hist\")\n    )\n  )\n)\nserver <- function(input, output, session) {\n  observeEvent(input$dist, {\n    updateTabsetPanel(inputId = \"params\", selected = input$dist)\n  }) \n  \n  sample <- reactive({\n    switch(input$dist,\n      normal = rnorm(input$n, input$mean, input$sd),\n      uniform = runif(input$n, input$min, input$max),\n      exponential = rexp(input$n, input$rate)\n    )\n  })\n  output$hist <- renderPlot(hist(sample()), res = 96)\n}"},{"path":"action-dynamic.html","id":"dynamic-wizard","chapter":"6 Dynamic UI","heading":"6.2.2 Wizard interface","text":"您还可以使用这个想法来创建一个“向导（wizard）”，这是一种界面，可以通过将大量信息分布在多个页面上来更轻松地收集信息。\n在这里，我们在每个“页面”中嵌入了操作按钮，以便轻松前进和后退。\n结果如 Figure 6.7 所示。\nFigure 6.7: 向导界面将复杂的 UI 划分为多个页面。在这里，我们通过一个非常简单的示例来演示这个想法，单击 next 前进到下一页。 See live https://hadley.shinyapps.io/ms-wizard.\n请注意使用 switch_page() 函数来减少 server 代码中的重复量。\n我们将在 Chapter ?? 中回到这个想法，然后在 Section ?? 中创建一个模块来自动化向导界面。","code":"\nui <- fluidPage(\n  tabsetPanel(\n    id = \"wizard\",\n    type = \"hidden\",\n    tabPanel(\"page_1\", \n             \"Welcome!\",\n             actionButton(\"page_12\", \"next\")\n    ),\n    tabPanel(\"page_2\", \n             \"Only one page to go\",\n             actionButton(\"page_21\", \"prev\"),\n             actionButton(\"page_23\", \"next\")\n    ),\n    tabPanel(\"page_3\", \n             \"You're done!\",\n             actionButton(\"page_32\", \"prev\")\n    )\n  )\n)\n\nserver <- function(input, output, session) {\n  switch_page <- function(i) {\n    updateTabsetPanel(inputId = \"wizard\", selected = paste0(\"page_\", i))\n  }\n  \n  observeEvent(input$page_12, switch_page(2))\n  observeEvent(input$page_21, switch_page(1))\n  observeEvent(input$page_23, switch_page(3))\n  observeEvent(input$page_32, switch_page(2))\n}"},{"path":"action-dynamic.html","id":"exercises-6","chapter":"6 Dynamic UI","heading":"6.2.3 Exercises","text":"仅当用户选中 “advanced” 复选框时，才使用隐藏选项卡集显示其他控件。创建一个绘制 ggplot(diamonds, aes(carat)) 的 app，但允许用户选择要使用的 geom：geom_histogram()、geom_freqpoly() 或 geom_density()。\n使用隐藏选项卡集允许用户根据 geom 选择不同的参数：geom_histogram() 和 geom_freqpoly() 有一个 binwidth 参数；geom_density() 有一个 bw 参数。修改您在上一个练习中创建的 app，以允许用户选择是否显示每个 geom（即，他们可以选择 0、1、2 或 3，而不是始终使用一个 geom）。确保您可以独立控制 histogram 和 frequency polygon 的 binwidth。","code":""},{"path":"action-dynamic.html","id":"programming-ui","chapter":"6 Dynamic UI","heading":"6.3 Creating UI with code","text":"有时，上述技术都无法为您提供所需的动态级别：更新函数仅允许您更改现有输入，而选项卡集仅在您拥有一组固定且已知的可能组合时才起作用。\n有时，您需要根据其他输入创建不同类型或数量的输入（或输出）。\n最后一项技术使您能够做到这一点。值得注意的是，您始终使用代码创建用户界面，但到目前为止您总是在 app 启动之前完成。\n此技术使您能够在 app 运行时创建和修改用户界面。\n该解决方案有两个部分：uiOutput() 在您的 ui 中插入一个占位符。\n这会留下一个“空位（hole）”，您的 server 代码可以稍后填充。uiOutput() 在您的 ui 中插入一个占位符。\n这会留下一个“空位（hole）”，您的 server 代码可以稍后填充。renderUI() 在 server() 中调用，用动态生成的 UI 填充占位符。renderUI() 在 server() 中调用，用动态生成的 UI 填充占位符。我们将通过一个简单的示例来了解它是如何工作的，然后深入研究一些实际用途。","code":""},{"path":"action-dynamic.html","id":"dynamic-basics","chapter":"6 Dynamic UI","heading":"6.3.1 Getting started","text":"让我们从一个简单的 app 开始，该 app 动态创建一个输入控件，并通过其他两个输入来控制类型和标签。\n生成的 app 如 Figure 6.8 所示。\nFigure 6.8: 加载 app（左），然后将类型更改为数字（中），然后将标签更改为 ‘label’。 See live https://hadley.shinyapps.io/ms-render-simple.\n如果您自己运行此代码，您会注意到 app 加载后需要不到一秒的时间才会出现。\n这是因为它是响应式的：app 必须加载、触发响应式事件，该事件调用 server 函数，生成要插入到页面中的 HTML。\n这是 renderUI() 的缺点之一；过度依赖它可能会导致用户界面滞后。\n为了获得良好的性能，请使用本章前面描述的技术尽可能多地保持用户界面的固定。这种方法还有另一个问题：当您更改控件时，您会丢失当前选择的值。\n维护现有状态是使用代码创建 UI 的一大挑战。\n这就是有选择地显示和隐藏 UI 是一种更好的方法（如果它适合您）的原因之一 — 因为您没有销毁和重新创建控件，因此不需要执行任何操作来保留值。\n但是，在许多情况下，我们可以通过将新输入的值设置为现有控件的当前值来解决问题：isolate() 的使用很重要。\n我们将回到它在 Section ?? 中的作用，但这里它确保我们不会创建响应式依赖关系，这会导致每次 input$dynamic 更改时重新运行此代码（每当用户修改值时就会发生这种情况）。我们只希望它在 input$type 或 input$label 更改时更改。","code":"\nui <- fluidPage(\n  textInput(\"label\", \"label\"),\n  selectInput(\"type\", \"type\", c(\"slider\", \"numeric\")),\n  uiOutput(\"numeric\")\n)\nserver <- function(input, output, session) {\n  output$numeric <- renderUI({\n    if (input$type == \"slider\") {\n      sliderInput(\"dynamic\", input$label, value = 0, min = 0, max = 10)\n    } else {\n      numericInput(\"dynamic\", input$label, value = 0, min = 0, max = 10) \n    }\n  })\n}\nserver <- function(input, output, session) {\n  output$numeric <- renderUI({\n    value <- isolate(input$dynamic)\n    if (input$type == \"slider\") {\n      sliderInput(\"dynamic\", input$label, value = value, min = 0, max = 10)\n    } else {\n      numericInput(\"dynamic\", input$label, value = value, min = 0, max = 10)\n    }\n  })\n}"},{"path":"action-dynamic.html","id":"multiple-controls","chapter":"6 Dynamic UI","heading":"6.3.2 Multiple controls","text":"当您生成任意数量或类型的控件时，动态 UI 最有用。\n这意味着您将使用代码生成 UI，我建议使用函数式编程来完成此类任务。\n在这里，我将使用 purrr::map() 和 purrr::reduce()，但您当然可以对基本 lapply() 和 Reduce() 函数执行相同的操作。如果您不熟悉函数式编程的 map() 和 reduce()，您可能需要在继续之前先阅读一下 Functional programming。\n我们还将在 Chapter ?? 中回到这个想法。\n这些都是复杂的想法，所以如果您第一次阅读时没有理解，请不要紧张。为了具体说明这一点，假设您希望用户能够提供他们自己的调色板。\n他们首先会指定需要多少种颜色，然后为每种颜色提供一个值。\nui 非常简单：我们有一个 numericInput() 来控制输入数量，一个 uiOutput() 用来生成生成的文本框，还有一个 textOutput() 来证明我们已经将所有内容正确地组合在一起。server 函数很短，但包含一些重要的想法：我使用响应式 col_names() 来存储我将要生成的每个颜色输入的名称。我使用响应式 col_names() 来存储我将要生成的每个颜色输入的名称。然后，我使用 map() 创建一个 textInput() 列表，每个文本输入对应 col_names() 中的每个名称。\nrenderUI() 然后获取此 HTML 组件列表并将其添加到 UI。然后，我使用 map() 创建一个 textInput() 列表，每个文本输入对应 col_names() 中的每个名称。\nrenderUI() 然后获取此 HTML 组件列表并将其添加到 UI。我需要使用一种新技巧来访问输入值的值。\n到目前为止，我们总是使用 $ 访问输入的组成部分，例如 input$col1。\n但这里我们有字符向量中的输入名称，例如 var <- \"col1\"。\n$ 在这种情况下不再起作用，因此我们需要切换到 [[，即 input[[var]]。我需要使用一种新技巧来访问输入值的值。\n到目前为止，我们总是使用 $ 访问输入的组成部分，例如 input$col1。\n但这里我们有字符向量中的输入名称，例如 var <- \"col1\"。\n$ 在这种情况下不再起作用，因此我们需要切换到 [[，即 input[[var]]。我使用 map_chr() 将所有值收集到字符向量中，并将其显示在 output$palette 中。\n不幸的是，在浏览器渲染新输入之前，有一段短暂的时间，它们的值为 NULL。\n这会导致 map_chr() 出错，我们通过使用方便的 %||% 函数来修复该错误：只要左侧为 NULL，它就会返回右侧。我使用 map_chr() 将所有值收集到字符向量中，并将其显示在 output$palette 中。\n不幸的是，在浏览器渲染新输入之前，有一段短暂的时间，它们的值为 NULL。\n这会导致 map_chr() 出错，我们通过使用方便的 %||% 函数来修复该错误：只要左侧为 NULL，它就会返回右侧。您可以在 Figure 6.9 中看到结果。\nFigure 6.9: 加载时的 app（左），将 n 设置为 3（中），然后输入一些颜色（右）。 See live https://hadley.shinyapps.io/ms-render-palette.\n如果您运行此 app，您会发现一个非常烦人的行为：每当您更改颜色数量时，您输入的所有数据都会消失。\n我们可以使用与之前相同的技术来解决此问题：将 value 设置为（isolated）当前值。\n我还将调整外观，使其看起来更好一些，包括在绘图中显示选定的颜色。\n示例屏幕截图如 Figure 6.10 所示。\nFigure 6.10: 填充彩虹颜色（左），然后将颜色数量减少到 3（右）；请注意，现有颜色将被保留。 See live https://hadley.shinyapps.io/ms-render-palette-full.\n","code":"\nlibrary(purrr)\nui <- fluidPage(\n  numericInput(\"n\", \"Number of colours\", value = 5, min = 1),\n  uiOutput(\"col\"),\n  textOutput(\"palette\")\n)\nserver <- function(input, output, session) {\n  col_names <- reactive(paste0(\"col\", seq_len(input$n)))\n  \n  output$col <- renderUI({\n    map(col_names(), ~ textInput(.x, NULL))\n  })\n  \n  output$palette <- renderText({\n    map_chr(col_names(), ~ input[[.x]] %||% \"\")\n  })\n}\nui <- fluidPage(\n  sidebarLayout(\n    sidebarPanel(\n      numericInput(\"n\", \"Number of colours\", value = 5, min = 1),\n      uiOutput(\"col\"),\n    ),\n    mainPanel(\n      plotOutput(\"plot\")  \n    )\n  )\n)\n\nserver <- function(input, output, session) {\n  col_names <- reactive(paste0(\"col\", seq_len(input$n)))\n  \n  output$col <- renderUI({\n    map(col_names(), ~ textInput(.x, NULL, value = isolate(input[[.x]])))\n  })\n  \n  output$plot <- renderPlot({\n    cols <- map_chr(col_names(), ~ input[[.x]] %||% \"\")\n    # convert empty inputs to transparent\n    cols[cols == \"\"] <- NA\n    \n    barplot(\n      rep(1, length(cols)), \n      col = cols,\n      space = 0, \n      axes = FALSE\n    )\n  }, res = 96)\n}"},{"path":"action-dynamic.html","id":"dynamic-filter","chapter":"6 Dynamic UI","heading":"6.3.3 Dynamic filtering","text":"为了结束本章，我将创建一个 app，让您可以动态过滤任何数据框。\n每个数字变量将获得一个范围滑块，每个因子变量将获得多项选择，因此（例如）如果数据框具有三个数字变量和两个因子，则 app 将具有三个滑块和两个选择框。我将从一个为单个变量创建 UI 的函数开始。\n它将返回数字输入的范围滑块、因子输入的多重选择以及所有其他类型的 NULL（无）。然后，我将编写与此函数等效的 server 端：它接受输入控件的变量和值，并返回一个逻辑向量，说明是否包含每个观察结果。\n使用逻辑向量可以轻松组合多个列的结果。然后，我可以“手动”使用这些函数为 iris 数据集生成一个简单的过滤 UI：\nFigure 6.11: iris 数据集的简单过滤器接口\n您可能会注意到，我厌倦了复制和粘贴，因此该 app 仅适用于三列。\n我可以通过使用一些函数式编程使其适用于所有列：在 ui 中使用 map() 为每个变量生成一个控件。在 ui 中使用 map() 为每个变量生成一个控件。在 server() 中，我使用 map() 为每个变量生成选择向量。\n然后，我使用 reduce() 获取每个变量的逻辑向量，并通过将每个向量组合成一个逻辑向量。在 server() 中，我使用 map() 为每个变量生成选择向量。\n然后，我使用 reduce() 获取每个变量的逻辑向量，并通过将每个向量组合成一个逻辑向量。再次强调，如果您不完全了解这里发生的情况，请不要太担心。\n主要的收获是，一旦掌握了函数式编程，您就可以编写非常简洁的代码来生成复杂的动态 apps。\nFigure 6.12: 使用函数式编程为 iris 数据集构建过滤 app。\n从这里开始，这是一个适用于任何数据框的简单概括。\n在这里，我将使用数据集包中的数据框来说明它，但是您可以轻松想象如何将其扩展到用户上传的数据。\n结果如 Figure 6.13 所示。\nFigure 6.13: 根据所选数据集的字段自动生成的动态用户界面。 See live https://hadley.shinyapps.io/ms-filtering-final.\n","code":"\nmake_ui <- function(x, var) {\n  if (is.numeric(x)) {\n    rng <- range(x, na.rm = TRUE)\n    sliderInput(var, var, min = rng[1], max = rng[2], value = rng)\n  } else if (is.factor(x)) {\n    levs <- levels(x)\n    selectInput(var, var, choices = levs, selected = levs, multiple = TRUE)\n  } else {\n    # Not supported\n    NULL\n  }\n}\nfilter_var <- function(x, val) {\n  if (is.numeric(x)) {\n    !is.na(x) & x >= val[1] & x <= val[2]\n  } else if (is.factor(x)) {\n    x %in% val\n  } else {\n    # No control, so don't filter\nTRUE\n}\n}\nui <- fluidPage(\n  sidebarLayout(\n    sidebarPanel(\n      make_ui(iris$Sepal.Length, \"Sepal.Length\"),\n      make_ui(iris$Sepal.Width, \"Sepal.Width\"),\n      make_ui(iris$Species, \"Species\")\n    ),\n    mainPanel(\n      tableOutput(\"data\")\n    )\n  )\n)\nserver <- function(input, output, session) {\n  selected <- reactive({\n    filter_var(iris$Sepal.Length, input$Sepal.Length) &\n      filter_var(iris$Sepal.Width, input$Sepal.Width) &\n      filter_var(iris$Species, input$Species)\n  })\n  \n  output$data <- renderTable(head(iris[selected(), ], 12))\n}\nui <- fluidPage(\n  sidebarLayout(\n    sidebarPanel(\n      map(names(iris), ~ make_ui(iris[[.x]], .x))\n    ),\n    mainPanel(\n      tableOutput(\"data\")\n    )\n  )\n)\nserver <- function(input, output, session) {\n  selected <- reactive({\n    each_var <- map(names(iris), ~ filter_var(iris[[.x]], input[[.x]]))\n    reduce(each_var, ~ .x & .y)\n  })\n  \n  output$data <- renderTable(head(iris[selected(), ], 12))\n}\ndfs <- keep(ls(\"package:datasets\"), ~ is.data.frame(get(.x, \"package:datasets\")))\n\nui <- fluidPage(\n  sidebarLayout(\n    sidebarPanel(\n      selectInput(\"dataset\", label = \"Dataset\", choices = dfs),\n      uiOutput(\"filter\")\n    ),\n    mainPanel(\n      tableOutput(\"data\")\n    )\n  )\n)\nserver <- function(input, output, session) {\n  data <- reactive({\n    get(input$dataset, \"package:datasets\")\n  })\n  vars <- reactive(names(data()))\n  \n  output$filter <- renderUI(\n    map(vars(), ~ make_ui(data()[[.x]], .x))\n  )\n  \n  selected <- reactive({\n    each_var <- map(vars(), ~ filter_var(data()[[.x]], input[[.x]]))\n    reduce(each_var, `&`)\n  })\n  \n  output$data <- renderTable(head(data()[selected(), ], 12))\n}"},{"path":"action-dynamic.html","id":"dialog-boxes","chapter":"6 Dynamic UI","heading":"6.3.4 Dialog boxes","text":"在我们结束之前，想提一下相关的技术：对话框。\n您已经在 Section ?? 中看到了它们，其中对话框的内容是固定的文本字符串。\n但由于 modalDialog() 是从 server 函数内部调用的，因此您实际上可以以与 renderUI() 相同的方式动态生成内容。\n如果您想迫使用户在继续常规应用程序流程之前做出某些决定，那么这是一项非常有用的技术。","code":""},{"path":"action-dynamic.html","id":"exercises-7","chapter":"6 Dynamic UI","heading":"6.3.5 Exercises","text":"根据本节中的初始示例采用这个非常简单的 app：您如何使用动态可见性来实现它？\n如果您实现动态可见性，那么当您更改控件时如何保持值同步？解释一下这个 app 是如何工作的。\n为什么当您第二次单击输入密码按钮时密码消失了？在 Section 6.3.1 的 app 中，如果从 value <- isolate(input$dynamic) 中删除 isolate()，会发生什么情况？在 Section 6.3.1 的 app 中，如果从 value <- isolate(input$dynamic) 中删除 isolate()，会发生什么情况？添加对日期和日期时间列 make_ui() 和 filter_var() 的支持。添加对日期和日期时间列 make_ui() 和 filter_var() 的支持。（Advanced）如果您了解 S3 OOP 系统，请考虑如何使用泛型函数替换 make_ui() 和 filter_var() 中的 块。（Advanced）如果您了解 S3 OOP 系统，请考虑如何使用泛型函数替换 make_ui() 和 filter_var() 中的 块。","code":"\nui <- fluidPage(\n  selectInput(\"type\", \"type\", c(\"slider\", \"numeric\")),\n  uiOutput(\"numeric\")\n)\nserver <- function(input, output, session) {\n  output$numeric <- renderUI({\n    if (input$type == \"slider\") {\n      sliderInput(\"n\", \"n\", value = 0, min = 0, max = 100)\n    } else {\n      numericInput(\"n\", \"n\", value = 0, min = 0, max = 100)  \n    }\n  })\n}\nui <- fluidPage(\n  actionButton(\"go\", \"Enter password\"),\n  textOutput(\"text\")\n)\nserver <- function(input, output, session) {\n  observeEvent(input$go, {\n    showModal(modalDialog(\n      passwordInput(\"password\", NULL),\n      title = \"Please enter your password\"\n    ))\n  })\n  \n  output$text <- renderText({\n    if (!isTruthy(input$password)) {\n      \"No password\"\n    } else {\n      \"Password entered\"\n    }\n  })\n}"},{"path":"action-dynamic.html","id":"summary-5","chapter":"6 Dynamic UI","heading":"6.4 Summary","text":"在阅读本章之前，您只能在运行 server 函数之前静态创建用户界面。\n现在您已经学习了如何修改用户界面并完全重新创建它以响应用户操作。\n动态用户界面将极大地增加 app 的复杂性，因此，如果您发现自己很难调试正在发生的内容，请不要感到惊讶。\n始终记住使用最简单的技术来解决您的问题，然后回到 Section 5.2 中的调试建议。下一章转向讨论书（bookmarking），使与其他人共享 app 的当前状态成为可能。","code":""}]
