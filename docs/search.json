[{"path":"index.html","id":"welcome","chapter":"Welcome","heading":"Welcome","text":"这是 Mastering Shiny 的在线版本，该书目前正在早期开发中，预计由 O’Reilly Media 于 2020 年底发行。Shiny 是一个使用 R 代码创建 Web 应用程序的框架。它的设计主要考虑了数据科学家的需求，为此，您可以在不了解 HTML、CSS 或 JavaScript 的情况下创建相当复杂的 Shiny 应用程序。另一方面，Shiny 并不限制您创建琐碎或预制的应用程序：它的用户界面组件可以轻松自定义或扩展，并且它的服务器使用反应式编程来让您创建您想要的任何类型的后端逻辑。\nShiny 的设计初衷是让您在刚开始使用时感觉非常简单，但您越深入地了解它的工作原理，您就越会意识到它是由通用构建块构建而成，而这些构建块背后都有强大的软件工程原理。如今，Shiny 的应用领域和行业几乎与 R 本身一样多。\n它在学术界被用作统计概念的教学工具，一种让本科生对学习编写代码感到兴奋的方式，一种炫耀新颖统计方法或模型的引人注目的媒介。\n大型制药公司使用它来加速药物开发过程中科学家和分析师之间的合作。\n硅谷科技公司使用它来设置包含高级分析的实时指标仪表盘。本书旨在帮助您从对 Shiny 一无所知到成为一名专家开发人员，能够编写仍然可维护且高性能的大型复杂应用程序。您将深入了解 Shiny 背后的反应式编程模型，并构建一个包含有用技术的工具箱来解决常见的应用程序挑战。","code":""},{"path":"index.html","id":"license","chapter":"Welcome","heading":"License","text":"book licensed Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.code samples book licensed Creative Commons CC0 1.0 Universal (CC0 1.0), .e. public domain.","code":""},{"path":"preface.html","id":"preface","chapter":"Preface","heading":"Preface","text":"","code":""},{"path":"preface.html","id":"what-is-shiny","chapter":"Preface","heading":"0.1 What is Shiny?","text":"如果您以前从未使用过 Shiny，欢迎！\nShiny 是一个 R 包，可让您轻松创建丰富的交互式 Web 应用程序。\nShiny 允许您在 R 中进行工作并通过网络浏览器公开它，以便任何人都可以使用它。\nShiny 让您可以轻松地以最少的痛苦来生成精美的 Web 应用程序，从而使您看起来很棒。在过去，创建 Web 应用程序对于大多数 R 用户来说都很困难，因为：您需要深入了解 HTML、CSS 和 JavaScript 等 Web 技术。您需要深入了解 HTML、CSS 和 JavaScript 等 Web 技术。制作复杂的交互式应用程序需要仔细分析交互流，以确保当输入更改时，仅更新相关的输出。制作复杂的交互式应用程序需要仔细分析交互流，以确保当输入更改时，仅更新相关的输出。Shiny 使 R 程序员可以通过以下方式更轻松地创建 Web 应用程序：提供一组精心策划的用户界面（简称 UI）功能，用于生成常见任务所需的 HTML、CSS 和 JavaScript。\n这意味着您不需要了解 HTML/CSS/JavaScript 的详细信息，除非您想要超越 Shiny 为您提供的基础。提供一组精心策划的用户界面（简称 UI）功能，用于生成常见任务所需的 HTML、CSS 和 JavaScript。\n这意味着您不需要了解 HTML/CSS/JavaScript 的详细信息，除非您想要超越 Shiny 为您提供的基础。引入一种称为反应式编程（reactive programming）的新编程风格，它自动跟踪代码片段的依赖关系。\n这意味着每当输入发生变化时，Shiny 都可以自动找出如何做最少的工作来更新所有相关的输出。引入一种称为反应式编程（reactive programming）的新编程风格，它自动跟踪代码片段的依赖关系。\n这意味着每当输入发生变化时，Shiny 都可以自动找出如何做最少的工作来更新所有相关的输出。人们使用 Shiny 来：创建跟踪重要的高级性能指标的仪表盘，同时促进深入了解需要更多调查的指标。创建跟踪重要的高级性能指标的仪表盘，同时促进深入了解需要更多调查的指标。用交互式应用程序替换数百页 PDF，让用户可以跳转到他们关心的结果的确切部分。用交互式应用程序替换数百页 PDF，让用户可以跳转到他们关心的结果的确切部分。通过信息丰富的可视化和交互式敏感性分析，向非技术受众传达复杂的模型。通过信息丰富的可视化和交互式敏感性分析，向非技术受众传达复杂的模型。为常见工作流程提供自助数据分析，用 Shiny 应用程序取代电子邮件请求，允许人们上传自己的数据并执行标准分析。\n您可以为没有编程技能的用户提供复杂的 R 分析。为常见工作流程提供自助数据分析，用 Shiny 应用程序取代电子邮件请求，允许人们上传自己的数据并执行标准分析。\n您可以为没有编程技能的用户提供复杂的 R 分析。创建用于教授统计学和数据科学概念的交互式演示，使学习者能够调整输入并观察分析中这些变化的下游影响。创建用于教授统计学和数据科学概念的交互式演示，使学习者能够调整输入并观察分析中这些变化的下游影响。简而言之，Shiny 使您能够将一些 R 超能力传递给任何可以使用网络的人。","code":""},{"path":"preface.html","id":"who-should-read-this-book","chapter":"Preface","heading":"0.2 Who should read this book?","text":"本书针对两种主要读者：有兴趣了解 Shiny 以便将他们的分析转化为交互式 Web 应用程序的 R 用户。\n为了充分利用本书，您应该能够熟练地使用 R 进行数据分析，并且至少应该编写一些函数。有兴趣了解 Shiny 以便将他们的分析转化为交互式 Web 应用程序的 R 用户。\n为了充分利用本书，您应该能够熟练地使用 R 进行数据分析，并且至少应该编写一些函数。现有的 Shiny 用户希望提高对 Shiny 基础理论的了解，以便更快、更轻松地编写更高质量的应用程序。\n如果您的应用程序开始变得越来越大并且您开始在管理复杂性方面遇到问题，那么您应该会发现这本书特别有帮助。现有的 Shiny 用户希望提高对 Shiny 基础理论的了解，以便更快、更轻松地编写更高质量的应用程序。\n如果您的应用程序开始变得越来越大并且您开始在管理复杂性方面遇到问题，那么您应该会发现这本书特别有帮助。","code":""},{"path":"preface.html","id":"what-will-you-learn","chapter":"Preface","heading":"0.3 What will you learn?","text":"本书分为四个部分：在 “Getting started” 部分，您将学习 Shiny 的基础知识，以便您可以尽快启动并运行。\n您将了解应用程序结构的基础知识、有用的 UI 组件以及响应式编程的基础知识。在 “Getting started” 部分，您将学习 Shiny 的基础知识，以便您可以尽快启动并运行。\n您将了解应用程序结构的基础知识、有用的 UI 组件以及响应式编程的基础知识。“Shiny action” 部分建立在帮助您解决常见问题的基础知识之上，包括向用户提供反馈、上传和下载数据、使用代码生成 UI、减少代码重复以及使用 Shiny 对 tidyverse 进行编程。“Shiny action” 部分建立在帮助您解决常见问题的基础知识之上，包括向用户提供反馈、上传和下载数据、使用代码生成 UI、减少代码重复以及使用 Shiny 对 tidyverse 进行编程。在 “Mastering reactivity” 部分，您将深入了解反应式编程的理论和实践，这是 Shiny 的编程范例。\n如果您是现有的 Shiny 用户，您将从本章中获得最大的价值，因为它将为您提供坚实的理论基础，使您能够创建专门针对您的问题定制的新工具。在 “Mastering reactivity” 部分，您将深入了解反应式编程的理论和实践，这是 Shiny 的编程范例。\n如果您是现有的 Shiny 用户，您将从本章中获得最大的价值，因为它将为您提供坚实的理论基础，使您能够创建专门针对您的问题定制的新工具。最后，在 “Best practices” 部分，我们将完成对使您的 Shiny 应用程序在生产中良好运行的有用技术的调查。\n您将学习如何将复杂的应用程序分解为函数和模块，如何使用包来组织代码，如何测试代码以确保其正确，以及如何衡量和提高性能。最后，在 “Best practices” 部分，我们将完成对使您的 Shiny 应用程序在生产中良好运行的有用技术的调查。\n您将学习如何将复杂的应用程序分解为函数和模块，如何使用包来组织代码，如何测试代码以确保其正确，以及如何衡量和提高性能。","code":""},{"path":"preface.html","id":"what-wont-you-learn","chapter":"Preface","heading":"0.4 What won’t you learn?","text":"本书的重点是制作有效的 Shiny 应用程序并理解反应式的基本理论。\n我将尽力展示数据科学、R 编程和软件工程的最佳实践，但您需要其他参考资料来掌握这些重要技能。\n如果您喜欢我在本书中的写作，您可能会喜欢我关于这些主题的其他书籍：R Data Science、Advanced R 和 R Packages。还有一些特定于 Shiny 的重要主题我没有涉及：本书仅涵盖内置的用户界面工具包。\n这并没有提供最性感的设计，但它很容易学习并且可以让你走得很远。\n如果您有其他需求（或者只是对默认设置感到厌倦），还有许多其他软件包可以提供替代前端。\n参见 Section ?? 获取更多细节。本书仅涵盖内置的用户界面工具包。\n这并没有提供最性感的设计，但它很容易学习并且可以让你走得很远。\n如果您有其他需求（或者只是对默认设置感到厌倦），还有许多其他软件包可以提供替代前端。\n参见 Section ?? 获取更多细节。部署 Shiny 应用程序。\n将 Shiny “投入生产” 超出了本书的讨论范围，因为每个公司的情况差异很大，而且其中大部分与 R 无关（大多数挑战往往是文化或组织方面的，而不是技术方面的）。\n如果您在生产中不熟悉 Shiny，我建议您从 Joe Cheng’s 2019 rstudio::conf keynote: https://rstudio.com/resources/rstudioconf-2019/shiny--production-principles-practices--tools/ 开始。\n这将为您提供基本情况，广泛讨论将 Shiny 投入生产需要什么以及如何克服您可能面临的一些挑战。\n完成此操作后，请访问 RStudio Connect website，了解用于在公司内部署应用程序的 RStudio 产品，并访问 Shiny website了解其他常见部署场景。部署 Shiny 应用程序。\n将 Shiny “投入生产” 超出了本书的讨论范围，因为每个公司的情况差异很大，而且其中大部分与 R 无关（大多数挑战往往是文化或组织方面的，而不是技术方面的）。\n如果您在生产中不熟悉 Shiny，我建议您从 Joe Cheng’s 2019 rstudio::conf keynote: https://rstudio.com/resources/rstudioconf-2019/shiny--production-principles-practices--tools/ 开始。\n这将为您提供基本情况，广泛讨论将 Shiny 投入生产需要什么以及如何克服您可能面临的一些挑战。\n完成此操作后，请访问 RStudio Connect website，了解用于在公司内部署应用程序的 RStudio 产品，并访问 Shiny website了解其他常见部署场景。","code":""},{"path":"preface.html","id":"prerequisites","chapter":"Preface","heading":"0.5 Prerequisites","text":"在我们继续之前，请确保您拥有本书所需的所有软件：R：如果你还没有安装 R，你可能读错书了；我假设您对本书中的 R 有基本的了解。\n如果您想学习如何使用 R，我会推荐我的 R Data Science，它旨在帮助您轻松上手并运行 R。R：如果你还没有安装 R，你可能读错书了；我假设您对本书中的 R 有基本的了解。\n如果您想学习如何使用 R，我会推荐我的 R Data Science，它旨在帮助您轻松上手并运行 R。RStudio：RStudio 是一个免费的开源 R 集成开发环境 (IDE)。\n虽然您可以在任何 R 环境（包括 R GUI 和 ESS）中编写和使用 Shiny 应用程序，但 RStudio 有一些专门用于创作、调试和部署 Shiny 应用程序的出色功能。\n我们建议您尝试一下，但并不需要使用 Shiny 或本书即可获得成功。\n您可以从 https://www.rstudio.com/products/rstudio/download 下载 RStudio Desktop。RStudio：RStudio 是一个免费的开源 R 集成开发环境 (IDE)。\n虽然您可以在任何 R 环境（包括 R GUI 和 ESS）中编写和使用 Shiny 应用程序，但 RStudio 有一些专门用于创作、调试和部署 Shiny 应用程序的出色功能。\n我们建议您尝试一下，但并不需要使用 Shiny 或本书即可获得成功。\n您可以从 https://www.rstudio.com/products/rstudio/download 下载 RStudio Desktop。R packages：本书使用了一堆 R 包。\n您可以通过运行以下命令一次性安装它们：\n\ninstall.packages(c(\n  \"gapminder\", \"ggforce\", \"gh\", \"globals\", \"openintro\", \"profvis\", \n  \"RSQLite\", \"shiny\", \"shinycssloaders\", \"shinyFeedback\", \n  \"shinythemes\", \"testthat\", \"thematic\", \"tidyverse\", \"vroom\", \n  \"waiter\", \"xml2\", \"zeallot\" \n))\n如果您过去下载过 Shiny，请确保您的版本至少为 1.6.0。R packages：本书使用了一堆 R 包。\n您可以通过运行以下命令一次性安装它们：如果您过去下载过 Shiny，请确保您的版本至少为 1.6.0。","code":"\ninstall.packages(c(\n  \"gapminder\", \"ggforce\", \"gh\", \"globals\", \"openintro\", \"profvis\", \n  \"RSQLite\", \"shiny\", \"shinycssloaders\", \"shinyFeedback\", \n  \"shinythemes\", \"testthat\", \"thematic\", \"tidyverse\", \"vroom\", \n  \"waiter\", \"xml2\", \"zeallot\" \n))"},{"path":"preface.html","id":"acknowledgements","chapter":"Preface","heading":"0.6 Acknowledgements","text":"这本书是公开撰写的，完成后各章节会在 Twitter 上发布广告。\n这确实是社区的努力：许多人阅读草稿、修正拼写错误、提出改进建议并贡献内容。\n如果没有这些贡献者，这本书就不会这么好，我非常感谢他们的帮助。big thank 83 people contributed specific improvements via GitHub pull requests (alphabetical order username): Adam Pearce (@1wheel), Adi Sarid (@adisarid), Alexandros Melemenidis (@alex-m-ffm), Anton Klåvus (@antonvsdata), Betsy Rosalen (@betsyrosalen), Michael Beigelmacher (@brooklynbagel), Bryan Smith (@BSCowboy), c1au6io_hh (@c1au6i0), @canovasjm, Chris Beeley (@ChrisBeeley), @chsafouane, Chuliang Xiao (@ChuliangXiao), Conor Neilson (@condwanaland), @d-edison, Dean Attali (@daattali), DanielDavid521 (@Danieldavid521), David Granjon (@DivadNojnarg), Eduardo Vásquez (@edovtp), Emil Hvitfeldt (@EmilHvitfeldt), Emilio (@emilopezcano), Emily Riederer (@emilyriederer), Eric Simms (@esimms999), Federico Marini (@federicomarini), Frederik Kok Hansen (@fkoh111), Frans van Dunné (@FvD), Giorgio Comai (@giocomai), Hedley (@heds1), Henning (@henningsway), Hlynur (@hlynurhallgrims), @hsm207, @jacobxk, James Pooley (@jamespooley), Joe Cheng (@jcheng5), Julien Colomb (@jcolomb), Juan C Rodriguez (@jcrodriguez1989), Jennifer (Jenny) Bryan (@jennybc), Jim Hester (@jimhester), Joachim Gassen (@joachim-gassen), Jon Calder (@jonmcalder), Jonathan Carroll (@jonocarroll), Julian Stanley (@julianstanley), @jyuu, @kaanpekel, Karandeep Singh (@kdpsingh), Robert Kirk DeLisle (@KirkDCO), Elaine (@loomalaine), Malcolm Barrett (@malcolmbarrett), Marly Gotti (@marlycormar), Matthew Wilson (@MattW-Geospatial), Matthew T. Warkentin (@mattwarkentin), Mauro Lepore (@maurolepore), Maximilian Rohde (@maxdrohde), Matthew Berginski (@mbergins), Michael Dewar (@michael-dewar), Mine Cetinkaya-Rundel (@mine-cetinkaya-rundel), Maria Paula Caldas (@mpaulacaldas), nthobservation (@nthobservation), Pietro Monticone (@pitmonticone), psychometrician (@psychometrician), Ram Thapa (@raamthapa), Janko Thyson (@rappster), Rebecca Janis (@rbjanis), Tom Palmer (@remlapmot), Russ Hyde (@russHyde), Barret Schloerke (@schloerke), Scott (@scottyd22), Matthew Sedaghatfar (@sedaghatfar), Shixiang Wang (@ShixiangWang), Praer (Suthira Owlarn) (@sowla), Sébastien Rochette (@statnmap), @stevensbr, André Calero Valdez (@Sumidu), Tanner Stauss (@tmstauss), Tony Fujs (@tonyfujs), Stefan Moog (@trekonom), Jeff Allen (@trestletech), Trey Gilliland (@treygilliland), Albrecht (@Tungurahua), Valeri Voev (@ValeriVoev), Vickus (@Vickusr), William Doane (@WilDoane), 黄湘云 (@XiangyunHuang), gXcloud (@xwydq).","code":"#> Warning: package 'dplyr' was built under R version 4.2.3"},{"path":"preface.html","id":"colophon","chapter":"Preface","heading":"0.7 Colophon","text":"本书是使用 bookdown 在 RStudio 中编写的。\n该网站由 netlify 托管，并在 Github Actions 每次提交后自动更新。完整的源代码可以从 GitHub 获取。本书的这个版本是使用 R 版本 R version 4.2.0 (2022-04-22 ucrt) 和以下软件包构建的：","code":""},{"path":"basic-intro.html","id":"basic-intro","chapter":"Introduction","heading":"Introduction","text":"接下来四章的目标是让您尽快编写 Shiny 应用程序。\n在 Chapter 1 中，我将从小而完整的开始，向您展示应用程序的所有主要部分以及它们如何组合在一起。\n然后在 Chapters 2 和 3 您将开始深入了解 Shiny 应用程序的两个主要部分的详细信息：前端（用户在浏览器中看到的内容）和后端（使其全部正常工作的代码）。\n我们将在 Chapter 4 结束，通过案例研究来帮助巩固您迄今为止学到的概念。","code":""},{"path":"basic-app.html","id":"basic-app","chapter":"1 Your first Shiny app","heading":"1 Your first Shiny app","text":"","code":""},{"path":"basic-app.html","id":"introduction","chapter":"1 Your first Shiny app","heading":"1.1 Introduction","text":"在本章中，我们将创建一个简单的 Shiny app。\n我将首先向您展示 Shiny app 所需的最小样板，然后您将学习如何启动和停止它。\n接下来，您将学习每个 Shiny app 的两个关键组件：定义 app 外观的 UI（user interface 的缩写），和定义 app 工作方式的 server function。\nShiny 使用响应式编程（reactive programming）在输入变化时自动更新输出，因此我们将通过学习 Shiny app 的第三个重要组件来结束本章：响应式表达式（reactive expressions）。如果您尚未安装 Shiny，请立即安装：如果您已经安装了 Shiny，请使用 packageVersion(\"shiny\") 检查您是否拥有 1.5.0 或更高版本。然后加载当前的 R 会话：","code":"\ninstall.packages(\"shiny\")\nlibrary(shiny)"},{"path":"basic-app.html","id":"create-app","chapter":"1 Your first Shiny app","heading":"1.2 Create app directory and file","text":"有多种方法可以创建 Shiny app。\n最简单的方法是为您的 app 创建一个新目录，并在其中放置一个名为 app.R 的文件。\n这个 app.R 文件将用于告诉 Shiny 您的 app 应该如何显示以及它应该如何运行。通过创建一个新目录并添加一个如下所示的 app.R 文件来尝试一下：这是一个完整但微不足道的 Shiny app！\n仔细观察上面的代码，我们的 app.R 做了四件事：它调用 library(shiny) 来加载 shiny 包。它调用 library(shiny) 来加载 shiny 包。它定义了用户界面，即人类与之交互的 HTML 网页。\n在本例中，它是一个包含 “Hello, world!” 字样的页面。它定义了用户界面，即人类与之交互的 HTML 网页。\n在本例中，它是一个包含 “Hello, world!” 字样的页面。它通过定义 server 函数来指定我们 app 的行为。\n它目前是空的，所以我们的应用程序不执行任何操作，但我们很快就会回来重新讨论这个问题。它通过定义 server 函数来指定我们 app 的行为。\n它目前是空的，所以我们的应用程序不执行任何操作，但我们很快就会回来重新讨论这个问题。它执行 shinyApp(ui, server) 来从 UI 和 server 构建并启动 Shiny app。它执行 shinyApp(ui, server) 来从 UI 和 server 构建并启动 Shiny app。RStudio Tip: 在 RStudio 中创建一个新的 app 有两种便捷的方法：单击 File | New Project 创建一个新目录和一个包含基本 app 的 app.R 文件，然后选择 New Directory 和 Shiny Web Application。单击 File | New Project 创建一个新目录和一个包含基本 app 的 app.R 文件，然后选择 New Directory 和 Shiny Web Application。如果您已经创建了 app.R 文件，则可以通过键入 “shinyapp” 并按 Shift+Tab 快速添加 app 样板。如果您已经创建了 app.R 文件，则可以通过键入 “shinyapp” 并按 Shift+Tab 快速添加 app 样板。","code":"\nlibrary(shiny)\nui <- fluidPage(\n  \"Hello, world!\"\n)\nserver <- function(input, output, session) {\n}\nshinyApp(ui, server)"},{"path":"basic-app.html","id":"running","chapter":"1 Your first Shiny app","heading":"1.3 Running and stopping","text":"您可以通过以下几种方式运行此 app：单击文档工具栏中的 Run App (Figure 1.1) 按钮。单击文档工具栏中的 Run App (Figure 1.1) 按钮。使用键盘快捷键：Cmd/Ctrl + Shift + Enter。使用键盘快捷键：Cmd/Ctrl + Shift + Enter。如果您不使用 RStudio，您可以 (source())1 整个文档，或者使用包含 app.R 的目录的路径调用 shiny::runApp()。如果您不使用 RStudio，您可以 (source())1 整个文档，或者使用包含 app.R 的目录的路径调用 shiny::runApp()。\nFigure 1.1: Run App 按钮位于源窗格的右上角。\n选择这些选项之一，并检查您是否看到与 Figure 1.2 中相同的 app。\n恭喜！\n您已经制作了第一个 Shiny app。\nFigure 1.2: 当您运行上面的代码时，您将看到一个非常基本的 shiny app\n在关闭 app 之前，请返回 RStudio 并查看 R console。\n你会注意到它说的是这样的：这告诉您可以找到您的 app 的 URL：127.0.0.1 是一个标准地址，表示“这台计算机”，3827 是一个随机分配的端口号（port）。\n您可以在任何兼容的2网络浏览器中输入该 URL 以打开你的 app 的另一个副本。另请注意 R 正忙：R 提示不可见，并且控制台工具栏显示停止标志图标。\n当 Shiny app 运行时，它会“阻止” R console。\n这意味着在 Shiny app 停止之前，您无法在 R console 上运行新命令。您可以使用以下任一选项停止 app 并返回对 console 的访问权限：单击 R console 工具栏上的停止标志图标。单击 R console 工具栏上的停止标志图标。单击 console，然后按 Esc（如果您不使用 RStudio，则按 Ctrl + C）。单击 console，然后按 Esc（如果您不使用 RStudio，则按 Ctrl + C）。关闭 Shiny app 窗口。关闭 Shiny app 窗口。Shiny app 开发的基本工作流程是编写一些代码，启动 app，使用 app，编写更多代码，然后重复。\n如果您使用的是 RStudio，您甚至不需要停止并重新启动应用程序即可查看更改 — 您可以按工具箱中的 Reload app 按钮或使用 Cmd/Ctrl + Shift + Enter 键盘快捷键。\n我将在 Chapter ?? 中介绍其他工作流程模式。","code":"\n#> Listening on http://127.0.0.1:3827"},{"path":"basic-app.html","id":"adding-ui","chapter":"1 Your first Shiny app","heading":"1.4 Adding UI controls","text":"接下来，我们将向 UI 添加一些输入和输出，这样它就不会那么小了。\n我们将制作一个非常简单的 app，向您显示 datasets 包中包含的所有内置 data frames。将您的 ui 替换为以下代码：此示例使用四个新函数：fluidPage() 是一个 layout function，用于设置页面的基本视觉结构。\n您将在 Section ?? 中了解有关它们的更多信息。fluidPage() 是一个 layout function，用于设置页面的基本视觉结构。\n您将在 Section ?? 中了解有关它们的更多信息。selectInput() 是一个 input control，允许用户通过提供值（value）与 app 交互。\n在本例中，它是一个带有 “Dataset” 标签的选择框，可让您选择 R 附带的内置数据集之一。\n您将在 Section 2.2 中了解有关输入的更多信息。selectInput() 是一个 input control，允许用户通过提供值（value）与 app 交互。\n在本例中，它是一个带有 “Dataset” 标签的选择框，可让您选择 R 附带的内置数据集之一。\n您将在 Section 2.2 中了解有关输入的更多信息。verbatimTextOutput() 和 tableOutput() 是 output controls，它们告诉 Shiny 将渲染的输出放在哪里（我们稍后会介绍如何放置）。\nverbatimTextOutput() 显示代码，tableOutput() 显示表格。\n您将在 Section 2.3 中了解有关输出的更多信息。verbatimTextOutput() 和 tableOutput() 是 output controls，它们告诉 Shiny 将渲染的输出放在哪里（我们稍后会介绍如何放置）。\nverbatimTextOutput() 显示代码，tableOutput() 显示表格。\n您将在 Section 2.3 中了解有关输出的更多信息。布局函数、输入和输出有不同的用途，但它们本质上是相同的：它们都是生成 HTML 的奇特方法，如果您在 Shiny app 之外调用其中任何一个，您将看到 HTML 在控制台打印出来。\n不要害怕四处探索，看看这些不同的布局和控件在幕后是如何工作的。继续并再次运行该 app。\n现在您将看到 Figure 1.3，这是一个包含选择框的页面。\n我们只看到输入，看不到两个输出，因为我们还没有告诉 Shiny 输入和输出是如何关联的。\nFigure 1.3: datasets app UI\n","code":"\nui <- fluidPage(\n  selectInput(\"dataset\", label = \"Dataset\", choices = ls(\"package:datasets\")),\n  verbatimTextOutput(\"summary\"),\n  tableOutput(\"table\")\n)"},{"path":"basic-app.html","id":"server-function","chapter":"1 Your first Shiny app","heading":"1.5 Adding behaviour","text":"接下来，我们将通过在 server 函数中定义输出来使输出变得生动。Shiny 使用响应式编程使 apps 具有交互性。\n您将在 Chapter 3 中了解有关响应式编程的更多信息，但现在请注意，它涉及告诉 Shiny 如何执行计算，而不是命令 Shiny 实际执行计算。\n这就像给某人一个菜谱和要求他们给你做一个三明治之间的区别。我们将通过提供这些输出的“配方”来告诉 Shiny 如何在示例 app 中填写 summary 和 table 输出。\n将空的 server 函数替换为：赋值运算符 (<-) 的左侧，output$ID，表示您正在为具有该 ID 的 Shiny 输出提供配方。\n赋值的右侧使用特定的渲染函数（render function）来包装您提供的一些代码。\n每个 render{Type} 函数都旨在生成特定类型的输出（例如文本、表格和绘图），并且通常与 {type}Output 函数配对。\n例如，在此 app 中，renderPrint() 与 verbatimTextOutput() 配合使用，以显示固定宽度（逐字）文本的统计摘要，而 renderTable() 与 tableOutput() 配合使用，以在表格中显示输入数据。再次运行 app 并进行测试，观察更改输入时输出会发生什么情况。\nFigure 1.4 显示了打开 app 时应该看到的内容。\nFigure 1.4: 现在我们已经提供了连接输出和输入的 server function，我们有了一个功能齐全的 app\n请注意，每当您更改输入数据集时，摘要和表格都会更新。\n这种依赖关系是隐式创建的，因为我们在输出函数中引用了 input$dataset。\ninput$dataset 填充了带有 id dataset 的 UI 组件的当前值，并且每当该值发生变化时都会导致输出自动更新。\n这是响应式（reactivity）的本质：当输入发生变化时，输出会自动做出响应（重新计算）。","code":"\nserver <- function(input, output, session) {\n  output$summary <- renderPrint({\n    dataset <- get(input$dataset, \"package:datasets\")\n    summary(dataset)\n  })\n  \n  output$table <- renderTable({\n    dataset <- get(input$dataset, \"package:datasets\")\n    dataset\n  })\n}"},{"path":"basic-app.html","id":"reactive-expr","chapter":"1 Your first Shiny app","heading":"1.6 Reducing duplication with reactive expressions","text":"即使在这个简单的示例中，我们也有一些重复的代码：两个输出中都存在以下行。在每种编程中，重复代码都是不好的做法；它可能会造成计算浪费，更重要的是，它增加了维护或调试代码的难度。\n这在这里并不重要，但我想在一个非常简单的上下文中说明基本思想。不幸的是，这些方法在这里都不起作用，原因您将在 Section ?? 中了解，并且我们需要一种新机制：响应式表达式（reactive expressions）。您可以通过将代码块包装在 reactive({...}) 中并将其分配给变量来创建响应式表达式，然后通过像函数一样调用它来使用响应式表达式。\n但是，虽然看起来像是在调用函数，但响应式表达式有一个重要的区别：它仅在第一次调用时运行，然后缓存其结果，直到需要更新为止。我们可以更新我们的 server() 以使用响应式表达式，如下所示。\n该 app 的行为相同，但工作效率更高一些，因为它只需要检索数据集一次，而不是两次。我们将多次回到响应式编程，但即使具备输入、输出和响应式表达式的粗略知识，也可以构建非常有用的 Shiny apps！","code":"\ndataset <- get(input$dataset, \"package:datasets\")\nserver <- function(input, output, session) {\n  # Create a reactive expression\n  dataset <- reactive({\n    get(input$dataset, \"package:datasets\")\n  })\n\n  output$summary <- renderPrint({\n    # Use a reactive expression by calling it like a function\n    summary(dataset())\n  })\n  \n  output$table <- renderTable({\n    dataset()\n  })\n}"},{"path":"basic-app.html","id":"summary","chapter":"1 Your first Shiny app","heading":"1.7 Summary","text":"在本章中，您创建了一个简单的 app — 它不是很令人兴奋或有用，但您看到了使用现有的 R 知识构建一个 web app 是多么容易。\n在接下来的两章中，您将了解有关用户界面和响应式编程的更多信息，这是 Shiny 的两个基本构建块。\n现在是获取 Shiny cheatsheet 的好时机。\n这是一个很好的资源，可以帮助您回忆 Shiny app 的主要组件。\nFigure 1.5: Shiny cheatsheet, available https://www.rstudio.com/resources/cheatsheets/\n","code":""},{"path":"basic-app.html","id":"exercises","chapter":"1 Your first Shiny app","heading":"1.8 Exercises","text":"创建一个通过名字向用户打招呼的 app。\n您还不知道执行此操作所需的所有函数，因此我在下面添加了一些代码行。\n考虑一下您将使用哪些行，然后将它们复制并粘贴到 Shiny app 中的正确位置。\n\ntableOutput(\"mortgage\")\noutput$greeting <- renderText({\n  paste0(\"Hello \", input$name)\n})\nnumericInput(\"age\", \"old ?\", value = NA)\ntextInput(\"name\", \"name?\")\ntextOutput(\"greeting\")\noutput$histogram <- renderPlot({\n  hist(rnorm(1000))\n}, res = 96)创建一个通过名字向用户打招呼的 app。\n您还不知道执行此操作所需的所有函数，因此我在下面添加了一些代码行。\n考虑一下您将使用哪些行，然后将它们复制并粘贴到 Shiny app 中的正确位置。假设您的朋友想要设计一个 app，允许用户设置 1 到 50 之间的数字 (x)，并显示该数字乘以 5 的结果。\n这是他们的第一次尝试：\n\nlibrary(shiny)\n\nui <- fluidPage(\n  sliderInput(\"x\", label = \"x \", min = 1, max = 50, value = 30),\n  \"x times 5 \",\n  textOutput(\"product\")\n)\n\nserver <- function(input, output, session) {\n  output$product <- renderText({ \n    x * 5\n  })\n}\n\nshinyApp(ui, server)\n但不幸的是它有一个错误：\n\n你能帮助他们找到并纠正错误吗？假设您的朋友想要设计一个 app，允许用户设置 1 到 50 之间的数字 (x)，并显示该数字乘以 5 的结果。\n这是他们的第一次尝试：但不幸的是它有一个错误：你能帮助他们找到并纠正错误吗？扩展上一个练习中的 app，以允许用户设置乘数 y 的值，以便应用程序生成 x * y 的值。\n最终结果应该是这样的：\n扩展上一个练习中的 app，以允许用户设置乘数 y 的值，以便应用程序生成 x * y 的值。\n最终结果应该是这样的：使用以下 app，它为上一个练习中描述的最后一个 app 添加了一些附加功能。\n什么是新的？\n如何通过使用响应式表达式来减少 app 中重复代码的数量。\n\nlibrary(shiny)\n\nui <- fluidPage(\n  sliderInput(\"x\", \"x \", min = 1, max = 50, value = 30),\n  sliderInput(\"y\", \"y \", min = 1, max = 50, value = 5),\n  \", (x * y) \", textOutput(\"product\"),\n  \", (x * y) + 5 \", textOutput(\"product_plus5\"),\n  \"(x * y) + 10 \", textOutput(\"product_plus10\")\n)\n\nserver <- function(input, output, session) {\n  output$product <- renderText({ \n    product <- input$x * input$y\n    product\n  })\n  output$product_plus5 <- renderText({ \n    product <- input$x * input$y\n    product + 5\n  })\n  output$product_plus10 <- renderText({ \n    product <- input$x * input$y\n    product + 10\n  })\n}\n\nshinyApp(ui, server)使用以下 app，它为上一个练习中描述的最后一个 app 添加了一些附加功能。\n什么是新的？\n如何通过使用响应式表达式来减少 app 中重复代码的数量。以下 app 与您在本章前面看到的 app 非常相似：您从包中选择一个数据集（这次我们使用 ggplot2 包），然后该 app 打印出数据的摘要和绘图。\n它还遵循良好实践并利用响应式表达式来避免代码冗余。\n然而，下面提供的代码中存在三个错误。\n你能找到并修复它们吗？\n\nlibrary(shiny)\nlibrary(ggplot2)\n#> Warning: package 'ggplot2' built R version 4.2.3\n\ndatasets <- c(\"economics\", \"faithfuld\", \"seals\")\nui <- fluidPage(\n  selectInput(\"dataset\", \"Dataset\", choices = datasets),\n  verbatimTextOutput(\"summary\"),\n  tableOutput(\"plot\")\n)\n\nserver <- function(input, output, session) {\n  dataset <- reactive({\n    get(input$dataset, \"package:ggplot2\")\n  })\n  output$summmry <- renderPrint({\n    summary(dataset())\n  })\n  output$plot <- renderPlot({\n    plot(dataset)\n  }, res = 96)\n}\n\nshinyApp(ui, server)以下 app 与您在本章前面看到的 app 非常相似：您从包中选择一个数据集（这次我们使用 ggplot2 包），然后该 app 打印出数据的摘要和绘图。\n它还遵循良好实践并利用响应式表达式来避免代码冗余。\n然而，下面提供的代码中存在三个错误。\n你能找到并修复它们吗？","code":"\ntableOutput(\"mortgage\")\noutput$greeting <- renderText({\n  paste0(\"Hello \", input$name)\n})\nnumericInput(\"age\", \"How old are you?\", value = NA)\ntextInput(\"name\", \"What's your name?\")\ntextOutput(\"greeting\")\noutput$histogram <- renderPlot({\n  hist(rnorm(1000))\n}, res = 96)\nlibrary(shiny)\n\nui <- fluidPage(\n  sliderInput(\"x\", label = \"If x is\", min = 1, max = 50, value = 30),\n  \"then x times 5 is\",\n  textOutput(\"product\")\n)\n\nserver <- function(input, output, session) {\n  output$product <- renderText({ \n    x * 5\n  })\n}\n\nshinyApp(ui, server)\nlibrary(shiny)\n\nui <- fluidPage(\n  sliderInput(\"x\", \"If x is\", min = 1, max = 50, value = 30),\n  sliderInput(\"y\", \"and y is\", min = 1, max = 50, value = 5),\n  \"then, (x * y) is\", textOutput(\"product\"),\n  \"and, (x * y) + 5 is\", textOutput(\"product_plus5\"),\n  \"and (x * y) + 10 is\", textOutput(\"product_plus10\")\n)\n\nserver <- function(input, output, session) {\n  output$product <- renderText({ \n    product <- input$x * input$y\n    product\n  })\n  output$product_plus5 <- renderText({ \n    product <- input$x * input$y\n    product + 5\n  })\n  output$product_plus10 <- renderText({ \n    product <- input$x * input$y\n    product + 10\n  })\n}\n\nshinyApp(ui, server)\nlibrary(shiny)\nlibrary(ggplot2)\n#> Warning: package 'ggplot2' was built under R version 4.2.3\n\ndatasets <- c(\"economics\", \"faithfuld\", \"seals\")\nui <- fluidPage(\n  selectInput(\"dataset\", \"Dataset\", choices = datasets),\n  verbatimTextOutput(\"summary\"),\n  tableOutput(\"plot\")\n)\n\nserver <- function(input, output, session) {\n  dataset <- reactive({\n    get(input$dataset, \"package:ggplot2\")\n  })\n  output$summmry <- renderPrint({\n    summary(dataset())\n  })\n  output$plot <- renderPlot({\n    plot(dataset)\n  }, res = 96)\n}\n\nshinyApp(ui, server)"},{"path":"basic-ui.html","id":"basic-ui","chapter":"2 Basic UI","heading":"2 Basic UI","text":"","code":""},{"path":"basic-ui.html","id":"introduction-1","chapter":"2 Basic UI","heading":"2.1 Introduction","text":"现在您已经掌握了一个基本的 app，我们可以开始探索让 Shiny 发挥作用的细节。\n正如您在上一章中看到的，Shiny 鼓励将生成用户界面（前端）的代码与驱动 app 行为的代码（后端）分离。在本章中，我们将重点关注前端，并带您快速了解 Shiny 提供的 HTML 输入和输出。\n这使您能够捕获多种类型的数据并显示多种类型的 R 输出。\n你还没有很多方法将输入和输出拼接在一起，但我们将在 Chapter ?? 中回到这一点。在这里，我将主要坚持 Shiny 本身内置的输入和输出。\n然而，有一个丰富且充满活力的扩展包社区，例如 shinyWidgets、colorpicker、和 sorttable。\n您可以在 https://github.com/nanxstats/awesome-shiny-extensions 找到全面的、积极维护的其他软件包列表，由 Nan Xiao 维护。像往常一样，我们将首先加载 shiny 包：","code":"\nlibrary(shiny)"},{"path":"basic-ui.html","id":"inputs","chapter":"2 Basic UI","heading":"2.2 Inputs","text":"正如我们在上一章中看到的，您可以使用 sliderInput()、selectInput()、textInput() 和 numericInput() 等函数将输入控件插入到 UI 规范中。\n现在我们将讨论所有输入函数的通用结构，并快速概述 Shiny 中内置的输入。","code":""},{"path":"basic-ui.html","id":"common-structure","chapter":"2 Basic UI","heading":"2.2.1 Common structure","text":"所有输入函数都有相同的第一个参数：inputId。\n这是用于连接前端和后端的标识符：如果您的 UI 有一个 ID 为 \"name\" 的输入，server 函数将使用 input$name 访问它。inputId 有两个约束：它必须是一个仅包含字母、数字和下划线的简单字符串（不允许包含空格、短划线、句点或其他特殊字符！）。\n命名它就像在 R 中命名变量一样。它必须是一个仅包含字母、数字和下划线的简单字符串（不允许包含空格、短划线、句点或其他特殊字符！）。\n命名它就像在 R 中命名变量一样。它必须是独一无二的。\n如果它不是唯一的，您将无法在 server 函数中引用此控件！它必须是独一无二的。\n如果它不是唯一的，您将无法在 server 函数中引用此控件！大多数输入函数都有第二个参数，称为 label。\n这用于为控件创建人类可读的标签。\nShiny 不会对此字符串施加任何限制，但您需要仔细考虑它以确保您的 app 可供人类使用！\n第三个参数通常是 value，在可能的情况下，让您设置默认值。\n其余参数对于该控件来说是唯一的。创建输入时，我建议按位置提供 inputId 和 label 参数，并按名称提供所有其他参数：以下部分描述了 Shiny 中内置的输入，根据它们创建的控件类型松散地分组。\n目的是让您快速了解您的选择，而不是详尽地描述所有参数。\n我将在下面显示每个控件最重要的参数，但您需要阅读文档才能获取完整的详细信息。","code":"\nsliderInput(\"min\", \"Limit (minimum)\", value = 50, min = 0, max = 100)"},{"path":"basic-ui.html","id":"free-text","chapter":"2 Basic UI","heading":"2.2.2 Free text","text":"使用 textInput() 收集少量文本，使用 passwordInput()3 收集密码，使用 textAreaInput() 收集文本段落。如果你想确保文本具有某些属性，你可以使用 validate()，我们将在 Chapter ?? 中讨论这一点。","code":"\nui <- fluidPage(\n  textInput(\"name\", \"What's your name?\"),\n  passwordInput(\"password\", \"What's your password?\"),\n  textAreaInput(\"story\", \"Tell me about yourself\", rows = 3)\n)"},{"path":"basic-ui.html","id":"numeric-inputs","chapter":"2 Basic UI","heading":"2.2.3 Numeric inputs","text":"要收集数值，请使用 numericInput() 创建受约束的文本框或使用 sliderInput() 创建滑块。\n如果为 sliderInput() 的默认值提供长度为 2 的数值向量，您将得到一个有两端的“范围”滑块。一般来说，我建议仅在小范围或精确值不太重要的情况下使用滑块。\n尝试在小滑块上精确选择数字是一项令人沮丧的练习！滑块是高度可定制的，并且有很多方法可以调整其外观。有关更多详细信息，请参阅 ?sliderInput 和 https://shiny.rstudio.com/articles/sliders.html。","code":"\nui <- fluidPage(\n  numericInput(\"num\", \"Number one\", value = 0, min = 0, max = 100),\n  sliderInput(\"num2\", \"Number two\", value = 50, min = 0, max = 100),\n  sliderInput(\"rng\", \"Range\", value = c(10, 20), min = 0, max = 100)\n)"},{"path":"basic-ui.html","id":"dates","chapter":"2 Basic UI","heading":"2.2.4 Dates","text":"使用 dateInput() 收集单个日期，或使用 dateRangeInput() 收集两个日期的范围。\n它们提供了一个方便的日历选择器，并且像 datesdisabled 和 daysofweekdisabled 这样的附加参数允许您限制有效输入的集合。日期格式、语言和一周开始日期默认为美国标准。\n如果您要创建面向国际受众的应用程序，请设置 format、language、和 weekstart，以便日期对您的用户来说是自然的。","code":"\nui <- fluidPage(\n  dateInput(\"dob\", \"When were you born?\"),\n  dateRangeInput(\"holiday\", \"When do you want to go on vacation next?\")\n)"},{"path":"basic-ui.html","id":"limited-choices","chapter":"2 Basic UI","heading":"2.2.5 Limited choices","text":"有两种不同的方法允许用户从一组预先指定的选项中进行选择：selectInput() 和 radioButtons()。单选按钮有两个很好的功能：它们显示所有可能的选项，使其适合短列表，并且通过 choiceNames/choiceValues 参数，它们可以显示纯文本以外的选项。\nchoiceNames 决定向用户显示的内容；choiceValues 决定 server 函数中返回的内容。无论选项数量多少，使用 selectInput() 创建的下拉菜单都会占用相同的空间，这使得它们更适合较长的选项。\n您还可以设置 multiple = TRUE 以允许用户选择多个元素。如果您有大量可能的选项，您可能需要使用“服务器端” selectInput()，以便完整的可能选项集不会嵌入到 UI 中（这会导致加载速度变慢），而是由 server 根据需要发送。\n您可以在 https://shiny.rstudio.com/articles/selectize.html#server-side-selectize 了解有关此高级主题的更多信息。无法使用单选按钮选择多个值，但有一个概念上类似的替代方案：checkboxGroupInput()。如果您想要单个复选框用于单个是/否问题，请使用 checkboxInput()：","code":"\nanimals <- c(\"dog\", \"cat\", \"mouse\", \"bird\", \"other\", \"I hate animals\")\n\nui <- fluidPage(\n  selectInput(\"state\", \"What's your favourite state?\", state.name),\n  radioButtons(\"animal\", \"What's your favourite animal?\", animals)\n)\nui <- fluidPage(\n  radioButtons(\"rb\", \"Choose one:\",\n    choiceNames = list(\n      icon(\"angry\"),\n      icon(\"smile\"),\n      icon(\"sad-tear\")\n    ),\n    choiceValues = list(\"angry\", \"happy\", \"sad\")\n  )\n)\nui <- fluidPage(\n  selectInput(\n    \"state\", \"What's your favourite state?\", state.name,\n    multiple = TRUE\n  )\n)\nui <- fluidPage(\n  checkboxGroupInput(\"animal\", \"What animals do you like?\", animals)\n)\nui <- fluidPage(\n  checkboxInput(\"cleanup\", \"Clean up?\", value = TRUE),\n  checkboxInput(\"shutdown\", \"Shutdown?\")\n)"},{"path":"basic-ui.html","id":"file-uploads","chapter":"2 Basic UI","heading":"2.2.6 File uploads","text":"通过 fileInput() 允许用户使上传文件：fileInput() 需要在服务器端进行特殊处理，在 Chapter ?? 中详细讨论。","code":"\nui <- fluidPage(\n  fileInput(\"upload\", NULL)\n)"},{"path":"basic-ui.html","id":"action-buttons","chapter":"2 Basic UI","heading":"2.2.7 Action buttons","text":"使用 actionButton() 或actionLink() 让用户执行操作：操作链接和按钮最自然地与 server 函数中的 observeEvent() 或 eventReactive() 配对。\n您还没有了解这些重要的功能，但我们将在 Section 3.5 中回顾它们。您可以使用 class 参数通过使用 \"btn-primary\"、\"btn-success\"、\"btn-info\"、\"btn-warning\"、\"btn-danger\" 其中的一个来自定义外观。\n您还可以使用 \"btn-lg\"、\"btn-sm\"、\"btn-xs\" 更改大小。\n最后，您可以使用 \"btn-block\" 使按钮跨越它们嵌入的元素的整个宽度。class 参数通过设置底层 HTML 的 class 属性来工作，这会影响元素的样式。\n要查看其他选项，您可以阅读 Bootstrap（Shiny 使用的 CSS 设计系统）的文档：<http://bootstrapdocs.com/v3.3.6/docs/css/#buttons>。","code":"\nui <- fluidPage(\n  actionButton(\"click\", \"Click me!\"),\n  actionButton(\"drink\", \"Drink me!\", icon = icon(\"cocktail\"))\n)\nui <- fluidPage(\n  fluidRow(\n    actionButton(\"click\", \"Click me!\", class = \"btn-danger\"),\n    actionButton(\"drink\", \"Drink me!\", class = \"btn-lg btn-success\")\n  ),\n  fluidRow(\n    actionButton(\"eat\", \"Eat me!\", class = \"btn-block\")\n  )\n)"},{"path":"basic-ui.html","id":"exercises-1","chapter":"2 Basic UI","heading":"2.2.8 Exercises","text":"当空间非常宝贵时，使用出现在文本输入区域内的占位符来标记文本框非常有用。\n如何调用 textInput() 来生成下面的 UI？\n当空间非常宝贵时，使用出现在文本输入区域内的占位符来标记文本框非常有用。\n如何调用 textInput() 来生成下面的 UI？仔细阅读 sliderInput() 的文档，了解如何创建日期滑块，如下所示。\n仔细阅读 sliderInput() 的文档，了解如何创建日期滑块，如下所示。创建一个滑块输入以选择 0 到 100 之间的值，其中滑块上每个可选值之间的间隔为 5。\n然后，向 input widget 添加动画，以便当用户按下“播放”时，input widget 会自动滚动该范围。创建一个滑块输入以选择 0 到 100 之间的值，其中滑块上每个可选值之间的间隔为 5。\n然后，向 input widget 添加动画，以便当用户按下“播放”时，input widget 会自动滚动该范围。如果 selectInput() 中有一个相当长的列表，那么创建将列表分成几部分的子标题会很有用。\n阅读文档以了解如何操作。\n（提示：底层 HTML 称为 <optgroup>。）如果 selectInput() 中有一个相当长的列表，那么创建将列表分成几部分的子标题会很有用。\n阅读文档以了解如何操作。\n（提示：底层 HTML 称为 <optgroup>。）","code":""},{"path":"basic-ui.html","id":"outputs","chapter":"2 Basic UI","heading":"2.3 Outputs","text":"UI 中的输出创建占位符，稍后由 server 函数填充。\n与输入一样，输出采用唯一的 ID 作为其第一个参数4：如果您的 UI 规范创建 ID 为 \"plot\" 的输出，您将在 server 函数中使用 output$plot 访问它。前端的每个 output 函数都与后端的 render 函数耦合。\n输出主要有三种类型，对应于报告中通常包含的三种内容：文本、表格和图表。\n以下部分向您展示前端输出函数的基础知识，以及后端相应的 render 函数。","code":""},{"path":"basic-ui.html","id":"text","chapter":"2 Basic UI","heading":"2.3.1 Text","text":"使用 textOutput() 输出常规文本，使用 verbatimTextOutput() 输出固定代码和控制台输出。请注意，仅当需要运行多行代码时，render 函数中才需要 {}。\n正如您很快就会了解到的，您应该在 render 函数中进行尽可能少的计算，这意味着您通常可以忽略它们。\n如果写得更紧凑的话，上面的 server 函数会是这样的：请注意，有两个 render 函数的行为略有不同：renderText() 将结果组合成单个字符串，通常与 textOutput() 配对renderPrint() 打印结果，就像在 R console 中一样，并且通常与 verbatimTextOutput() 配对。我们可以看到与 toy app 的区别：这相当于 R 语言中 cat() 和 print() 的区别。","code":"\nui <- fluidPage(\n  textOutput(\"text\"),\n  verbatimTextOutput(\"code\")\n)\nserver <- function(input, output, session) {\n  output$text <- renderText({ \n    \"Hello friend!\" \n  })\n  output$code <- renderPrint({ \n    summary(1:10) \n  })\n}\nserver <- function(input, output, session) {\n  output$text <- renderText(\"Hello friend!\")\n  output$code <- renderPrint(summary(1:10))\n}\nui <- fluidPage(\n  textOutput(\"text\"),\n  verbatimTextOutput(\"print\")\n)\nserver <- function(input, output, session) {\n  output$text <- renderText(\"hello!\")\n  output$print <- renderPrint(\"hello!\")\n}"},{"path":"basic-ui.html","id":"tables","chapter":"2 Basic UI","heading":"2.3.2 Tables","text":"有两种用于在表格中显示 data frames 的选项：tableOutput() 和 renderTable() 渲染静态数据表，一次性显示所有数据。tableOutput() 和 renderTable() 渲染静态数据表，一次性显示所有数据。dataTableOutput() 和 renderDataTable() 呈现一个动态表，显示固定数量的行以及用于更改哪些行可见的控件。dataTableOutput() 和 renderDataTable() 呈现一个动态表，显示固定数量的行以及用于更改哪些行可见的控件。tableOutput() 对于小型固定摘要最有用（例如模型系数）；如果您想向用户公开完整的 data frame，则 dataTableOutput() 最合适。\n如果您想更好地控制 dataTableOutput() 的输出，我强烈推荐 Greg Lin 的 reactable 包。","code":"\nui <- fluidPage(\n  tableOutput(\"static\"),\n  dataTableOutput(\"dynamic\")\n)\nserver <- function(input, output, session) {\n  output$static <- renderTable(head(mtcars))\n  output$dynamic <- renderDataTable(mtcars, options = list(pageLength = 5))\n}"},{"path":"basic-ui.html","id":"plots","chapter":"2 Basic UI","heading":"2.3.3 Plots","text":"您可以使用 plotOutput() 和 renderPlot() 显示任何类型的 R 图形（base、ggplot2 或其他）：默认情况下，plotOutput() 将占据其容器的整个宽度（稍后会详细介绍），高度为 400 像素。\n您可以使用 height 和 width 参数覆盖这些默认值。\n我们建议始终设置 res = 96，因为这将使您的 Shiny plots 尽可能匹配您在 RStudio 中看到的内容。Plots 很特殊，因为它们是输出，也可以充当输入。\nplotOutput() 有许多参数，例如 click、dblclick 和 hover。\n如果您向它们传递一个字符串，例如 click = \"plot_click\"，它们将创建一个反应性输入 (input$plot_click)，您可以使用它来处理绘图上的用户交互，例如单击绘图。\n我们将在 Chapter ?? 中回到 Shiny 中的 interactive plots。","code":"\nui <- fluidPage(\n  plotOutput(\"plot\", width = \"400px\")\n)\nserver <- function(input, output, session) {\n  output$plot <- renderPlot(plot(1:5), res = 96)\n}"},{"path":"basic-ui.html","id":"downloads","chapter":"2 Basic UI","heading":"2.3.4 Downloads","text":"您可以使用 downloadButton() 或 downloadLink() 让用户下载文件。\n这些需要 server 函数中的新技术，所以我们将在 Chapter ?? 中回到这一点。","code":""},{"path":"basic-ui.html","id":"exercises-2","chapter":"2 Basic UI","heading":"2.3.5 Exercises","text":"以下每个 render 函数应该与 textOutput() 和 verbatimTextOutput() 中的哪一个配对？\nrenderPrint(summary(mtcars))\nrenderText(\"Good morning!\")\nrenderPrint(t.test(1:5, 2:6))\nrenderText(str(lm(mpg ~ wt, data = mtcars)))\n以下每个 render 函数应该与 textOutput() 和 verbatimTextOutput() 中的哪一个配对？renderPrint(summary(mtcars))renderPrint(summary(mtcars))renderText(\"Good morning!\")renderText(\"Good morning!\")renderPrint(t.test(1:5, 2:6))renderPrint(t.test(1:5, 2:6))renderText(str(lm(mpg ~ wt, data = mtcars)))renderText(str(lm(mpg ~ wt, data = mtcars)))重新创建 Section 2.3.3 中的 Shiny app，这次将高度设置为 300px，宽度设置为 700px。\n设置绘图 “alt” 文本，以便视障用户可以看出它是五个随机数的散点图。重新创建 Section 2.3.3 中的 Shiny app，这次将高度设置为 300px，宽度设置为 700px。\n设置绘图 “alt” 文本，以便视障用户可以看出它是五个随机数的散点图。更新下面对 renderDataTable() 的调用中的选项，以便显示数据，但抑制所有其他控件（即删除搜索、排序和过滤命令）。\n您需要阅读 ?renderDataTable 并查看 https://datatables.net/reference/option/ 中的选项。\n\nui <- fluidPage(\n  dataTableOutput(\"table\")\n)\nserver <- function(input, output, session) {\n  output$table <- renderDataTable(mtcars, options = list(pageLength = 5))\n}更新下面对 renderDataTable() 的调用中的选项，以便显示数据，但抑制所有其他控件（即删除搜索、排序和过滤命令）。\n您需要阅读 ?renderDataTable 并查看 https://datatables.net/reference/option/ 中的选项。或者，阅读有关 reactable 的内容，并将上述 app 转换为使用它。或者，阅读有关 reactable 的内容，并将上述 app 转换为使用它。","code":"\nui <- fluidPage(\n  dataTableOutput(\"table\")\n)\nserver <- function(input, output, session) {\n  output$table <- renderDataTable(mtcars, options = list(pageLength = 5))\n}"},{"path":"basic-ui.html","id":"summary-1","chapter":"2 Basic UI","heading":"2.4 Summary","text":"本章向您介绍了构成 Shiny app 前端的主要输入和输出函数。\n这是一个很大的信息转储，所以不要指望在一次阅读后记住所有内容。\n相反，当您正在寻找特定组件时，请返回本章：您可以快速浏览图形，然后找到您需要的代码。在下一章中，我们将继续讨论 Shiny app 的后端：使用户界面栩栩如生的 R 代码。","code":""},{"path":"basic-reactivity.html","id":"basic-reactivity","chapter":"3 Basic reactivity","heading":"3 Basic reactivity","text":"","code":""},{"path":"basic-reactivity.html","id":"introduction-2","chapter":"3 Basic reactivity","heading":"3.1 Introduction","text":"在 Shiny 中，您可以使用响应式编程来表达你的 server 逻辑。\n响应式编程是一种优雅而强大的编程范式，但一开始它可能会让人迷失方向，因为它与编写脚本是一种非常不同的范式。\n响应式编程的关键思想是指定依赖关系图，以便当输入更改时，所有相关输出都会自动更新。\n这使得 app 的流程变得相当简单，但需要一段时间才能理解它们是如何组合在一起的。本章将简要介绍响应式编程，教您在 Shiny apps 中使用的最常见响应式结构的基础知识。\n我们将从 server 函数的调查开始，更详细地讨论 input 和 output 参数的工作原理。\n接下来，我们将回顾最简单的响应式形式（其中输入直接连接到输出），然后讨论响应式表达式如何帮助您消除重复的工作。\n最后，我们将回顾一下 Shiny 新用户遇到的一些常见障碍。","code":""},{"path":"basic-reactivity.html","id":"the-server-function","chapter":"3 Basic reactivity","heading":"3.2 The server function","text":"正如您所看到的，每个 Shiny app 的内部结构如下所示：上一章介绍了前端的基础知识，即包含呈现给 app 的每个用户的 HTML 的 ui 对象。\nui 很简单，因为每个用户都会获得相同的 HTML。\nserver 更加复杂，因为每个用户都需要获得独立版本的 app；当用户 移动滑块时，用户 B 不应看到其输出发生变化。为了实现这种独立性，Shiny 每次启动新会话5时都会调用 server() 函数。\n就像任何其他 R 函数一样，当调用 server 函数时，它会创建一个独立于该函数的所有其他调用的新本地环境。\n这允许每个会话具有唯一的状态，并隔离函数内创建的变量。\n这就是为什么您在 Shiny 中进行的几乎所有响应式编程都将在 server 函数中进行6。Server 函数采用三个参数：input、output 和 session。\n因为您从不自己调用 server 函数，所以您永远不会自己创建这些对象。\n相反，它们是在会话开始时由 Shiny 创建的，并连接回特定会话。\n目前，我们将重点关注 input 和 output 参数，并将 session 留给后面的章节。","code":"\nlibrary(shiny)\n\nui <- fluidPage(\n  # front end interface\n)\n\nserver <- function(input, output, session) {\n  # back end logic\n}\n\nshinyApp(ui, server)"},{"path":"basic-reactivity.html","id":"input","chapter":"3 Basic reactivity","heading":"3.2.1 Input","text":"input 参数是一个类似列表的对象，其中包含从浏览器发送的所有输入数据，根据输入 ID 命名。\n例如，如果您的 UI 包含一个输入 ID 为 count 的数字输入控件，如下所示：然后您可以使用 input$count 访问该输入的值。\n它最初包含值 100，并且当用户更改浏览器中的值时，它将自动更新。与典型列表不同，input 对象是只读的。\n如果您尝试修改 server 函数内的 input，您将收到报错：发生此错误的原因是 input 反映了浏览器中发生的情况，而浏览器是 Shiny 的“单一事实来源”。\n如果您可以修改 R 中的值，则可能会导致不一致，即输入滑块在浏览器中表示一件事，而 input$count 在 R 中表示不同的内容。\n这将使编程变得具有挑战性！\n稍后，在 Chapter ?? 中，您将学习如何使用 updateNumericInput() 等函数来修改浏览器中的值，然后 input$count 也会相应更新。关于 input 的另一件重要的事情是：它对允许谁阅读它是有选择性的。\n要读取 input，您必须处于由 renderText() 或 reactive() 等函数创建的响应式上下文中。\n我们很快就会回到这个想法，但这是一个重要的约束，它允许输出在输入更改时自动更新。\n此代码说明了如果您犯此错误，您将看到的错误：","code":"\nui <- fluidPage(\n  numericInput(\"count\", label = \"Number of values\", value = 100)\n)\nserver <- function(input, output, session) {\n  input$count <- 10  \n}\n\nshinyApp(ui, server)\n#> Error: Can't modify read-only reactive value 'count'\nserver <- function(input, output, session) {\n  message(\"The value of input$count is \", input$count)\n}\n\nshinyApp(ui, server)\n#> Error: Can't access reactive value 'count' outside of reactive consumer.\n#> ℹ Do you need to wrap inside reactive() or observer()?"},{"path":"basic-reactivity.html","id":"output","chapter":"3 Basic reactivity","heading":"3.2.2 Output","text":"output 与 input 非常相似：它也是一个根据输出 ID 命名的类似列表的对象。\n主要区别在于您使用它来发送输出而不是接收输入。\n您始终将 output 对象与 render 函数结合使用，如以下简单示例所示：（请注意，该 ID 在 UI 中被引用，但在 server 中未被引用。）render 函数做了两件事：它设置了一个特殊的响应式上下文，可以自动跟踪输出使用的输入。它设置了一个特殊的响应式上下文，可以自动跟踪输出使用的输入。它将 R 代码的输出转换为适合在网页上显示的 HTML。它将 R 代码的输出转换为适合在网页上显示的 HTML。与 input 一样，output 对您的使用方式也很挑剔。\n如果出现以下情况，您将收到错误消息：你忘记了 render 函数。\n\nserver <- function(input, output, session) {\n  output$greeting <- \"Hello human\"\n}\nshinyApp(ui, server)\n#> Error: Unexpected character object output$greeting\n#> ℹ forget use render function?你忘记了 render 函数。您尝试读取 output。\n\nserver <- function(input, output, session) {\n  message(\"greeting \", output$greeting)\n}\nshinyApp(ui, server)\n#> Error: Reading shinyoutput object allowed.您尝试读取 output。","code":"\nui <- fluidPage(\n  textOutput(\"greeting\")\n)\n\nserver <- function(input, output, session) {\n  output$greeting <- renderText(\"Hello human!\")\n}\nserver <- function(input, output, session) {\n  output$greeting <- \"Hello human\"\n}\nshinyApp(ui, server)\n#> Error: Unexpected character object for output$greeting\n#> ℹ Did you forget to use a render function?\nserver <- function(input, output, session) {\n  message(\"The greeting is \", output$greeting)\n}\nshinyApp(ui, server)\n#> Error: Reading from shinyoutput object is not allowed."},{"path":"basic-reactivity.html","id":"reactive-programming","chapter":"3 Basic reactivity","heading":"3.3 Reactive programming","text":"如果 app 只有输入或只有输出，那么它会非常无聊。\n当您拥有同时具备这两种功能的 app 时，Shiny 的真正魔力就会发挥出来。\n让我们看一个简单的例子：很难在一本书中展示它是如何工作的，但我在 Figure 3.1 中尽力了。\n如果您运行该 app，并在 name 框中输入内容，您将看到问候语会在您输入时自动更新7。\nFigure 3.1: 响应式意味着输出会随着输入的变化而自动更新，就像在这个 app 中我输入“J”、“o”、“e”一样。 See live https://hadley.shinyapps.io/ms-connection.\n这是 Shiny 的重要思想：您不需要告诉输出何时更新，因为 Shiny 会自动为您计算出来。\n它是如何工作的？\n函数体内究竟发生了什么？\n让我们更精确地考虑一下 server 函数内部的代码：很容易将其理解为“将‘hello’和用户名粘贴在一起，然后将其发送到output$greeting”。\n但这种思维模式在一个微妙但重要的方面是错误的。\n想一想：使用这种模型，您只需发出一次指令。\n但每次我们更新 input$name 时，Shiny 都会执行该操作，所以肯定还有更多的事情发生。该 app 之所以有效，是因为代码不会告诉 Shiny 创建字符串并将其发送到浏览器，而是通知 Shiny 在需要时如何创建字符串。\n代码何时（甚至是否！）运行取决于 Shiny。\n它可能会在 app 启动后立即运行，也可能会晚一些；它可能会运行很多次，也可能永远不会运行！\n这并不是说 Shiny 反复无常，只是说决定何时执行代码是 Shiny 的责任，而不是你的。\n将您的 app 视为向 Shiny 提供食谱，而不是向其发出命令。","code":"\nui <- fluidPage(\n  textInput(\"name\", \"What's your name?\"),\n  textOutput(\"greeting\")\n)\n\nserver <- function(input, output, session) {\n  output$greeting <- renderText({\n    paste0(\"Hello \", input$name, \"!\")\n  })\n}\noutput$greeting <- renderText({\n  paste0(\"Hello \", input$name, \"!\")\n})"},{"path":"basic-reactivity.html","id":"imperative-vs-declarative-programming","chapter":"3 Basic reactivity","heading":"3.3.1 Imperative vs declarative programming","text":"命令和配方之间的区别是两种重要编程风格之间的主要区别之一：在命令式（imperative）编程中，您发出特定的命令，它会立即执行。\n这是您在分析脚本中习惯的编程风格：命令 R 加载数据、转换数据、可视化数据并将结果保存到磁盘。在命令式（imperative）编程中，您发出特定的命令，它会立即执行。\n这是您在分析脚本中习惯的编程风格：命令 R 加载数据、转换数据、可视化数据并将结果保存到磁盘。在声明式（declarative）编程中，您表达更高级别的目标或描述重要的约束，并依靠其他人来决定如何和/或何时将其转化为行动。\n这是您在 Shiny 中使用的编程风格。在声明式（declarative）编程中，您表达更高级别的目标或描述重要的约束，并依靠其他人来决定如何和/或何时将其转化为行动。\n这是您在 Shiny 中使用的编程风格。使用命令式代码，您可以说“给我做一个三明治”8。\n使用声明性代码，您可以说“每当我查看冰箱内部时，确保冰箱中有一个三明治”。\n命令式代码是断言的（assertive）；声明式代码是被动攻击性的（passive-aggressive）。大多数时候，声明式编程非常自由：您描述您的总体目标，软件就会计算出如何实现这些目标，而无需进一步干预。\n缺点是有时您确切地知道自己想要什么，但无法弄清楚如何以声明性系统可以理解的方式构建它9。\n本书的目的是帮助您加深对基础理论的理解，从而尽可能减少这种情况的发生。","code":""},{"path":"basic-reactivity.html","id":"laziness","chapter":"3 Basic reactivity","heading":"3.3.2 Laziness","text":"Shiny 中声明式编程的优点之一是它允许 apps 变得非常懒惰。\nShiny app 只会执行更新您当前可以看到的输出控件所需的最少工作量10。\n然而，这种懒惰带来了一个您应该意识到的重要缺点。\n你能发现下面的 server 函数有什么问题吗？如果你仔细观察，你可能会注意到我写的是 greting 而不是 greeting。\n这不会在 Shiny 中产生错误，但它不会做你想要的事情。\ngreting 输出不存在，因此 renderText() 中的代码永远不会运行。如果您正在开发一个 Shiny app，并且您无法弄清楚为什么您的代码永远不会运行，请仔细检查您的 UI 和 server 函数是否使用相同的标识符。","code":"\nserver <- function(input, output, session) {\n  output$greting <- renderText({\n    paste0(\"Hello \", input$name, \"!\")\n  })\n}"},{"path":"basic-reactivity.html","id":"the-reactive-graph","chapter":"3 Basic reactivity","heading":"3.3.3 The reactive graph","text":"Shiny 的懒惰还有另一个重要的特性。\n在大多数 R 代码中，您可以通过从上到下阅读代码来了解执行顺序。\n这在 Shiny 中不起作用，因为代码仅在需要时运行。\n要了解执行顺序，您需要查看响应式图（reactive graph），它描述了输入和输出如何连接。\n上面 app 的响应式图非常简单，如 Figure 3.2 所示。\nFigure 3.2: 响应式图显示了输入和输出的连接方式\n响应式图对于每个输入和输出都包含一个符号，每当输出访问输入时，我们就将输入连接到输出。\n该图告诉您，只要 name 更改，就需要重新计算 greeting。\n我们经常将这种关系描述为 greeting 对 name 有响应式依赖（reactive dependency）。请注意我们用于输入和输出的图形约定：name 输入自然适合 greeting 输出。\n我们可以将它们紧密地画在一起，如 Figure 3.3 所示，以强调它们组合在一起的方式；我们通常不会这样做，因为它只适用于最简单的 apps。\nFigure 3.3: 响应式图组件使用的形状唤起了它们连接的方式。\n响应式图是了解 app 工作原理的强大工具。\n随着您的 app 变得越来越复杂，制作响应式图的快速高级草图通常很有用，以提醒您所有部分如何组合在一起。\n在本书中，我们将向您展示响应式图，以帮助您理解示例的工作原理，稍后在 Chapter 14 中，您将学习如何使用 reactlog 来为您绘制图表。","code":""},{"path":"basic-reactivity.html","id":"reactive-expressions","chapter":"3 Basic reactivity","heading":"3.3.4 Reactive expressions","text":"您将在响应式图中看到一个更重要的组件：响应式表达式。\n我们很快就会详细讨论响应式表达式；现在将它们视为一种工具，通过在响应式图中引入额外的节点来减少响应式代码中的重复。我们在非常简单的 app 中不需要响应式表达式，但无论如何我都会添加一个，以便您可以看到它如何影响响应式图，Figure 3.4。\nFigure 3.4: 响应式表达式两边都有角度，因为它将输入连接到输出。\n响应式表达式接受输入并产生输出，因此它们具有结合输入和输出特征的形状。\n希望这些形状能帮助您记住组件如何组合在一起。","code":"\nserver <- function(input, output, session) {\n  string <- reactive(paste0(\"Hello \", input$name, \"!\"))\n  output$greeting <- renderText(string())\n}"},{"path":"basic-reactivity.html","id":"execution-order","chapter":"3 Basic reactivity","heading":"3.3.5 Execution order","text":"重要的是要理解代码运行的顺序完全由响应式图决定。\n这与大多数 R 代码不同，大多数 R 代码的执行顺序由行的顺序决定。\n例如，我们可以在简单的 server 函数中翻转两行的顺序：您可能认为这会产生错误，因为 output$greeting 引用尚未创建的响应式表达式、字符串。\n但请记住，Shiny 是惰性的，因此代码仅在创建字符串后会话启动时运行。相反，此代码会生成与上面相同的响应式图，因此代码的运行顺序完全相同。\n像这样组织代码会让人类感到困惑，最好避免。\n相反，请确保响应式表达式和输出仅引用上面定义的内容，而不是下面定义的内容11。\n这将使您的代码更容易理解。这个概念非常重要，并且与大多数其他 R 代码不同，所以我再说一遍：响应式代码的运行顺序仅由响应式图决定，而不是由其在 server 函数中的布局决定。","code":"\nserver <- function(input, output, session) {\n  output$greeting <- renderText(string())\n  string <- reactive(paste0(\"Hello \", input$name, \"!\"))\n}"},{"path":"basic-reactivity.html","id":"exercises-3","chapter":"3 Basic reactivity","heading":"3.3.6 Exercises","text":"给定这个 UI:\n\nui <- fluidPage(\n  textInput(\"name\", \"name?\"),\n  textOutput(\"greeting\")\n)\n修复以下三个 server 函数中发现的简单错误。\n首先尝试通过阅读代码来发现问题；然后运行代码以确保您已修复它。\n\nserver1 <- function(input, output, server) {\n  input$greeting <- renderText(paste0(\"Hello \", name))\n}\n\nserver2 <- function(input, output, server) {\n  greeting <- paste0(\"Hello \", input$name)\n  output$greeting <- renderText(greeting)\n}\n\nserver3 <- function(input, output, server) {\n  output$greting <- paste0(\"Hello\", input$name)\n}给定这个 UI:修复以下三个 server 函数中发现的简单错误。\n首先尝试通过阅读代码来发现问题；然后运行代码以确保您已修复它。绘制以下 server 函数的响应式图：\n\nserver1 <- function(input, output, session) {\n  c <- reactive(input$+ input$b)\n  e <- reactive(c() + input$d)\n  output$f <- renderText(e())\n}\nserver2 <- function(input, output, session) {\n  x <- reactive(input$x1 + input$x2 + input$x3)\n  y <- reactive(input$y1 + input$y2)\n  output$z <- renderText(x() / y())\n}\nserver3 <- function(input, output, session) {\n  d <- reactive(c() ^ input$d)\n  <- reactive(input$* 10)\n  c <- reactive(b() / input$c) \n  b <- reactive(() + input$b)\n}绘制以下 server 函数的响应式图：为什么这段代码会失败？\n\nvar <- reactive(df[[input$var]])\nrange <- reactive(range(var(), na.rm = TRUE))\n为什么 range() 和 var() 对于响应式来说是不好的名字？为什么这段代码会失败？为什么 range() 和 var() 对于响应式来说是不好的名字？","code":"\nui <- fluidPage(\n  textInput(\"name\", \"What's your name?\"),\n  textOutput(\"greeting\")\n)\nserver1 <- function(input, output, server) {\n  input$greeting <- renderText(paste0(\"Hello \", name))\n}\n\nserver2 <- function(input, output, server) {\n  greeting <- paste0(\"Hello \", input$name)\n  output$greeting <- renderText(greeting)\n}\n\nserver3 <- function(input, output, server) {\n  output$greting <- paste0(\"Hello\", input$name)\n}\nserver1 <- function(input, output, session) {\n  c <- reactive(input$a + input$b)\n  e <- reactive(c() + input$d)\n  output$f <- renderText(e())\n}\nserver2 <- function(input, output, session) {\n  x <- reactive(input$x1 + input$x2 + input$x3)\n  y <- reactive(input$y1 + input$y2)\n  output$z <- renderText(x() / y())\n}\nserver3 <- function(input, output, session) {\n  d <- reactive(c() ^ input$d)\n  a <- reactive(input$a * 10)\n  c <- reactive(b() / input$c) \n  b <- reactive(a() + input$b)\n}\nvar <- reactive(df[[input$var]])\nrange <- reactive(range(var(), na.rm = TRUE))"},{"path":"basic-reactivity.html","id":"reactive-expressions-1","chapter":"3 Basic reactivity","heading":"3.4 Reactive expressions","text":"我们已经快速浏览了几次响应式表达式，因此您希望能够了解它们可能会做什么。\n现在我们将深入探讨更多细节，并展示为什么它们在构建真实 apps 时如此重要。响应式表达式很重要，因为它们为 Shiny 提供了更多信息，以便它在输入更改时可以减少重新计算，从而使 apps 更加高效，并且它们通过简化响应式图使人们更容易理解 app。\n响应式表达式具有输入和输出的风格：与 inputs 一样，您可以在 output 中使用响应式表达式的结果。与 inputs 一样，您可以在 output 中使用响应式表达式的结果。与 outputs 一样，响应式表达式依赖于 inputs 并自动知道何时需要更新。与 outputs 一样，响应式表达式依赖于 inputs 并自动知道何时需要更新。这种二元性意味着我们需要一些新的词汇：我将使用生产者（producers）来指代响应式输入和表达式，使用消费者（consumers）来指代响应式表达式和输出。\nFigure 3.5 用维恩图显示了这种关系。\nFigure 3.5: 输入和表达式是响应式生产者；表达式和输出是响应式消费者。\n我们将需要一个更复杂的 app 来了解使用响应式表达式的好处。\n首先，我们将定义一些常规 R 函数来为我们的 app 提供支持，从而做好准备。","code":""},{"path":"basic-reactivity.html","id":"the-motivation","chapter":"3 Basic reactivity","heading":"3.4.1 The motivation","text":"想象一下，我想通过绘图和假设检验来比较两个模拟数据集。\n我做了一些实验并提出了以下函数：freqpoly() 使用频率多边形可视化两个分布12，t_test() 使用 t-test 来比较平均值并用字符串总结结果：如果我有一些模拟数据，我可以使用这些函数来比较两个变量：在真正的分析中，您可能会在最终使用这些函数之前进行大量探索。\n我在这里跳过了该探索，以便我们可以尽快使用该 app。\n但是，将命令式代码提取到常规函数中对于所有 Shiny app 来说都是一项重要技术：从 app 中提取的代码越多，它就越容易理解。\n这是很好的软件工程，因为它有助于隔离问题：app 外部的函数专注于计算，以便 app 内部的代码可以专注于响应用户操作。\n我们将在 Chapter ?? 中再次讨论这个想法。","code":"\nlibrary(ggplot2)\n\nfreqpoly <- function(x1, x2, binwidth = 0.1, xlim = c(-3, 3)) {\n  df <- data.frame(\n    x = c(x1, x2),\n    g = c(rep(\"x1\", length(x1)), rep(\"x2\", length(x2)))\n  )\n\n  ggplot(df, aes(x, colour = g)) +\n    geom_freqpoly(binwidth = binwidth, size = 1) +\n    coord_cartesian(xlim = xlim)\n}\n\nt_test <- function(x1, x2) {\n  test <- t.test(x1, x2)\n  \n  # use sprintf() to format t.test() results compactly\n  sprintf(\n    \"p value: %0.3f\\n[%0.2f, %0.2f]\",\n    test$p.value, test$conf.int[1], test$conf.int[2]\n  )\n}\nx1 <- rnorm(100, mean = 0, sd = 0.5)\nx2 <- rnorm(200, mean = 0.15, sd = 0.9)\n\nfreqpoly(x1, x2)\ncat(t_test(x1, x2))\n#> p value: 0.272\n#> [-0.24, 0.07]"},{"path":"basic-reactivity.html","id":"the-app","chapter":"3 Basic reactivity","heading":"3.4.2 The app","text":"我想使用这两个工具来快速探索一系列模拟。\nShiny app 是实现此目的的好方法，因为它可以让您避免繁琐的修改和重新运行 R 代码。\n下面我将这些片段封装到一个 Shiny app 中，我可以在其中交互式地调整输入。让我们从 UI 开始。\n我们将回到 Section ?? 中 fluidRow() 和 column() 的具体用途；但你可以从他们的名字猜出他们的目的😄。\n第一行有三列用于 input controls（distribution 1, distribution 2, plot controls）。\n第二行有一个宽的列用于绘图，一个窄的列用于假设检验。指定分布绘制后，server 函数结合了对 freqpoly() 和 t_test() 函数的调用：\nFigure 3.6: 一个 Shiny app，可让您使用 t-test 和频数多边形来比较两个模拟分布。 See live https://hadley.shinyapps.io/ms-case-study-1.\nserver 和 ui 的定义如 Figure 3.6 所示。\n您可以在 https://hadley.shinyapps.io/ms-case-study-1 找到实时版本；我建议您打开该 app 并快速玩一下，以确保您在继续阅读之前了解其基本操作。","code":"\nui <- fluidPage(\n  fluidRow(\n    column(4, \n      \"Distribution 1\",\n      numericInput(\"n1\", label = \"n\", value = 1000, min = 1),\n      numericInput(\"mean1\", label = \"µ\", value = 0, step = 0.1),\n      numericInput(\"sd1\", label = \"σ\", value = 0.5, min = 0.1, step = 0.1)\n    ),\n    column(4, \n      \"Distribution 2\",\n      numericInput(\"n2\", label = \"n\", value = 1000, min = 1),\n      numericInput(\"mean2\", label = \"µ\", value = 0, step = 0.1),\n      numericInput(\"sd2\", label = \"σ\", value = 0.5, min = 0.1, step = 0.1)\n    ),\n    column(4,\n      \"Frequency polygon\",\n      numericInput(\"binwidth\", label = \"Bin width\", value = 0.1, step = 0.1),\n      sliderInput(\"range\", label = \"range\", value = c(-3, 3), min = -5, max = 5)\n    )\n  ),\n  fluidRow(\n    column(9, plotOutput(\"hist\")),\n    column(3, verbatimTextOutput(\"ttest\"))\n  )\n)\nserver <- function(input, output, session) {\n  output$hist <- renderPlot({\n    x1 <- rnorm(input$n1, input$mean1, input$sd1)\n    x2 <- rnorm(input$n2, input$mean2, input$sd2)\n    \n    freqpoly(x1, x2, binwidth = input$binwidth, xlim = input$range)\n  }, res = 96)\n\n  output$ttest <- renderText({\n    x1 <- rnorm(input$n1, input$mean1, input$sd1)\n    x2 <- rnorm(input$n2, input$mean2, input$sd2)\n    \n    t_test(x1, x2)\n  })\n}"},{"path":"basic-reactivity.html","id":"the-reactive-graph-1","chapter":"3 Basic reactivity","heading":"3.4.3 The reactive graph","text":"让我们首先绘制这个 app 的响应式图。\nShiny 足够聪明，只有当它引用的输入发生变化时才会更新输出；它不够智能，无法仅选择性地运行输出中的代码片段。\n换句话说，输出是原子的：它们要么被执行，要么不作为一个整体执行。例如，从 server 获取此片段：作为阅读这段代码的人，您可以看出，当 n1、mean1 或 sd1 更改时，我们只需要更新 x1，当 n2、mean2 或 sd2 更改时，我们只需要更新 x2。\n然而，Shiny 只将输出视为一个整体，因此每当 n1、mean1、sd1、n2、mean2 或 sd2 之一发生变化时，它都会更新 x1 和 x2。\n这导致响应式图如 Figure 3.7 所示：\nFigure 3.7: 响应式图显示每个输出都取决于每个输入\n您会注意到该图非常密集：几乎每个输入都直接连接到每个输出。\n这会产生两个问题：该 app 很难理解，因为有很多连接。\n该 app 中没有任何部分可以单独提取和分析。该 app 很难理解，因为有很多连接。\n该 app 中没有任何部分可以单独提取和分析。该 app 效率低下，因为它做了超出必要的工作。\n例如，如果更改绘图的 breaks，则会重新计算数据；如果更改 n1 的值，x2 也会更新（在两个地方！）。该 app 效率低下，因为它做了超出必要的工作。\n例如，如果更改绘图的 breaks，则会重新计算数据；如果更改 n1 的值，x2 也会更新（在两个地方！）。该 app 还有另一个主要缺陷：频率多边形和 t-test 使用单独的随机抽取。\n这是相当误导的，因为您期望他们处理相同的基础数据。幸运的是，我们可以通过使用响应式表达式来消除重复计算来解决所有这些问题。","code":"\nx1 <- rnorm(input$n1, input$mean1, input$sd1)\nx2 <- rnorm(input$n2, input$mean2, input$sd2)\nt_test(x1, x2)"},{"path":"basic-reactivity.html","id":"simplifying-the-graph","chapter":"3 Basic reactivity","heading":"3.4.4 Simplifying the graph","text":"在下面的 server 函数中，我们重构现有代码，将重复的代码提取为两个新的响应式表达式 x1 和 x2，它们模拟来自两个分布的数据。\n为了创建响应式表达式，我们调用 reactive() 并将结果分配给一个变量。\n为了稍后使用该表达式，我们将变量称为函数。这种转换产生了 Figure 3.8 所示的更加简单的图。\n这个更简单的图使您更容易理解 app，因为您可以单独理解连接的组件；分布参数的值仅影响通过 x1 和 x2 的输出。\n这种重写还使 app 更加高效，因为它执行的计算要少得多。\n现在，当您更改 binwidth 或 range 时，只有绘图发生变化，而不是基础数据。\nFigure 3.8: 使用响应式表达式可以大大简化图，使其更容易理解\n为了强调这种模块化，Figure 3.9 在独立组件周围画了方框。\n当我们讨论模块时，我们将在 Chapter ?? 中回到这个想法。\n模块允许您提取重复的代码以供重复使用，同时保证它与 app 中的其他所有内容隔离。\n对于更复杂的 apps 来说，模块是一种非常有用且强大的技术。\nFigure 3.9: 模块强制 app 各部分之间的隔离\n您可能熟悉编程的“三规则”：每当您将某些内容复制并粘贴三次时，您应该弄清楚如何减少重复（通常通过编写函数）。\n这很重要，因为它减少了代码中的重复量，这使得代码更容易理解，并且随着需求的变化更容易更新。然而，在 Shiny 中，我认为您应该考虑一则规则：每当您复制并粘贴某些内容一次时，您应该考虑将重复的代码提取到响应式表达式中。\n该规则对于 Shiny 来说更为严格，因为响应式表达式不仅使人们更容易理解代码，还提高了 Shiny 有效重新运行代码的能力。","code":"\nserver <- function(input, output, session) {\n  x1 <- reactive(rnorm(input$n1, input$mean1, input$sd1))\n  x2 <- reactive(rnorm(input$n2, input$mean2, input$sd2))\n\n  output$hist <- renderPlot({\n    freqpoly(x1(), x2(), binwidth = input$binwidth, xlim = input$range)\n  }, res = 96)\n\n  output$ttest <- renderText({\n    t_test(x1(), x2())\n  })\n}"},{"path":"basic-reactivity.html","id":"reactive-roadblocks","chapter":"3 Basic reactivity","heading":"3.4.5 Why do we need reactive expressions?","text":"当您第一次开始使用响应式代码时，您可能想知道为什么我们需要响应式表达式。\n为什么不能使用现有的工具来减少代码重复：创建新变量和编写函数？\n不幸的是，这些技术都不能在响应式环境中工作。如果您尝试使用变量来减少重复，您可能会编写如下内容：如果运行此代码，您将收到报错，因为您正在尝试访问响应式上下文之外的输入值。\n即使您没有收到该报错，您仍然会遇到问题：x1 和 x2 只会在会话开始时计算一次，而不是每次更新其中一个输入时计算。如果您尝试使用一个函数，该 app 将运行：但它与原始代码存在相同的问题：任何输入都会导致所有输出重新计算，并且 t-test 和频数多边形将在单独的样本上运行。\n响应式表达式会自动缓存其结果，并且仅在其输入更改时更新13。虽然变量只计算一次值（粥太冷），函数每次调用时都计算值（粥太热），但响应式表达式仅在值可能发生变化时才计算值（粥正好是正确的！）。","code":"\nserver <- function(input, output, session) {\n  x1 <- rnorm(input$n1, input$mean1, input$sd1)\n  x2 <- rnorm(input$n2, input$mean2, input$sd2)\n\n  output$hist <- renderPlot({\n    freqpoly(x1, x2, binwidth = input$binwidth, xlim = input$range)\n  }, res = 96)\n\n  output$ttest <- renderText({\n    t_test(x1, x2)\n  })\n}\nserver <- function(input, output, session) { \n  x1 <- function() rnorm(input$n1, input$mean1, input$sd1)\n  x2 <- function() rnorm(input$n2, input$mean2, input$sd2)\n\n  output$hist <- renderPlot({\n    freqpoly(x1(), x2(), binwidth = input$binwidth, xlim = input$range)\n  }, res = 96)\n\n  output$ttest <- renderText({\n    t_test(x1(), x2())\n  })\n}"},{"path":"basic-reactivity.html","id":"controlling-timing-of-evaluation","chapter":"3 Basic reactivity","heading":"3.5 Controlling timing of evaluation","text":"现在您已经熟悉了响应式的基本思想，我们将讨论两种更高级的技术，这些技术允许您增加或减少响应式表达式的执行频率。\n在这里我将展示如何使用基本技术；在 Chapter ?? 中，我们将回到它们的底层实现。为了探索基本想法，我将简化我的模拟 app。\n我将使用只有一个参数的分布，并强制两个样本共享相同的 n。\n我还将删除绘图控件。\n这会产生一个更小的 UI 对象和 server 函数：这会生成如 Figure 3.10 所示的 app 和如 Figure 3.11 所示的响应式图。\nFigure 3.10: 一个更简单的 app，显示从两个泊松分布中提取的随机数的频率多边形。 See live https://hadley.shinyapps.io/ms-simulation-2.\n\nFigure 3.11: reactive graph\n","code":"\nui <- fluidPage(\n  fluidRow(\n    column(3, \n      numericInput(\"lambda1\", label = \"lambda1\", value = 3),\n      numericInput(\"lambda2\", label = \"lambda2\", value = 5),\n      numericInput(\"n\", label = \"n\", value = 1e4, min = 0)\n    ),\n    column(9, plotOutput(\"hist\"))\n  )\n)\nserver <- function(input, output, session) {\n  x1 <- reactive(rpois(input$n, input$lambda1))\n  x2 <- reactive(rpois(input$n, input$lambda2))\n  output$hist <- renderPlot({\n    freqpoly(x1(), x2(), binwidth = 1, xlim = c(0, 40))\n  }, res = 96)\n}"},{"path":"basic-reactivity.html","id":"timed-invalidation","chapter":"3 Basic reactivity","heading":"3.5.1 Timed invalidation","text":"想象一下，您想通过不断重新模拟数据来强化这是针对模拟数据的事实，以便您看到动画而不是静态图14。\n我们可以使用一个新函数来增加更新频率：reactiveTimer()。reactiveTimer() 是一个响应式表达式，它依赖于隐藏输入：当前时间。\n当您希望响应式表达式比其他方式更频繁地使自身无效时，可以使用 reactiveTimer()。\n例如，以下代码使用 500 ms 的间隔，以便绘图每秒更新两次。\n这个速度足够快，足以提醒您正在查看模拟，而不会因快速的变化而感到头晕。\n此更改产生如 Figure 3.12 所示的响应式图\nFigure 3.12: reactiveTimer(500) 引入了一种新的响应式输入，每半秒自动失效一次\n请注意我们如何在计算 x1() 和 x2() 的响应式表达式中使用 timer()：我们调用它，但不使用该值。\n这让 x1 和 x2 对 timer 产生响应式依赖，而不必担心它返回的具体值。","code":"\nserver <- function(input, output, session) {\n  timer <- reactiveTimer(500)\n  \n  x1 <- reactive({\n    timer()\n    rpois(input$n, input$lambda1)\n  })\n  x2 <- reactive({\n    timer()\n    rpois(input$n, input$lambda2)\n  })\n  \n  output$hist <- renderPlot({\n    freqpoly(x1(), x2(), binwidth = 1, xlim = c(0, 40))\n  }, res = 96)\n}"},{"path":"basic-reactivity.html","id":"on-click","chapter":"3 Basic reactivity","heading":"3.5.2 On click","text":"在上面的场景中，想一想如果模拟代码运行时间为 1 秒会发生什么。\n我们每 0.5s 执行一次模拟，因此 Shiny 要做的事情会越来越多，并且永远无法赶上。\n如果有人快速单击 app 中的按钮并且您正在进行的计算相对昂贵，也会发生同样的问题。\n有可能为 Shiny 创建大量积压工作，并且在处理积压工作时，它无法响应任何新事件。\n这会导致糟糕的用户体验。如果您的 app 中出现这种情况，您可能希望要求用户通过单击按钮来选择执行昂贵的计算。\n这是 actionButton() 的一个很好的用例：要使用 action button，我们需要学习一种新工具。\n要了解原因，我们首先使用与上述相同的方法来解决问题。\n如上所述，我们引用 simulate 时不使用其值来对其进行响应式依赖。\nFigure 3.13: App action button. See live https://hadley.shinyapps.io/ms-action-button.\n\nFigure 3.14: 这个响应式图并没有实现我们的目标；我们添加了一个依赖项，而不是替换现有的依赖项。\n这会产生 Figure 3.13 中的 app 和 Figure 3.14 中的响应式图。\n这并没有达到我们的目标，因为它只是引入了一个新的依赖项：当我们单击 simulate 按钮时，x1() 和 x2() 将更新，但当 lambda1、lambda2 或 n 更改时，它们也会继续更新。\n我们想要替换现有的依赖项，而不是添加它们。为了解决这个问题，我们需要一个新工具：一种使用输入值而不对其产生响应式依赖的方法。\n我们需要 eventReactive()，它有两个参数：第一个参数指定要依赖的内容，第二个参数指定要计算的内容。\n这使得该 app 仅在单击 simulate 时计算 x1() 和 x2()：Figure 3.15 显示了新的响应式图。\n请注意，根据需要，x1 和 x2 不再对 lambda1、lambda2 和 n 具有响应式依赖：更改它们的值将不会触发计算。\n我将箭头保留为非常浅的灰色，只是为了提醒您 x1 和 x2 继续使用这些值，但不再对它们产生响应式依赖。\nFigure 3.15: eventReactive() 可以将依赖项（黑色箭头）与用于计算结果的值（浅灰色箭头）分开。\n","code":"\nui <- fluidPage(\n  fluidRow(\n    column(3, \n      numericInput(\"lambda1\", label = \"lambda1\", value = 3),\n      numericInput(\"lambda2\", label = \"lambda2\", value = 5),\n      numericInput(\"n\", label = \"n\", value = 1e4, min = 0),\n      actionButton(\"simulate\", \"Simulate!\")\n    ),\n    column(9, plotOutput(\"hist\"))\n  )\n)\nserver <- function(input, output, session) {\n  x1 <- reactive({\n    input$simulate\n    rpois(input$n, input$lambda1)\n  })\n  x2 <- reactive({\n    input$simulate\n    rpois(input$n, input$lambda2)\n  })\n  output$hist <- renderPlot({\n    freqpoly(x1(), x2(), binwidth = 1, xlim = c(0, 40))\n  }, res = 96)\n}\nserver <- function(input, output, session) {\n  x1 <- eventReactive(input$simulate, {\n    rpois(input$n, input$lambda1)\n  })\n  x2 <- eventReactive(input$simulate, {\n    rpois(input$n, input$lambda2)\n  })\n\n  output$hist <- renderPlot({\n    freqpoly(x1(), x2(), binwidth = 1, xlim = c(0, 40))\n  }, res = 96)\n}"},{"path":"basic-reactivity.html","id":"observers","chapter":"3 Basic reactivity","heading":"3.6 Observers","text":"到目前为止，我们关注的是 app 内部发生的事情。\n但有时您需要到达 app 之外，并导致世界其他地方发生副作用。\n这可能是将文件保存到共享网络驱动器、将数据发送到 Web API、更新数据库或（最常见）将调试消息打印到控制台。\n这些操作不会影响 app 的外观，因此您不应使用输出和 render 函数。\n相反，您需要使用观察者（observer）。创建观察者的方法有多种，我们将在 Section ?? 稍后再讨论它们。\n现在，我想向您展示如何使用 observeEvent()，因为当您第一次学习 Shiny 时，它为您提供了一个重要的调试工具。observeEvent() 与 eventReactive() 非常相似。\n它有两个重要的参数：eventExpr 和 handlerExpr。\n第一个参数是要依赖的输入或表达式；第二个参数是将运行的代码。\n例如，对 server() 进行以下修改意味着每次更新 name 时，都会向控制台发送一条消息：observeEvent() 和 eventReactive() 之间有两个重要的区别：您没有将 observeEvent() 的结果分配给变量，因此你不能从其他响应式消费者那里引用它。观察者和输出密切相关。\n您可以将输出视为具有特殊的副作用：更新用户浏览器中的 HTML。\n为了强调这种接近性，我们将在响应式图中以相同的方式绘制它们。\n这会产生如 Figure 3.16 所示的响应式图。\nFigure 3.16: 在响应式图中，observer 看起来与 output 相同\n","code":"\nui <- fluidPage(\n  textInput(\"name\", \"What's your name?\"),\n  textOutput(\"greeting\")\n)\n\nserver <- function(input, output, session) {\n  string <- reactive(paste0(\"Hello \", input$name, \"!\"))\n  \n  output$greeting <- renderText(string())\n  observeEvent(input$name, {\n    message(\"Greeting performed\")\n  })\n}"},{"path":"basic-reactivity.html","id":"summary-2","chapter":"3 Basic reactivity","heading":"3.7 Summary","text":"本章应该可以提高您对 Shiny apps 后端（响应用户操作的 server() 代码）的理解。\n您还迈出了掌握支撑 Shiny 的响应式编程范例的第一步。\n你在这里学到的东西将会带你走很长的路；我们将在 Chapter ?? 中回到基本理论。\n响应式非常强大，但它与您最习惯的 R 编程的命令式风格也有很大不同。\n如果需要一段时间才能了解所有后果，请不要感到惊讶。本章总结了我们对 Shiny 基础的概述。\n下一章将通过创建一个旨在支持数据分析的更大的 Shiny app 来帮助您练习到目前为止所看到的材料。","code":""},{"path":"basic-case-study.html","id":"basic-case-study","chapter":"4 Case study: ER injuries","heading":"4 Case study: ER injuries","text":"","code":""},{"path":"basic-case-study.html","id":"introduction-3","chapter":"4 Case study: ER injuries","heading":"4.1 Introduction","text":"’ve introduced bunch new concepts last three chapters.\nhelp sink , ’ll now walk richer Shiny app explores fun dataset pulls together many ideas ’ve seen far.\n’ll start little data analysis outside Shiny, turn app, starting simply, progressively layering detail.chapter, ’ll supplement Shiny vroom (fast file reading) tidyverse (general data analysis).","code":"\nlibrary(shiny)\nlibrary(vroom)\n#> Warning: package 'vroom' was built under R version 4.2.3\nlibrary(tidyverse)\n#> Warning: package 'tidyverse' was built under R version 4.2.3\n#> Warning: package 'ggplot2' was built under R version 4.2.3\n#> Warning: package 'tibble' was built under R version 4.2.3\n#> Warning: package 'tidyr' was built under R version 4.2.3\n#> Warning: package 'readr' was built under R version 4.2.3\n#> Warning: package 'purrr' was built under R version 4.2.3\n#> Warning: package 'dplyr' was built under R version 4.2.3\n#> Warning: package 'stringr' was built under R version 4.2.2\n#> Warning: package 'forcats' was built under R version 4.2.3\n#> Warning: package 'lubridate' was built under R version 4.2.3"},{"path":"basic-case-study.html","id":"the-data","chapter":"4 Case study: ER injuries","heading":"4.2 The data","text":"’re going explore data National Electronic Injury Surveillance System (NEISS), collected Consumer Product Safety Commission.\nlong-term study records accidents seen representative sample hospitals United States.\n’s interesting dataset explore every one already familiar domain, observation accompanied short narrative explains accident occurred.\ncan find dataset https://github.com/hadley/neiss.chapter, ’m going focus just data 2017.\nkeeps data small enough (~10 MB) ’s easy store git (along rest book), means don’t need think sophisticated strategies importing data quickly (’ll come back later book).\ncan see code used create extract chapter https://github.com/hadley/mastering-shiny/blob/master/neiss/data.R.want get data computer, run code:main dataset ’ll use injuries, contains around 250,000 observations:row represents single accident 10 variables:trmt_date date person seen hospital (accident occurred).trmt_date date person seen hospital (accident occurred).age, sex, race give demographic information person experienced accident.age, sex, race give demographic information person experienced accident.body_part location injury body (like ankle ear); location place accident occurred (like home school).body_part location injury body (like ankle ear); location place accident occurred (like home school).diag gives basic diagnosis injury (like fracture laceration).diag gives basic diagnosis injury (like fracture laceration).prod_code primary product associated injury.prod_code primary product associated injury.weight statistical weight giving estimated number people suffer injury dataset scaled entire population US.weight statistical weight giving estimated number people suffer injury dataset scaled entire population US.narrative brief story accident occurred.narrative brief story accident occurred.’ll pair two data frames additional context: products lets us look product name product code, population tells us total US population 2017 combination age sex.","code":"\ndir.create(\"neiss\")\ndownload <- function(name) {\n  url <- \"https://github.com/hadley/mastering-shiny/blob/main/neiss/\"\n  download.file(paste0(url, name), paste0(\"neiss/\", name), quiet = TRUE)\n}\ndownload(\"injuries.tsv.gz\")\ndownload(\"population.tsv\")\ndownload(\"products.tsv\")\ninjuries <- vroom::vroom(\"neiss/injuries.tsv.gz\")\ninjuries\n#> # A tibble: 255,064 × 10\n#>   trmt_date    age sex   race  body_part   diag         location prod_code weight\n#>   <date>     <dbl> <chr> <chr> <chr>       <chr>        <chr>        <dbl>  <dbl>\n#> 1 2017-01-01    71 male  white Upper Trunk Contusion O… Other P…      1807   77.7\n#> 2 2017-01-01    16 male  white Lower Arm   Burns, Ther… Home           676   77.7\n#> 3 2017-01-01    58 male  white Upper Trunk Contusion O… Home           649   77.7\n#> 4 2017-01-01    21 male  white Lower Trunk Strain, Spr… Home          4076   77.7\n#> 5 2017-01-01    54 male  white Head        Inter Organ… Other P…      1807   77.7\n#> 6 2017-01-01    21 male  white Hand        Fracture     Home          1884   77.7\n#> # ℹ 255,058 more rows\n#> # ℹ 1 more variable: narrative <chr>\nproducts <- vroom::vroom(\"neiss/products.tsv\")\nproducts\n#> # A tibble: 38 × 2\n#>   prod_code title                            \n#>       <dbl> <chr>                            \n#> 1       464 knives, not elsewhere classified \n#> 2       474 tableware and accessories        \n#> 3       604 desks, chests, bureaus or buffets\n#> 4       611 bathtubs or showers              \n#> 5       649 toilets                          \n#> 6       676 rugs or carpets, not specified   \n#> # ℹ 32 more rows\n\npopulation <- vroom::vroom(\"neiss/population.tsv\")\npopulation\n#> # A tibble: 170 × 3\n#>     age sex    population\n#>   <dbl> <chr>       <dbl>\n#> 1     0 female    1924145\n#> 2     0 male      2015150\n#> 3     1 female    1943534\n#> 4     1 male      2031718\n#> 5     2 female    1965150\n#> 6     2 male      2056625\n#> # ℹ 164 more rows"},{"path":"basic-case-study.html","id":"exploration","chapter":"4 Case study: ER injuries","heading":"4.3 Exploration","text":"create app, let’s explore data little.\n’ll start looking product interesting story: 649, “toilets”.\nFirst ’ll pull injuries associated product:Next ’ll perform basic summaries looking location, body part, diagnosis toilet related injuries.\nNote weight weight variable counts can interpreted estimated total injuries across whole US.might expect, injuries involving toilets often occur home.\ncommon body parts involved possibly suggest falls (since head face usually involved routine toilet usage), diagnoses seem rather varied.can also explore pattern across age sex.\nenough data table useful, make plot, Figure 4.1, makes patterns obvious.\nFigure 4.1: Estimated number injuries caused toilets, broken age sex\nsee spike young boys peaking age 3, increase (particularly women) starting around middle age, gradual decline age 80.\nsuspect peak boys usually use toilet standing , increase women due osteoporosis (.e. suspect women men injuries rate, women end ER higher risk fractures).One problem interpreting pattern know fewer older people younger people, population available injured smaller.\ncan control comparing number people injured total population calculating injury rate.\nuse rate per 10,000.Plotting rate, Figure 4.2, yields strikingly different trend age 50: difference men women much smaller, longer see decrease.\nwomen tend live longer men, older ages simply women alive injured toilets.\nFigure 4.2: Estimated rate injuries per 10,000 people, broken age sex\n(Note rates go age 80 couldn’t find population data ages 80.)Finally, can look narratives.\nBrowsing informal way check hypotheses, generate new ideas exploration.\npull random sample 10:done exploration one product, nice easily products, without retype code.\nlet’s make Shiny app!","code":"\nselected <- injuries %>% filter(prod_code == 649)\nnrow(selected)\n#> [1] 2993\nselected %>% count(location, wt = weight, sort = TRUE)\n#> # A tibble: 6 × 2\n#>   location                         n\n#>   <chr>                        <dbl>\n#> 1 Home                       99603. \n#> 2 Other Public Property      18663. \n#> 3 Unknown                    16267. \n#> 4 School                       659. \n#> 5 Street Or Highway             16.2\n#> 6 Sports Or Recreation Place    14.8\n\nselected %>% count(body_part, wt = weight, sort = TRUE)\n#> # A tibble: 24 × 2\n#>   body_part        n\n#>   <chr>        <dbl>\n#> 1 Head        31370.\n#> 2 Lower Trunk 26855.\n#> 3 Face        13016.\n#> 4 Upper Trunk 12508.\n#> 5 Knee         6968.\n#> 6 N.S./Unk     6741.\n#> # ℹ 18 more rows\n\nselected %>% count(diag, wt = weight, sort = TRUE)\n#> # A tibble: 20 × 2\n#>   diag                       n\n#>   <chr>                  <dbl>\n#> 1 Other Or Not Stated   32897.\n#> 2 Contusion Or Abrasion 22493.\n#> 3 Inter Organ Injury    21525.\n#> 4 Fracture              21497.\n#> 5 Laceration            18734.\n#> 6 Strain, Sprain         7609.\n#> # ℹ 14 more rows\nsummary <- selected %>% \n  count(age, sex, wt = weight)\nsummary\n#> # A tibble: 208 × 3\n#>     age sex         n\n#>   <dbl> <chr>   <dbl>\n#> 1     0 female   4.76\n#> 2     0 male    14.3 \n#> 3     1 female 253.  \n#> 4     1 male   231.  \n#> 5     2 female 438.  \n#> 6     2 male   632.  \n#> # ℹ 202 more rows\n\nsummary %>% \n  ggplot(aes(age, n, colour = sex)) + \n  geom_line() + \n  labs(y = \"Estimated number of injuries\")\nsummary <- selected %>% \n  count(age, sex, wt = weight) %>% \n  left_join(population, by = c(\"age\", \"sex\")) %>% \n  mutate(rate = n / population * 1e4)\n\nsummary\n#> # A tibble: 208 × 5\n#>     age sex         n population   rate\n#>   <dbl> <chr>   <dbl>      <dbl>  <dbl>\n#> 1     0 female   4.76    1924145 0.0247\n#> 2     0 male    14.3     2015150 0.0708\n#> 3     1 female 253.      1943534 1.30  \n#> 4     1 male   231.      2031718 1.14  \n#> 5     2 female 438.      1965150 2.23  \n#> 6     2 male   632.      2056625 3.07  \n#> # ℹ 202 more rows\nsummary %>% \n  ggplot(aes(age, rate, colour = sex)) + \n  geom_line(na.rm = TRUE) + \n  labs(y = \"Injuries per 10,000 people\")\nselected %>% \n  sample_n(10) %>% \n  pull(narrative)\n#>  [1] \"56 YOF FACE CONTUSION, GETTING OFF COMMODE WHEN SHE FELL FORWARD HITTING FACE ON TILE FLOOR\"                                        \n#>  [2] \"87 YOF - LAC HEAD - PT FELL ASLEEP ON THE TOILET AND FELL HITTINGHEAD ON THE FLOOR @H OME.\"                                         \n#>  [3] \"72YM ON *** FOR AF,FD BY FAMILY DOWN ON THE BR FLOOR UNRESPONSIVE,PERUMED FALL FROM THE TOILET>>ICH, PTX, CARDIAC ARREST\"           \n#>  [4] \"63YOF STS THAT WAS TRANSFERING FROM BED TO PORTABLE TOILET & FELL ONTOL WRIST ON GRD,12 HRS PTA ,NO HD INJURY DX CLSD FX OF L WRIST\"\n#>  [5] \"82 Y F FOING TO RESTROOM AT NURISNG HOME MISSED TOILET FELL AND STRUCKHEAD ON WALL DX HEAD INJURY\"                                  \n#>  [6] \"89 YOM SUSTAINED A LEFT RIB FX AFTER FALLING FROM THE TOILET TO THE FLOOR\"                                                          \n#>  [7] \"26YOM  ABRASION FACE - FELL FROM TOILET\"                                                                                            \n#>  [8] \"CHI, NASAL BONE FX. 93 YOF FELL OFF OF A TOILET AND ONTO THE FLOOR.\"                                                                \n#>  [9] \"41YOM INJ/BP NS- VOMITING IN TOILET, FELL TO FLOOR\"                                                                                 \n#> [10] \"60 YOM SLIPPED AND FELL IN BATHROOM HITTING TOILET.DX:  CONCUSSION, CONT L KNEE, CONT BACK,FINGER LAC.\""},{"path":"basic-case-study.html","id":"prototype","chapter":"4 Case study: ER injuries","heading":"4.4 Prototype","text":"building complex app, strongly recommend starting simple possible, can confirm basic mechanics work start something complicated.\n’ll start one input (product code), three tables, one plot.designing first prototype, challenge making “simple possible”.\n’s tension getting basics working quickly planning future app.\nEither extreme can bad: design narrowly, ’ll spend lot time later reworking app; design rigorously, ’ll spend bunch time writing code later ends cutting floor.\nhelp get balance right, often pencil--paper sketches rapidly explore UI reactive graph committing code.decided one row inputs (accepting ’m probably going add inputs app done), one row three tables (giving table 4 columns, 1/3 12 column width), one row plot:haven’t talked fluidRow() column() yet, able guess context, ’ll come back talk Section ??.\nAlso note use setNames() selectInput() choices: shows product name UI returns product code server.server function relatively straightforward.\nfirst convert selected summary variables created previous section reactive expressions.\nreasonable general pattern: create variables data analysis decompose analysis steps, avoid recomputing things multiple times, reactive expressions play role Shiny apps.Often ’s good idea spend little time cleaning analysis code start Shiny app, can think problems regular R code, add additional complexity reactivity.Note creating summary reactive isn’t strictly necessary , ’s used single reactive consumer.\n’s good practice keep computing plotting separate makes flow app easier understand, make easier generalise future.screenshot resulting app shown Figure 4.3.\ncan find source code https://github.com/hadley/mastering-shiny/tree/main/neiss/prototype.R try live version app https://hadley.shinyapps.io/ms-prototype/.\nFigure 4.3: First prototype NEISS exploration app\n","code":"\nprod_codes <- setNames(products$prod_code, products$title)\n\nui <- fluidPage(\n  fluidRow(\n    column(6,\n      selectInput(\"code\", \"Product\", choices = prod_codes)\n    )\n  ),\n  fluidRow(\n    column(4, tableOutput(\"diag\")),\n    column(4, tableOutput(\"body_part\")),\n    column(4, tableOutput(\"location\"))\n  ),\n  fluidRow(\n    column(12, plotOutput(\"age_sex\"))\n  )\n)\nserver <- function(input, output, session) {\n  selected <- reactive(injuries %>% filter(prod_code == input$code))\n\n  output$diag <- renderTable(\n    selected() %>% count(diag, wt = weight, sort = TRUE)\n  )\n  output$body_part <- renderTable(\n    selected() %>% count(body_part, wt = weight, sort = TRUE)\n  )\n  output$location <- renderTable(\n    selected() %>% count(location, wt = weight, sort = TRUE)\n  )\n\n  summary <- reactive({\n    selected() %>%\n      count(age, sex, wt = weight) %>%\n      left_join(population, by = c(\"age\", \"sex\")) %>%\n      mutate(rate = n / population * 1e4)\n  })\n\n  output$age_sex <- renderPlot({\n    summary() %>%\n      ggplot(aes(age, n, colour = sex)) +\n      geom_line() +\n      labs(y = \"Estimated number of injuries\")\n  }, res = 96)\n}"},{"path":"basic-case-study.html","id":"polish-tables","chapter":"4 Case study: ER injuries","heading":"4.5 Polish tables","text":"Now basic components place working, can progressively improve app.\nfirst problem app shows lot information tables, probably just want highlights.\nfix need first figure truncate tables.\n’ve chosen combination forcats functions: convert variable factor, order frequency levels, lump together levels top 5.knew , wrote little function automate variable.\ndetails aren’t really important , ’ll come back Chapter ??.\nalso solve problem copy paste, don’t worry code looks totally foreign.use server function:made one change improve aesthetics app: forced tables take maximum width (.e. fill column appear ).\nmakes output aesthetically pleasing reduces amount incidental variation.screenshot resulting app shown Figure 4.4.\ncan find source code https://github.com/hadley/mastering-shiny/tree/main/neiss/polish-tables.R try live version app https://hadley.shinyapps.io/ms-polish-tables.\nFigure 4.4: second iteration app improves display showing frequent rows summary tables\n","code":"\ninjuries %>%\n  mutate(diag = fct_lump(fct_infreq(diag), n = 5)) %>%\n  group_by(diag) %>%\n  summarise(n = as.integer(sum(weight)))\n#> # A tibble: 6 × 2\n#>   diag                        n\n#>   <fct>                   <int>\n#> 1 Other Or Not Stated   1806436\n#> 2 Fracture              1558961\n#> 3 Laceration            1432407\n#> 4 Strain, Sprain        1432556\n#> 5 Contusion Or Abrasion 1451987\n#> 6 Other                 1929147\ncount_top <- function(df, var, n = 5) {\n  df %>%\n    mutate({{ var }} := fct_lump(fct_infreq({{ var }}), n = n)) %>%\n    group_by({{ var }}) %>%\n    summarise(n = as.integer(sum(weight)))\n}\n  output$diag <- renderTable(count_top(selected(), diag), width = \"100%\")\n  output$body_part <- renderTable(count_top(selected(), body_part), width = \"100%\")\n  output$location <- renderTable(count_top(selected(), location), width = \"100%\")"},{"path":"basic-case-study.html","id":"rate-vs-count","chapter":"4 Case study: ER injuries","heading":"4.6 Rate vs count","text":"far, ’re displaying single plot, ’d like give user choice visualising number injuries population-standardised rate.\nFirst add control UI.\n’ve chosen use selectInput() makes states explicit, easy add new states future:(default rate think ’s safer; don’t need understand population distribution order correctly interpret plot.)condition input generating plot:screenshot resulting app shown Figure 4.5.\ncan find source code https://github.com/hadley/mastering-shiny/tree/main/neiss/rate-vs-count.R try live version app https://hadley.shinyapps.io/ms-rate-vs-count.\nFigure 4.5: iteration, give user ability switch displaying count population standardised rate y-axis.\n","code":"  fluidRow(\n    column(8,\n      selectInput(\"code\", \"Product\",\n        choices = setNames(products$prod_code, products$title),\n        width = \"100%\"\n      )\n    ),\n    column(2, selectInput(\"y\", \"Y axis\", c(\"rate\", \"count\")))\n  ),\n  output$age_sex <- renderPlot({\n    if (input$y == \"count\") {\n      summary() %>%\n        ggplot(aes(age, n, colour = sex)) +\n        geom_line() +\n        labs(y = \"Estimated number of injuries\")\n    } else {\n      summary() %>%\n        ggplot(aes(age, rate, colour = sex)) +\n        geom_line(na.rm = TRUE) +\n        labs(y = \"Injuries per 10,000 people\")\n    }\n  }, res = 96)"},{"path":"basic-case-study.html","id":"narrative","chapter":"4 Case study: ER injuries","heading":"4.7 Narrative","text":"Finally, want provide way access narratives interesting, give informal way cross-check hypotheses come looking plots.\nR code, sample multiple narratives , ’s reason app can explore interactively.two parts solution.\nFirst add new row bottom UI.\nuse action button trigger new story, put narrative textOutput():use eventReactive() create reactive updates button clicked underlying data changes.screenshot resulting app shown Figure 4.6.\ncan find source code https://github.com/hadley/mastering-shiny/tree/main/neiss/narrative.R try live version app https://hadley.shinyapps.io/ms-narrative.\nFigure 4.6: final iteration adds ability pull random narrative selected rows\n","code":"\n  fluidRow(\n    column(2, actionButton(\"story\", \"Tell me a story\")),\n    column(10, textOutput(\"narrative\"))\n  )\n  narrative_sample <- eventReactive(\n    list(input$story, selected()),\n    selected() %>% pull(narrative) %>% sample(1)\n  )\n  output$narrative <- renderText(narrative_sample())"},{"path":"basic-case-study.html","id":"exercises-4","chapter":"4 Case study: ER injuries","heading":"4.8 Exercises","text":"Draw reactive graph app.Draw reactive graph app.happens flip fct_infreq() fct_lump() code reduces summary tables?happens flip fct_infreq() fct_lump() code reduces summary tables?Add input control lets user decide many rows show summary tables.Add input control lets user decide many rows show summary tables.Provide way step every narrative systematically forward backward buttons.\nAdvanced: Make list narratives “circular” advancing forward last narrative takes first.Provide way step every narrative systematically forward backward buttons.Advanced: Make list narratives “circular” advancing forward last narrative takes first.","code":""},{"path":"basic-case-study.html","id":"summary-3","chapter":"4 Case study: ER injuries","heading":"4.9 Summary","text":"Now basics Shiny apps belt, following seven chapters give grab bag important techniques.\n’ve read next chapter workflow, recommend skimming remaining chapters get good sense cover, dip toes back need techniques app.","code":""}]
